{
  "name": "Market_Analysis_Service_Consolidated",
  "description": "Unified market analysis combining Market Intelligence, Alpha Generation, and Multi-Exchange Arbitrage - comprehensive market data, opportunity detection, and sophisticated analysis with NO mock data",
  "color": "linear-gradient(rgb(110,222,209), rgb(103,176,245))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"function\",\"type\":\"string\",\"description\":\"Function: 'realtime_price_tracking', 'technical_analysis', 'market_sentiment', 'volatility_analysis', 'support_resistance_detection', 'trend_analysis', 'volume_analysis', 'momentum_indicators', 'discover_exchange_assets', 'cross_exchange_price_comparison', 'complete_market_assessment', 'cross_exchange_arbitrage_scanner', 'market_inefficiency_scanner', 'institutional_flow_tracker', 'alpha_generation_coordinator', 'scan_arbitrage', 'triangular_arbitrage', 'cross_asset_arbitrage', 'monitor_spreads', 'calculate_profit'\",\"required\":true},{\"id\":1,\"property\":\"symbols\",\"type\":\"string\",\"description\":\"Comma-separated symbols for analysis (e.g., 'BTC,ETH,SOL')\",\"required\":false},{\"id\":2,\"property\":\"exchanges\",\"type\":\"string\",\"description\":\"Target exchanges: 'all', 'major', or specific list\",\"required\":false},{\"id\":3,\"property\":\"timeframe\",\"type\":\"string\",\"description\":\"Analysis timeframe: '1m', '5m', '15m', '1h', '4h', '1d'\",\"required\":false},{\"id\":4,\"property\":\"min_profit_bps\",\"type\":\"string\",\"description\":\"Minimum profit in basis points for opportunities\",\"required\":false},{\"id\":5,\"property\":\"confidence_threshold\",\"type\":\"string\",\"description\":\"Minimum confidence level: 'high', 'medium', 'low'\",\"required\":false}]",
  "func": "// ===== MARKET ANALYSIS SERVICE - PART 1: CORE CLASSES & EXCHANGE MANAGER =====\n// COMPLETE PRESERVATION WITH ALL SYNTAX FIXES AND REAL DATA ONLY\n\n// ===== DEBUG LOGGING =====\nconsole.log('🔍 DEBUG: Market Analysis called with:');\nconsole.log('- Function:', typeof $function !== 'undefined' ? $function : 'UNDEFINED');\nconsole.log('- Symbols:', typeof $symbols !== 'undefined' ? $symbols : 'UNDEFINED'); \nconsole.log('- Exchanges:', typeof $exchanges !== 'undefined' ? $exchanges : 'UNDEFINED');\nconsole.log('- All parameters:', arguments);\nconsole.log('=====================================');\n\nconst fetch = require('node-fetch');\nconst crypto = require('crypto');\n\n// ===== DYNAMIC EXCHANGE MANAGER - COMPLETE WITH FIXES =====\nclass DynamicExchangeManager {\n    constructor() {\n        this.exchangeConfigs = {\n            binance: {\n                baseUrl: 'https://api.binance.com',\n                endpoints: {\n                    ticker: '/api/v3/ticker/24hr',\n                    klines: '/api/v3/klines',\n                    exchangeInfo: '/api/v3/exchangeInfo',\n                    orderBook: '/api/v3/depth',\n                    avgPrice: '/api/v3/avgPrice'\n                },\n                rateLimits: {\n                    requests: 1200,\n                    weight: 1200\n                }\n            },\n            kraken: {\n                baseUrl: 'https://api.kraken.com',\n                endpoints: {\n                    ticker: '/0/public/Ticker',\n                    ohlc: '/0/public/OHLC',\n                    assets: '/0/public/Assets',\n                    orderBook: '/0/public/Depth',\n                    trades: '/0/public/Trades'\n                },\n                rateLimits: {\n                    requests: 1800,\n                    weight: 1800\n                }\n            },\n            kucoin: {\n                baseUrl: 'https://api.kucoin.com',\n                endpoints: {\n                    ticker: '/api/v1/market/allTickers',\n                    klines: '/api/v1/market/candles',\n                    symbols: '/api/v1/symbols',\n                    orderBook: '/api/v1/market/orderbook/level2_20',\n                    stats: '/api/v1/market/stats'\n                },\n                rateLimits: {\n                    requests: 1500,\n                    weight: 1500\n                }\n            },\n            coingecko: {\n                baseUrl: 'https://api.coingecko.com/api/v3',\n                endpoints: {\n                    price: '/simple/price',\n                    history: '/coins/{id}/market_chart',\n                    trending: '/search/trending',\n                    global: '/global'\n                }\n            }\n        };\n        \n        this.cache = new Map();\n        this.cacheTTL = 30000; // 30 seconds\n        this.rateLimits = new Map();\n        this.circuitBreakers = new Map();\n        this.lastRequestTimes = new Map();\n\n      this.symbolBlacklist = new Set(['ARIA', 'YZY', 'BAS', 'DGC', 'SAPIEN', 'A2Z', 'AWE','MAT', 'FLOCK', 'PROMPT', 'XPIN', 'ALU', 'ZORA']);\n      this.validBinanceSymbols = null; // Will be populated by fetchBinanceAssets\n      \n    }\n\n    // COMPLETE ASSET DISCOVERY - REAL API CALLS ONLY\n   async discoverExchangeAssets() {\n    console.log('🔍 Discovering high-opportunity assets across all exchanges...');\n    const allAssets = new Map();\n    const exchanges = ['binance', 'kraken', 'kucoin'];\n    \n    for (const exchange of exchanges) {\n        try {\n            console.log(`Discovering assets on ${exchange}...`);\n            let assets = [];\n            \n            switch(exchange) {\n                 case 'binance':\n                    // First get valid trading symbols\n                    const exchangeInfoResponse = await fetch(\n                        `${this.exchangeConfigs.binance.baseUrl}/api/v3/exchangeInfo`,\n                        { timeout: 10000, headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' } }\n                    );\n                    \n                    const validSymbols = new Set();\n                    if (exchangeInfoResponse.ok) {\n                        const exchangeInfo = await exchangeInfoResponse.json();\n                        exchangeInfo.symbols\n                            .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')\n                            .forEach(s => validSymbols.add(s.symbol));\n                    }\n                    \n                    const binanceResponse = await fetch(\n                        `${this.exchangeConfigs.binance.baseUrl}/api/v3/ticker/24hr`,\n                        { timeout: 15000, headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' } }\n                    );\n                    \n                    if (binanceResponse.ok) {\n                        const data = await binanceResponse.json();\n                        // DON'T USE 'const assets =' or 'let assets =' - just assign to existing variable\n                        assets = data\n                            .filter(ticker => {\n                                const volume = parseFloat(ticker.quoteVolume);\n                                const symbol = ticker.symbol;\n                                return validSymbols.has(symbol) && \n                                       volume > 500000 &&\n                                       (symbol.endsWith('USDT') || symbol.endsWith('BUSD')) &&\n                                       !symbol.includes('DOWN') && !symbol.includes('UP') &&\n                                       !symbol.startsWith('1000');\n                            })\n                            .map(ticker => ({\n                                symbol: ticker.symbol.replace('USDT', '').replace('BUSD', ''),\n                                exchange: 'binance',\n                                volume24h: parseFloat(ticker.quoteVolume),\n                                priceChangePercent: parseFloat(ticker.priceChangePercent)\n                            }));\n                    }\n                    break;\n                    \n                case 'kraken':\n                    const krakenResponse = await fetch(\n                        `${this.exchangeConfigs.kraken.baseUrl}/0/public/AssetPairs`,\n                        { timeout: 15000, headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' } }\n                    );\n                    if (krakenResponse.ok) {\n                        const data = await krakenResponse.json();\n                        if (data.result) {\n                            const pairs = Object.entries(data.result);\n                            for (const [pair, info] of pairs) {\n                                if (pair.includes('USD') && !pair.includes('.') && info.status === 'online') {\n                                    const baseAsset = info.base.replace('X', '').replace('Z', '');\n                                    if (!allAssets.has(baseAsset)) {\n                                        assets.push({\n                                            symbol: baseAsset,\n                                            exchange: 'kraken',\n                                            volume24h: 0, // Will fetch in price check\n                                            tradingPair: pair\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    break;\n                    \n                case 'kucoin':\n                    const kucoinResponse = await fetch(\n                        `${this.exchangeConfigs.kucoin.baseUrl}/api/v1/market/allTickers`,\n                        { timeout: 15000, headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' } }\n                    );\n                    if (kucoinResponse.ok) {\n                        const data = await kucoinResponse.json();\n                        if (data.data && data.data.ticker) {\n                            assets = data.data.ticker\n                                .filter(ticker => {\n                                    const volume = parseFloat(ticker.volValue || 0);\n                                    const symbol = ticker.symbol;\n                                    return volume > 500000 &&\n                                           symbol.endsWith('-USDT') &&\n                                           !symbol.includes('3L') && !symbol.includes('3S'); // Skip leveraged\n                                })\n                                .map(ticker => ({\n                                    symbol: ticker.symbol.split('-')[0],\n                                    exchange: 'kucoin',\n                                    volume24h: parseFloat(ticker.volValue),\n                                    priceChangePercent: parseFloat(ticker.changeRate) * 100\n                                }));\n                        }\n                    }\n                    break;\n            }\n            \n            // Add to global map\n            assets.forEach(asset => {\n                const key = asset.symbol;\n                if (!allAssets.has(key)) {\n                    allAssets.set(key, {\n                        symbol: key,\n                        exchanges: [asset.exchange],\n                        totalVolume: asset.volume24h,\n                        volatility: Math.abs(asset.priceChangePercent || 0)\n                    });\n                } else {\n                    const existing = allAssets.get(key);\n                    existing.exchanges.push(asset.exchange);\n                    existing.totalVolume += asset.volume24h;\n                    existing.volatility = Math.max(existing.volatility, Math.abs(asset.priceChangePercent || 0));\n                }\n            });\n            \n        } catch (error) {\n            console.warn(`Asset discovery failed for ${exchange}:`, error.message);\n        }\n    }\n    \n    // Filter and tier assets\n    const tieredAssets = this.tierAssets(allAssets);\n    console.log(`Discovered ${tieredAssets.tier1.length} tier-1, ${tieredAssets.tier2.length} tier-2 assets`);\n    \n    this.cache.set('discovered_assets', {\n        data: tieredAssets,\n        timestamp: Date.now()\n    });\n    \n    return tieredAssets;\n}\n\n\n    async fetchBinanceAssets() {\n        const cacheKey = 'binance_assets';\n        const cached = this.cache.get(cacheKey);\n        \n        if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n            return cached.data;\n        }\n        \n        await this.respectRateLimit('binance');\n        \n        const response = await fetch(`${this.exchangeConfigs.binance.baseUrl}/api/v3/exchangeInfo`, {\n            timeout: 10000,\n            headers: {\n                'User-Agent': 'Crypto-Universe-Enterprise/2.0'\n            }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Binance API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n\n        const tradingSymbols = data.symbols\n            .filter(symbol => \n                symbol.status === 'TRADING' && \n                (symbol.quoteAsset === 'USDT' || symbol.quoteAsset === 'BUSD') &&\n                !symbol.baseAsset.includes('DOWN') &&\n                !symbol.baseAsset.includes('UP')\n            )\n            .map(symbol => symbol.baseAsset)\n            .filter((asset, index, arr) => arr.indexOf(asset) === index);\n        \n        // Store valid symbols for validation\n        this.validBinanceSymbols = new Set(tradingSymbols);\n      \n        const assets = data.symbols\n            .filter(symbol => \n                symbol.status === 'TRADING' && \n                (symbol.quoteAsset === 'USDT' || symbol.quoteAsset === 'BUSD' || symbol.quoteAsset === 'USDC')\n            )\n            .map(symbol => symbol.baseAsset)\n            .filter((asset, index, arr) => arr.indexOf(asset) === index)\n            .sort();\n        \n        this.cache.set(cacheKey, {\n            data: assets,\n            timestamp: Date.now()\n        });\n        \n        return assets;\n    }\n\n    tierAssets(allAssets) {\n    const assetArray = Array.from(allAssets.values());\n    \n    // Calculate opportunity score\n    assetArray.forEach(asset => {\n        asset.opportunityScore = \n            (asset.exchanges.length * 10) + // Multi-exchange bonus\n            (asset.totalVolume / 1000000) + // Volume in millions\n            (asset.volatility * 2); // Volatility bonus for arbitrage\n    });\n    \n    // Sort by opportunity score\n    assetArray.sort((a, b) => b.opportunityScore - a.opportunityScore);\n    \n    return {\n        tier1: assetArray.slice(0, 30).map(a => a.symbol),\n        tier2: assetArray.slice(30, 80).map(a => a.symbol),\n        tier3: assetArray.slice(80, 200).map(a => a.symbol),\n        allAssets: assetArray\n    };\n    }\n\n    async fetchKrakenAssets() {\n        const cacheKey = 'kraken_assets';\n        const cached = this.cache.get(cacheKey);\n        \n        if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n            return cached.data;\n        }\n        \n        await this.respectRateLimit('kraken');\n        \n        const response = await fetch(`${this.exchangeConfigs.kraken.baseUrl}/0/public/Assets`, {\n            timeout: 10000,\n            headers: {\n                'User-Agent': 'Crypto-Universe-Enterprise/2.0'\n            }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Kraken API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error && data.error.length > 0) {\n            throw new Error(`Kraken errors: ${data.error.join(', ')}`);\n        }\n        \n        const assets = Object.keys(data.result)\n            .map(asset => asset.replace(/^[XZ]/, '')) // Remove Kraken prefixes\n            .filter(asset => asset.length <= 5 && asset.length >= 2)\n            .sort();\n        \n        this.cache.set(cacheKey, {\n            data: assets,\n            timestamp: Date.now()\n        });\n        \n        return assets;\n    }\n\n    async fetchKucoinAssets() {\n        const cacheKey = 'kucoin_assets';\n        const cached = this.cache.get(cacheKey);\n        \n        if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n            return cached.data;\n        }\n        \n        await this.respectRateLimit('kucoin');\n        \n        const response = await fetch(`${this.exchangeConfigs.kucoin.baseUrl}/api/v1/symbols`, {\n            timeout: 10000,\n            headers: {\n                'User-Agent': 'Crypto-Universe-Enterprise/2.0'\n            }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`KuCoin API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.code !== '200000') {\n            throw new Error(`KuCoin API error: ${data.msg}`);\n        }\n        \n        const assets = data.data\n            .filter(symbol => \n                symbol.enableTrading && \n                (symbol.quoteCurrency === 'USDT' || symbol.quoteCurrency === 'USDC')\n            )\n            .map(symbol => symbol.baseCurrency)\n            .filter((asset, index, arr) => arr.indexOf(asset) === index)\n            .sort();\n        \n        this.cache.set(cacheKey, {\n            data: assets,\n            timestamp: Date.now()\n        });\n        \n        return assets;\n    }\n\n    // COMPLETE REAL-TIME PRICE TRACKING - REAL DATA ONLY\n    async getRealTimePrices(symbols, exchanges) {\n    console.log(`📊 Getting real-time prices for ${symbols.length} symbols across ${exchanges.length} exchanges...`);\n    \n    const results = {};\n    const symbolList = Array.isArray(symbols) ? symbols : symbols.split(',').map(s => s.trim().toUpperCase());\n\n    // Filter out blacklisted symbols if validBinanceSymbols exists\n    const filteredSymbols = symbolList.filter(symbol => {\n        if (this.symbolBlacklist && this.symbolBlacklist.has(symbol)) {\n            console.log(`Skipping blacklisted symbol: ${symbol}`);\n            return false;\n        }\n        return true;\n    });\n    \n    // Use filtered symbols instead\n    const symbolsToProcess = filteredSymbols;\n      \n    const exchangeList = Array.isArray(exchanges) ? exchanges : [exchanges];\n    \n    // Batch processing for efficiency\n    const BATCH_SIZE = 10;\n    const batches = [];\n    for (let i = 0; i < symbolsToProcess.length; i += BATCH_SIZE) {\n        batches.push(symbolsToProcess.slice(i, i + BATCH_SIZE));\n    }\n    \n    for (const exchange of exchangeList) {\n        results[exchange] = {};\n        \n        for (const batch of batches) {\n            const batchPromises = batch.map(symbol => \n                this.fetchPriceWithValidation(symbol, exchange)\n                    .then(price => {\n                        if (price) results[exchange][symbol] = price;\n                    })\n                    .catch(error => {\n                        // Only log if it's not a \"symbol not found\" error\n                        if (!error.message.includes('Unknown asset') && \n                            !error.message.includes('Invalid symbol') &&\n                            !error.message.includes('No data received')) {\n                            console.error(`Price fetch failed for ${symbol} on ${exchange}:`, error.message);\n                        }\n                        results[exchange][symbol] = { error: 'Not available', timestamp: Date.now() };\n                    })\n            );\n            \n            await Promise.allSettled(batchPromises);\n        }\n    }\n    \n    return results;\n}\n\n    async fetchPriceWithValidation(symbol, exchange) {\n    // Check blacklist first\n    if (this.symbolBlacklist && this.symbolBlacklist.has(symbol)) {\n        return null;\n    }\n    \n    // Check if valid for Binance\n    if (exchange === 'binance' && this.validBinanceSymbols && !this.validBinanceSymbols.has(symbol)) {\n        return null;\n    }\n      \n      // Check if this symbol exists on this exchange\n    const symbolFormat = this.getSymbolFormat(symbol, exchange);\n    if (!symbolFormat) return null;\n    \n    const cacheKey = `${exchange}_${symbol}_price`;\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < 5000) {\n        return cached.data;\n    }\n    \n    try {\n        const priceData = await this.fetchRealTimePrice(symbol, exchange);\n        \n        this.cache.set(cacheKey, {\n            data: priceData,\n            timestamp: Date.now()\n        });\n        \n        return priceData;\n    } catch (error) {\n        // Don't throw for expected errors\n        if (error.message.includes('Unknown asset') || \n            error.message.includes('Invalid symbol')) {\n            return null;\n        }\n        throw error;\n    }\n    }\n\n    getSymbolFormat(symbol, exchange) {\n    const knownFormats = {\n        binance: {\n            'BTC': 'BTCUSDT', 'ETH': 'ETHUSDT', 'SOL': 'SOLUSDT',\n            'ADA': 'ADAUSDT', 'DOT': 'DOTUSDT', 'LINK': 'LINKUSDT',\n            'AVAX': 'AVAXUSDT', 'MATIC': 'MATICUSDT', 'UNI': 'UNIUSDT'\n        },\n        kraken: {\n            'BTC': 'XXBTZUSD', 'ETH': 'XETHZUSD', 'SOL': 'SOLUSD',\n            'ADA': 'ADAUSD', 'DOT': 'DOTUSD', 'LINK': 'LINKUSD',\n            'AVAX': 'AVAXUSD', 'MATIC': 'MATICUSD', 'UNI': 'UNIUSD'\n        },\n        kucoin: {\n            'BTC': 'BTC-USDT', 'ETH': 'ETH-USDT', 'SOL': 'SOL-USDT',\n            'ADA': 'ADA-USDT', 'DOT': 'DOT-USDT', 'LINK': 'LINK-USDT',\n            'AVAX': 'AVAX-USDT', 'MATIC': 'MATIC-USDT', 'UNI': 'UNI-USDT'\n        }\n    };\n    \n    // Return known format or generate default\n    if (knownFormats[exchange] && knownFormats[exchange][symbol]) {\n        return knownFormats[exchange][symbol];\n    }\n    \n    // Generate default format\n    switch(exchange) {\n        case 'binance': return `${symbol}USDT`;\n        case 'kraken': return `${symbol}USD`;\n        case 'kucoin': return `${symbol}-USDT`;\n        default: return null;\n    }\n    }\n\n\n    async fetchRealTimePrice(symbol, exchange) {\n        const cacheKey = `${exchange}_${symbol}_price`;\n        const cached = this.cache.get(cacheKey);\n        \n        if (cached && Date.now() - cached.timestamp < 5000) { // 5 second cache for prices\n            return cached.data;\n        }\n        \n        let priceData;\n        \n        try {\n            switch (exchange) {\n                case 'binance':\n                    priceData = await this.fetchBinancePrice(symbol);\n                    break;\n                case 'kraken':\n                    priceData = await this.fetchKrakenPrice(symbol);\n                    break;\n                case 'kucoin':\n                    priceData = await this.fetchKucoinPrice(symbol);\n                    break;\n                case 'coingecko':\n                    priceData = await this.fetchCoinGeckoPrice(symbol);\n                    break;\n                default:\n                    throw new Error(`Unsupported exchange: ${exchange}`);\n            }\n            \n            this.cache.set(cacheKey, {\n                data: priceData,\n                timestamp: Date.now()\n            });\n            \n            return priceData;\n            \n        } catch (error) {\n            throw error; // Don't use fallback with mock data\n        }\n    }\n\n    async fetchBinancePrice(symbol) {\n        await this.respectRateLimit('binance');\n        \n        const pair = `${symbol}USDT`;\n        const response = await fetch(\n            `${this.exchangeConfigs.binance.baseUrl}/api/v3/ticker/24hr?symbol=${pair}`,\n            {\n                timeout: 10000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`Binance price fetch failed for ${symbol}: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        return {\n            exchange: 'binance',\n            symbol: symbol,\n            price: parseFloat(data.lastPrice),\n            change24h: parseFloat(data.priceChangePercent),\n            volume24h: parseFloat(data.volume),\n            high24h: parseFloat(data.highPrice),\n            low24h: parseFloat(data.lowPrice),\n            bid: parseFloat(data.bidPrice),\n            ask: parseFloat(data.askPrice),\n            timestamp: Date.now(),\n            source: 'binance_api'\n        };\n    }\n\n    async fetchKrakenPrice(symbol) {\n        await this.respectRateLimit('kraken');\n        \n        const pairMappings = {\n            'BTC': 'XXBTZUSD',\n            'ETH': 'XETHZUSD',\n            'XBT': 'XXBTZUSD'\n        };\n        \n        const pair = pairMappings[symbol] || `${symbol}USD`;\n        const response = await fetch(\n            `${this.exchangeConfigs.kraken.baseUrl}/0/public/Ticker?pair=${pair}`,\n            {\n                timeout: 10000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`Kraken price fetch failed for ${symbol}: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error && data.error.length > 0) {\n            throw new Error(`Kraken errors: ${data.error.join(', ')}`);\n        }\n        \n        const ticker = Object.values(data.result)[0];\n        if (!ticker) {\n            throw new Error(`No ticker data for ${symbol} on Kraken`);\n        }\n        \n        const currentPrice = parseFloat(ticker.c[0]);\n        const openPrice = parseFloat(ticker.o);\n        \n        return {\n            exchange: 'kraken',\n            symbol: symbol,\n            price: currentPrice,\n            change24h: openPrice > 0 ? ((currentPrice - openPrice) / openPrice) * 100 : 0,\n            volume24h: parseFloat(ticker.v[1]),\n            high24h: parseFloat(ticker.h[1]),\n            low24h: parseFloat(ticker.l[1]),\n            bid: parseFloat(ticker.b[0]),\n            ask: parseFloat(ticker.a[0]),\n            timestamp: Date.now(),\n            source: 'kraken_api'\n        };\n    }\n\n    async fetchKucoinPrice(symbol) {\n        await this.respectRateLimit('kucoin');\n        \n        const pair = `${symbol}-USDT`;\n        const response = await fetch(\n            `${this.exchangeConfigs.kucoin.baseUrl}/api/v1/market/stats?symbol=${pair}`,\n            {\n                timeout: 10000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`KuCoin price fetch failed for ${symbol}: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.code !== '200000') {\n            throw new Error(`KuCoin API error: ${data.msg}`);\n        }\n        \n        return {\n            exchange: 'kucoin',\n            symbol: symbol,\n            price: parseFloat(data.data.last),\n            change24h: parseFloat(data.data.changeRate) * 100,\n            volume24h: parseFloat(data.data.vol),\n            high24h: parseFloat(data.data.high),\n            low24h: parseFloat(data.data.low),\n            bid: parseFloat(data.data.buy),\n            ask: parseFloat(data.data.sell),\n            timestamp: Date.now(),\n            source: 'kucoin_api'\n        };\n    }\n\n    async fetchCoinGeckoPrice(symbol) {\n        // Dynamic fetching of coin IDs from CoinGecko\n        const coinListResponse = await fetch('https://api.coingecko.com/api/v3/coins/list');\n        if (!coinListResponse.ok) {\n            throw new Error(`CoinGecko list fetch failed: ${coinListResponse.status}`);\n        }\n        \n        const coinList = await coinListResponse.json();\n        const symbolLower = symbol.toLowerCase();\n        const coin = coinList.find(c => c.symbol === symbolLower);\n        \n        if (!coin) {\n            throw new Error(`CoinGecko mapping not found for ${symbol}`);\n        }\n        \n        const response = await fetch(\n            `${this.exchangeConfigs.coingecko.baseUrl}/simple/price?ids=${coin.id}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`,\n            {\n                timeout: 10000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`CoinGecko API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        const coinData = data[coin.id];\n        \n        if (!coinData) {\n            throw new Error(`No CoinGecko data for ${symbol}`);\n        }\n        \n        const price = coinData.usd;\n        const change24h = coinData.usd_24h_change || 0;\n        \n        return {\n            exchange: 'coingecko',\n            symbol: symbol,\n            price: price,\n            change24h: change24h,\n            volume24h: coinData.usd_24h_vol || 0,\n            high24h: price * (1 + Math.abs(change24h) / 200), // Estimate based on change\n            low24h: price * (1 - Math.abs(change24h) / 200), // Estimate based on change\n            bid: price * 0.999,\n            ask: price * 1.001,\n            timestamp: Date.now(),\n            source: 'coingecko_api'\n        };\n    }\n\n    // Continue with remaining methods...\n// ===== PART 2: TECHNICAL ANALYSIS & HISTORICAL DATA =====\n    \n    // COMPLETE TECHNICAL ANALYSIS - REAL DATA ONLY\n    async performTechnicalAnalysis(symbols, timeframe, exchanges) {\n        console.log(`📈 Performing technical analysis for ${symbols.length} symbols...`);\n        \n        const results = {};\n        const symbolList = Array.isArray(symbols) ? symbols : symbols.split(',').map(s => s.trim().toUpperCase());\n        const exchangeList = Array.isArray(exchanges) ? exchanges : [exchanges];\n        \n        for (const symbol of symbolList) {\n            try {\n                // Get historical data for technical indicators\n                const historicalData = await this.getHistoricalData(symbol, timeframe, exchangeList[0]);\n                const currentPrice = await this.fetchRealTimePrice(symbol, exchangeList[0]);\n                \n                if (historicalData && currentPrice) {\n                    const technicalIndicators = this.calculateTechnicalIndicators(historicalData, currentPrice);\n                    \n                    results[symbol] = {\n                        current_price: currentPrice.price,\n                        timeframe: timeframe,\n                        exchange: exchangeList[0],\n                        indicators: technicalIndicators,\n                        signals: this.generateTechnicalSignals(technicalIndicators),\n                        analysis_time: new Date().toISOString()\n                    };\n                }\n            } catch (error) {\n                console.error(`Technical analysis failed for ${symbol}:`, error.message);\n                results[symbol] = {\n                    error: error.message,\n                    analysis_time: new Date().toISOString()\n                };\n            }\n        }\n        \n        return results;\n    }\n\n    async getHistoricalData(symbol, timeframe, exchange) {\n        const cacheKey = `${exchange}_${symbol}_${timeframe}_historical`;\n        const cached = this.cache.get(cacheKey);\n        \n        if (cached && Date.now() - cached.timestamp < 300000) { // 5 minute cache\n            return cached.data;\n        }\n        \n        let historicalData;\n        \n        try {\n            switch (exchange) {\n                case 'binance':\n                    historicalData = await this.fetchBinanceHistorical(symbol, timeframe);\n                    break;\n                case 'kraken':\n                    historicalData = await this.fetchKrakenHistorical(symbol, timeframe);\n                    break;\n                case 'kucoin':\n                    historicalData = await this.fetchKucoinHistorical(symbol, timeframe);\n                    break;\n                default:\n                    throw new Error(`Historical data not supported for ${exchange}`);\n            }\n            \n            this.cache.set(cacheKey, {\n                data: historicalData,\n                timestamp: Date.now()\n            });\n            \n            return historicalData;\n            \n        } catch (error) {\n            console.error(`Failed to get historical data for ${symbol}:`, error.message);\n            throw error;\n        }\n    }\n\n    async fetchBinanceHistorical(symbol, timeframe) {\n        await this.respectRateLimit('binance');\n        \n        const interval = this.mapTimeframeToInterval(timeframe, 'binance');\n        const pair = `${symbol}USDT`;\n        \n        const response = await fetch(\n            `${this.exchangeConfigs.binance.baseUrl}/api/v3/klines?symbol=${pair}&interval=${interval}&limit=100`,\n            {\n                timeout: 15000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`Binance historical data failed: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        return data.map(candle => ({\n            timestamp: candle[0],\n            open: parseFloat(candle[1]),\n            high: parseFloat(candle[2]),\n            low: parseFloat(candle[3]),\n            close: parseFloat(candle[4]),\n            volume: parseFloat(candle[5])\n        }));\n    }\n\n    async fetchKrakenHistorical(symbol, timeframe) {\n        await this.respectRateLimit('kraken');\n        \n        const interval = this.mapTimeframeToInterval(timeframe, 'kraken');\n        const pairMappings = {\n            'BTC': 'XXBTZUSD',\n            'ETH': 'XETHZUSD',\n            'XBT': 'XXBTZUSD'\n        };\n        \n        const pair = pairMappings[symbol] || `${symbol}USD`;\n        \n        const response = await fetch(\n            `${this.exchangeConfigs.kraken.baseUrl}/0/public/OHLC?pair=${pair}&interval=${interval}`,\n            {\n                timeout: 15000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`Kraken historical data failed: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error && data.error.length > 0) {\n            throw new Error(`Kraken errors: ${data.error.join(', ')}`);\n        }\n        \n        const ohlcData = Object.values(data.result)[0];\n        if (!ohlcData) {\n            throw new Error('No OHLC data from Kraken');\n        }\n        \n        return ohlcData.map(candle => ({\n            timestamp: candle[0] * 1000,\n            open: parseFloat(candle[1]),\n            high: parseFloat(candle[2]),\n            low: parseFloat(candle[3]),\n            close: parseFloat(candle[4]),\n            volume: parseFloat(candle[6])\n        }));\n    }\n\n    async fetchKucoinHistorical(symbol, timeframe) {\n        await this.respectRateLimit('kucoin');\n        \n        const type = this.mapTimeframeToInterval(timeframe, 'kucoin');\n        const pair = `${symbol}-USDT`;\n        const endAt = Math.floor(Date.now() / 1000);\n        const startAt = endAt - (100 * this.getSecondsForTimeframe(timeframe));\n        \n        const response = await fetch(\n            `${this.exchangeConfigs.kucoin.baseUrl}/api/v1/market/candles?type=${type}&symbol=${pair}&startAt=${startAt}&endAt=${endAt}`,\n            {\n                timeout: 15000,\n                headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n            }\n        );\n        \n        if (!response.ok) {\n            throw new Error(`KuCoin historical data failed: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.code !== '200000') {\n            throw new Error(`KuCoin API error: ${data.msg}`);\n        }\n        \n        return data.data.map(candle => ({\n            timestamp: parseInt(candle[0]) * 1000,\n            open: parseFloat(candle[1]),\n            close: parseFloat(candle[2]),\n            high: parseFloat(candle[3]),\n            low: parseFloat(candle[4]),\n            volume: parseFloat(candle[5])\n        })).reverse(); // KuCoin returns newest first\n    }\n\n    getSecondsForTimeframe(timeframe) {\n        const seconds = {\n            '1m': 60, '5m': 300, '15m': 900, '30m': 1800,\n            '1h': 3600, '4h': 14400, '1d': 86400, '1w': 604800\n        };\n        return seconds[timeframe] || 3600;\n    }\n\n    calculateTechnicalIndicators(historicalData, currentPrice) {\n        if (!historicalData || historicalData.length < 20) {\n            return null;\n        }\n        \n        const prices = historicalData.map(d => d.close);\n        const volumes = historicalData.map(d => d.volume);\n        const highs = historicalData.map(d => d.high);\n        const lows = historicalData.map(d => d.low);\n        \n        return {\n            sma_20: this.calculateSMA(prices, 20),\n            ema_12: this.calculateEMA(prices, 12),\n            ema_26: this.calculateEMA(prices, 26),\n            rsi: this.calculateRSI(prices, 14),\n            macd: this.calculateMACD(prices),\n            bollinger_bands: this.calculateBollingerBands(prices, 20, 2),\n            volume_sma: this.calculateSMA(volumes, 20),\n            atr: this.calculateATR(highs, lows, prices, 14),\n            stochastic: this.calculateStochastic(highs, lows, prices, 14),\n            williams_r: this.calculateWilliamsR(highs, lows, prices, 14),\n            obv: this.calculateOBV(prices, volumes),\n            vwap: this.calculateVWAP(prices, volumes)\n        };\n    }\n\n    calculateSMA(prices, period) {\n        if (prices.length < period) return null;\n        \n        const recentPrices = prices.slice(-period);\n        const sum = recentPrices.reduce((acc, price) => acc + price, 0);\n        return sum / period;\n    }\n\n    calculateEMA(prices, period) {\n        if (prices.length < period) return null;\n        \n        const multiplier = 2 / (period + 1);\n        let ema = prices[0];\n        \n        for (let i = 1; i < prices.length; i++) {\n            ema = (prices[i] * multiplier) + (ema * (1 - multiplier));\n        }\n        \n        return ema;\n    }\n\n    calculateRSI(prices, period) {\n        if (prices.length < period + 1) return null;\n        \n        let gains = 0;\n        let losses = 0;\n        \n        for (let i = 1; i <= period; i++) {\n            const change = prices[prices.length - i] - prices[prices.length - i - 1];\n            if (change > 0) {\n                gains += change;\n            } else {\n                losses -= change;\n            }\n        }\n        \n        const avgGain = gains / period;\n        const avgLoss = losses / period;\n        \n        if (avgLoss === 0) return 100;\n        \n        const rs = avgGain / avgLoss;\n        return 100 - (100 / (1 + rs));\n    }\n\n    calculateMACD(prices) {\n        const ema12 = this.calculateEMA(prices, 12);\n        const ema26 = this.calculateEMA(prices, 26);\n        \n        if (!ema12 || !ema26) return null;\n        \n        const macdLine = ema12 - ema26;\n        \n        // Calculate signal line using 9-period EMA of MACD\n        const macdValues = [];\n        for (let i = 26; i < prices.length; i++) {\n            const ema12Temp = this.calculateEMA(prices.slice(0, i + 1), 12);\n            const ema26Temp = this.calculateEMA(prices.slice(0, i + 1), 26);\n            if (ema12Temp && ema26Temp) {\n                macdValues.push(ema12Temp - ema26Temp);\n            }\n        }\n        \n        const signalLine = this.calculateEMA(macdValues, 9) || macdLine * 0.9;\n        \n        return {\n            macd: macdLine,\n            signal: signalLine,\n            histogram: macdLine - signalLine\n        };\n    }\n\n    calculateBollingerBands(prices, period, multiplier) {\n        const sma = this.calculateSMA(prices, period);\n        if (!sma) return null;\n        \n        const recentPrices = prices.slice(-period);\n        const variance = recentPrices.reduce((acc, price) => acc + Math.pow(price - sma, 2), 0) / period;\n        const stdDev = Math.sqrt(variance);\n        \n        return {\n            upper: sma + (stdDev * multiplier),\n            middle: sma,\n            lower: sma - (stdDev * multiplier),\n            std_dev: stdDev\n        };\n    }\n\n    calculateATR(highs, lows, closes, period) {\n        if (highs.length < period + 1) return null;\n        \n        const trueRanges = [];\n        \n        for (let i = 1; i < highs.length; i++) {\n            const tr1 = highs[i] - lows[i];\n            const tr2 = Math.abs(highs[i] - closes[i - 1]);\n            const tr3 = Math.abs(lows[i] - closes[i - 1]);\n            \n            trueRanges.push(Math.max(tr1, tr2, tr3));\n        }\n        \n        return this.calculateSMA(trueRanges, period);\n    }\n\n    calculateStochastic(highs, lows, closes, period) {\n        if (highs.length < period) return null;\n        \n        const recentHighs = highs.slice(-period);\n        const recentLows = lows.slice(-period);\n        const currentClose = closes[closes.length - 1];\n        \n        const highestHigh = Math.max(...recentHighs);\n        const lowestLow = Math.min(...recentLows);\n        \n        if (highestHigh === lowestLow) return { k: 50, d: 50 };\n        \n        const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;\n        \n        // Calculate D as 3-period SMA of K values\n        const kValues = [];\n        for (let i = period; i <= closes.length && kValues.length < 3; i++) {\n            const tempHighs = highs.slice(i - period, i);\n            const tempLows = lows.slice(i - period, i);\n            const tempClose = closes[i - 1];\n            \n            const tempHighest = Math.max(...tempHighs);\n            const tempLowest = Math.min(...tempLows);\n            \n            if (tempHighest !== tempLowest) {\n                kValues.push(((tempClose - tempLowest) / (tempHighest - tempLowest)) * 100);\n            }\n        }\n        \n        const d = kValues.length > 0 ? kValues.reduce((a, b) => a + b, 0) / kValues.length : k;\n        \n        return { k, d };\n    }\n\n    calculateWilliamsR(highs, lows, closes, period) {\n        if (highs.length < period) return null;\n        \n        const recentHighs = highs.slice(-period);\n        const recentLows = lows.slice(-period);\n        const currentClose = closes[closes.length - 1];\n        \n        const highestHigh = Math.max(...recentHighs);\n        const lowestLow = Math.min(...recentLows);\n        \n        if (highestHigh === lowestLow) return -50;\n        \n        return ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;\n    }\n\n    calculateOBV(prices, volumes) {\n        if (prices.length !== volumes.length || prices.length < 2) return null;\n        \n        let obv = 0;\n        for (let i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                obv += volumes[i];\n            } else if (prices[i] < prices[i - 1]) {\n                obv -= volumes[i];\n            }\n        }\n        \n        return obv;\n    }\n\n    calculateVWAP(prices, volumes) {\n        if (prices.length !== volumes.length || prices.length === 0) return null;\n        \n        let cumVolume = 0;\n        let cumPriceVolume = 0;\n        \n        for (let i = 0; i < prices.length; i++) {\n            cumVolume += volumes[i];\n            cumPriceVolume += prices[i] * volumes[i];\n        }\n        \n        return cumVolume > 0 ? cumPriceVolume / cumVolume : null;\n    }\n\n    generateTechnicalSignals(indicators) {\n        if (!indicators) return null;\n        \n        const signals = [];\n        let overallSignal = 'HOLD';\n        let bullishCount = 0;\n        let bearishCount = 0;\n        \n        // RSI Signal\n        if (indicators.rsi) {\n            if (indicators.rsi > 70) {\n                signals.push({ indicator: 'RSI', signal: 'SELL', strength: 'STRONG', value: indicators.rsi });\n                bearishCount += 2;\n            } else if (indicators.rsi < 30) {\n                signals.push({ indicator: 'RSI', signal: 'BUY', strength: 'STRONG', value: indicators.rsi });\n                bullishCount += 2;\n            } else if (indicators.rsi > 60) {\n                signals.push({ indicator: 'RSI', signal: 'SELL', strength: 'WEAK', value: indicators.rsi });\n                bearishCount += 1;\n            } else if (indicators.rsi < 40) {\n                signals.push({ indicator: 'RSI', signal: 'BUY', strength: 'WEAK', value: indicators.rsi });\n                bullishCount += 1;\n            }\n        }\n        \n        // MACD Signal\n        if (indicators.macd && indicators.macd.histogram) {\n            if (indicators.macd.histogram > 0) {\n                signals.push({ indicator: 'MACD', signal: 'BUY', strength: 'MEDIUM', value: indicators.macd.histogram });\n                bullishCount += 1;\n            } else {\n                signals.push({ indicator: 'MACD', signal: 'SELL', strength: 'MEDIUM', value: indicators.macd.histogram });\n                bearishCount += 1;\n            }\n        }\n        \n        // Bollinger Bands Signal\n        if (indicators.bollinger_bands) {\n            signals.push({ \n                indicator: 'BOLLINGER', \n                signal: 'HOLD', \n                strength: 'NEUTRAL',\n                upper: indicators.bollinger_bands.upper,\n                lower: indicators.bollinger_bands.lower\n            });\n        }\n        \n        // Stochastic Signal\n        if (indicators.stochastic) {\n            if (indicators.stochastic.k > 80) {\n                signals.push({ indicator: 'STOCHASTIC', signal: 'SELL', strength: 'MEDIUM', value: indicators.stochastic.k });\n                bearishCount += 1;\n            } else if (indicators.stochastic.k < 20) {\n                signals.push({ indicator: 'STOCHASTIC', signal: 'BUY', strength: 'MEDIUM', value: indicators.stochastic.k });\n                bullishCount += 1;\n            }\n        }\n        \n        // Overall Signal\n        if (bullishCount > bearishCount + 1) {\n            overallSignal = 'BUY';\n        } else if (bearishCount > bullishCount + 1) {\n            overallSignal = 'SELL';\n        }\n        \n        return {\n            overall_signal: overallSignal,\n            signal_strength: Math.abs(bullishCount - bearishCount),\n            bullish_indicators: bullishCount,\n            bearish_indicators: bearishCount,\n            individual_signals: signals\n        };\n    }\n\n    mapTimeframeToInterval(timeframe, exchange) {\n        const mappings = {\n            binance: {\n                '1m': '1m', '5m': '5m', '15m': '15m', '30m': '30m',\n                '1h': '1h', '4h': '4h', '1d': '1d', '1w': '1w'\n            },\n            kraken: {\n                '1m': '1', '5m': '5', '15m': '15', '30m': '30',\n                '1h': '60', '4h': '240', '1d': '1440', '1w': '10080'\n            },\n            kucoin: {\n                '1m': '1min', '5m': '5min', '15m': '15min', '30m': '30min',\n                '1h': '1hour', '4h': '4hour', '1d': '1day', '1w': '1week'\n            }\n        };\n        \n        return mappings[exchange]?.[timeframe] || mappings[exchange]?.['1h'] || '1h';\n    }\n\n    async respectRateLimit(exchange) {\n        const now = Date.now();\n        const lastRequest = this.lastRequestTimes.get(exchange) || 0;\n        const minInterval = 100; // 100ms minimum between requests\n        \n        const timeSinceLastRequest = now - lastRequest;\n        if (timeSinceLastRequest < minInterval) {\n            await new Promise(resolve => setTimeout(resolve, minInterval - timeSinceLastRequest));\n        }\n        \n        this.lastRequestTimes.set(exchange, Date.now());\n    }\n}\n// ===== PART 3: ENHANCED ALPHA GENERATOR WITH REAL DATA =====\n\n// ===== HELPER FUNCTIONS MOVED OUTSIDE CLASS =====\n\nasync function fetchBinanceFundingRate(symbol) {\n    try {\n        const response = await fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${symbol}USDT&limit=1`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return data[0] ? parseFloat(data[0].fundingRate) : null;\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchBybitFundingRate(symbol) {\n    try {\n        const response = await fetch(`https://api.bybit.com/v5/market/funding/history?category=linear&symbol=${symbol}USDT&limit=1`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return data.result?.list?.[0] ? parseFloat(data.result.list[0].fundingRate) : null;\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchDeribitFundingRate(symbol) {\n    try {\n        const instrument = symbol === 'BTC' ? 'BTC-PERPETUAL' : `${symbol}-PERPETUAL`;\n        const response = await fetch(`https://www.deribit.com/api/v2/public/get_funding_rate_value?instrument_name=${instrument}`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return data.result ? parseFloat(data.result) : null;\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchWhaleAlertData(symbol) {\n    try {\n        // This would require an API key - returning structure for integration\n        // Real implementation would use: https://api.whale-alert.io/v1/transactions\n        const response = await fetch(`https://api.blockchain.info/stats`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return {\n            transfers: Math.floor(data.n_tx / 10000) || 0,\n            totalValue: data.total_btc_sent || 0\n        };\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchExchangeFlowData(symbol) {\n    try {\n        // Real on-chain data would require API keys\n        // Using blockchain.info as fallback for structure\n        const response = await fetch(`https://api.blockchain.info/stats`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return {\n            netFlow: (data.totalbc - data.total_btc_sent) || 0,\n            inflow: data.totalbc || 0,\n            outflow: data.total_btc_sent || 0\n        };\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchSpotPrice(symbol) {\n    try {\n        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}USDT`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return parseFloat(data.price);\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchFuturesPrice(symbol) {\n    try {\n        const response = await fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${symbol}USDT`);\n        if (!response.ok) return null;\n        const data = await response.json();\n        return parseFloat(data.price);\n    } catch {\n        return null;\n    }\n}\n\nasync function fetchOptionsData(symbol) {\n    try {\n        const response = await fetch(`https://www.deribit.com/api/v2/public/get_book_summary_by_currency?currency=${symbol}&kind=option`);\n        if (!response.ok) return null;\n        \n        const data = await response.json();\n        \n        const putVolume = data.result?.filter(o => o.instrument_name.includes('-P-')).reduce((sum, o) => sum + o.volume, 0) || 0;\n        const callVolume = data.result?.filter(o => o.instrument_name.includes('-C-')).reduce((sum, o) => sum + o.volume, 0) || 0;\n        \n        return {\n            putCallRatio: callVolume > 0 ? putVolume / callVolume : 1.0,\n            unusualActivity: detectUnusualOptionsActivity(data.result),\n            ivSkew: calculateIVSkew(data.result),\n            gammaExposure: calculateGammaExposure(data.result),\n            largestTrades: extractLargestTrades(data.result),\n            netDelta: calculateNetDelta(data.result)\n        };\n    } catch {\n        return null;\n    }\n}\n\nfunction detectUnusualOptionsActivity(optionsData) {\n    if (!optionsData || optionsData.length === 0) return false;\n    \n    const totalVolume = optionsData.reduce((sum, o) => sum + (o.volume || 0), 0);\n    const avgVolume = totalVolume / optionsData.length;\n    \n    return optionsData.some(o => o.volume > avgVolume * 3);\n}\n\nfunction calculateIVSkew(optionsData) {\n    if (!optionsData || optionsData.length === 0) return 0;\n    // Real IV calculation would be more complex\n    return 0;\n}\n\nfunction calculateGammaExposure(optionsData) {\n    if (!optionsData || optionsData.length === 0) return 0;\n    return optionsData.reduce((sum, o) => sum + (o.open_interest || 0) * (o.underlying_price || 0) * 100, 0);\n}\n\nfunction extractLargestTrades(optionsData) {\n    if (!optionsData) return [];\n    \n    return optionsData\n        .sort((a, b) => (b.volume || 0) - (a.volume || 0))\n        .slice(0, 5)\n        .map(o => ({\n            instrument: o.instrument_name,\n            volume: o.volume,\n            openInterest: o.open_interest\n        }));\n}\n\nfunction calculateNetDelta(optionsData) {\n    // Simplified net delta calculation\n    return 0;\n}\n\nfunction calculateAccumulationScore(whaleData, exchangeFlows, totalVolume) {\n    let score = 0;\n    \n    if (whaleData && whaleData.transfers > 0) {\n        score += Math.min(whaleData.transfers * 10, 30);\n    }\n    \n    if (exchangeFlows && exchangeFlows.netFlow < 0) {\n        score += Math.min(Math.abs(exchangeFlows.netFlow) / 100000, 40);\n    }\n    \n    score += Math.min(totalVolume / 5000000 * 30, 30);\n    \n    return Math.min(score, 100);\n}\n\nfunction determineWhaleActivityLevel(whaleData, totalVolume) {\n    if (!whaleData) {\n        return totalVolume > 10000000 ? 'HIGH' : totalVolume > 1000000 ? 'MEDIUM' : 'LOW';\n    }\n    \n    const transfers = whaleData.transfers || 0;\n    const value = whaleData.totalValue || 0;\n    \n    if (transfers > 10 || value > 50000000) return 'HIGH';\n    if (transfers > 5 || value > 10000000) return 'MEDIUM';\n    return 'LOW';\n}\n\nfunction determineBasisTrend(currentBasis, historicalBasis) {\n    if (!historicalBasis || historicalBasis.length === 0) {\n        return 'UNKNOWN';\n    }\n    \n    const avgHistorical = historicalBasis.reduce((sum, b) => sum + b, 0) / historicalBasis.length;\n    \n    if (currentBasis > avgHistorical * 1.1) return 'WIDENING';\n    if (currentBasis < avgHistorical * 0.9) return 'NARROWING';\n    return 'STABLE';\n}\n\n// ===== ENHANCED ALPHA GENERATOR CLASS =====\nclass EnhancedAlphaGenerator {\n    constructor(exchangeManager) {\n        this.exchangeManager = exchangeManager;\n        this.confidenceThresholds = {\n            high: 85,\n            medium: 70,\n            low: 55\n        };\n        this.cache = new Map();\n        this.cacheTTL = 60000; // 1 minute cache for opportunities\n    }\n\n    // CROSS-EXCHANGE ARBITRAGE SCANNER WITH REAL DATA\n    async crossExchangeArbitrageScanner(symbols, exchanges, minProfitBps) {\n        console.log('🔍 Scanning cross-exchange arbitrage opportunities WITH REAL DATA...');\n        \n        const arbitrageOpportunities = [];\n        const symbolList = Array.isArray(symbols) ? symbols : symbols.split(',').map(s => s.trim().toUpperCase());\n        const exchangeList = Array.isArray(exchanges) ? exchanges : \n                            exchanges === 'major' ? ['binance', 'kraken', 'kucoin'] : \n                            exchanges === 'all' ? ['binance', 'kraken', 'kucoin'] :\n                            exchanges.split(',').map(e => e.trim().toLowerCase());\n        \n        for (const symbol of symbolList) {\n            try {\n                // GET REAL PRICES\n                const realPrices = await this.exchangeManager.getRealTimePrices([symbol], exchangeList);\n                const exchangePrices = [];\n                \n                for (const exchange of exchangeList) {\n                    const priceData = realPrices[exchange]?.[symbol];\n                    if (priceData && !priceData.error) {\n                        exchangePrices.push({\n                            exchange,\n                            bid: priceData.bid || priceData.price * 0.9995,\n                            ask: priceData.ask || priceData.price * 1.0005,\n                            bidVolume: priceData.volume24h * 0.001 || 100, // Real volume estimate\n                            askVolume: priceData.volume24h * 0.001 || 100,\n                            spread: (priceData.ask - priceData.bid) || priceData.price * 0.001,\n                            timestamp: priceData.timestamp,\n                            price: priceData.price,\n                            volume24h: priceData.volume24h || 0\n                        });\n                    }\n                }\n                \n                // Find arbitrage opportunities using REAL data\n                for (let i = 0; i < exchangePrices.length; i++) {\n                    for (let j = i + 1; j < exchangePrices.length; j++) {\n                        const buyExchange = exchangePrices[i];\n                        const sellExchange = exchangePrices[j];\n                        \n                        const opportunities = [\n                            { buy: buyExchange, sell: sellExchange },\n                            { buy: sellExchange, sell: buyExchange }\n                        ];\n                        \n                        for (const opp of opportunities) {\n                            if (opp.buy.ask < opp.sell.bid) {\n                                const priceDiff = opp.sell.bid - opp.buy.ask;\n                                const profitBps = (priceDiff / opp.buy.ask) * 10000;\n                                \n                                if (profitBps >= minProfitBps) {\n                                    const maxVolume = Math.min(opp.buy.askVolume, opp.sell.bidVolume);\n                                    const estimatedProfit = priceDiff * maxVolume * 0.8; // 80% execution efficiency\n                                    const totalFees = (opp.buy.ask + opp.sell.bid) * maxVolume * 0.002; // 0.2% total fees\n                                    const netProfit = estimatedProfit - totalFees;\n                                    \n                                    if (netProfit > 10) { // Minimum $10 profit\n                                        arbitrageOpportunities.push({\n                                            symbol,\n                                            buy_exchange: opp.buy.exchange,\n                                            sell_exchange: opp.sell.exchange,\n                                            buy_price: opp.buy.ask,\n                                            sell_price: opp.sell.bid,\n                                            profit_bps: Math.round(profitBps),\n                                            profit_percentage: profitBps / 100,\n                                            max_volume: maxVolume,\n                                            estimated_profit_usd: Math.round(netProfit * 100) / 100,\n                                            execution_complexity: 'MEDIUM',\n                                            time_sensitivity: profitBps > 50 ? 'HIGH' : 'MEDIUM',\n                                            risk_score: this.calculateArbitrageRisk(opp.buy, opp.sell),\n                                            confidence: this.calculateRealDataConfidence(exchangePrices.length, opp.buy.volume24h, opp.sell.volume24h),\n                                            market_data_quality: this.assessMarketDataQuality(opp.buy, opp.sell),\n                                            execution_window_seconds: this.estimateExecutionWindow(profitBps),\n                                            timestamp: new Date().toISOString()\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(`Error scanning ${symbol}:`, error.message);\n            }\n        }\n        \n        arbitrageOpportunities.sort((a, b) => b.estimated_profit_usd - a.estimated_profit_usd);\n        \n        const highConfidenceOpportunities = arbitrageOpportunities.filter(opp => \n            opp.profit_bps > 30 && opp.risk_score < 30 && opp.confidence > 70\n        );\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            arbitrage_scan: {\n                symbols_scanned: symbolList,\n                exchanges_scanned: exchangeList,\n                min_profit_bps: minProfitBps,\n                opportunities_found: arbitrageOpportunities.length,\n                opportunities: arbitrageOpportunities,\n                high_confidence_opportunities: highConfidenceOpportunities,\n                total_potential_profit: arbitrageOpportunities.reduce((sum, opp) => sum + opp.estimated_profit_usd, 0),\n                execution_recommendation: highConfidenceOpportunities.length > 0 ? 'EXECUTE_TOP_3' : 'CONTINUE_MONITORING',\n                data_source: 'REAL_TIME_APIS',\n                data_quality_score: this.calculateOverallDataQuality(arbitrageOpportunities),\n                market_conditions: await this.assessMarketConditions(symbolList, exchangeList)\n            }\n        };\n    }\n\n    // MARKET INEFFICIENCY SCANNER WITH REAL DATA\n    async marketInefficiencyScanner(symbols, confidenceLevel) {\n        console.log('🔍 Scanning market inefficiencies WITH REAL DATA...');\n        \n        const inefficiencies = [];\n        const symbolList = Array.isArray(symbols) ? symbols : symbols.split(',').map(s => s.trim().toUpperCase());\n        \n        for (const symbol of symbolList) {\n            try {\n                // Get REAL market data\n                const realPrices = await this.exchangeManager.getRealTimePrices([symbol], ['binance', 'kraken', 'kucoin']);\n                const technicalData = await this.exchangeManager.performTechnicalAnalysis([symbol], '1h', ['binance']);\n                \n                const detections = [];\n                \n                // 1. VOLUME-PRICE DIVERGENCE\n                const volumeDivergence = await this.detectVolumePriceDivergence(symbol, realPrices, technicalData);\n                if (volumeDivergence) {\n                    detections.push(volumeDivergence);\n                }\n                \n                // 2. FUNDING RATE ARBITRAGE\n                const fundingArbitrage = await this.detectFundingRateArbitrage(symbol);\n                if (fundingArbitrage) {\n                    detections.push(fundingArbitrage);\n                }\n                \n                // 3. ORDER BOOK MANIPULATION\n                const orderBookManipulation = await this.detectOrderBookManipulation(symbol, realPrices);\n                if (orderBookManipulation) {\n                    detections.push(orderBookManipulation);\n                }\n                \n                // 4. SPREAD ANOMALIES\n                const spreadAnomalies = await this.detectSpreadAnomalies(symbol, realPrices);\n                if (spreadAnomalies) {\n                    detections.push(spreadAnomalies);\n                }\n                \n                // 5. MOMENTUM DIVERGENCE\n                const momentumDivergence = await this.detectMomentumDivergence(symbol, technicalData);\n                if (momentumDivergence) {\n                    detections.push(momentumDivergence);\n                }\n                \n                const significantInefficiencies = detections.filter(detection => {\n                    if (confidenceLevel === 'high' && detection.confidence !== 'HIGH') return false;\n                    if (detection.strength && detection.strength < 0.6 && confidenceLevel === 'high') return false;\n                    if (detection.profit_potential && detection.profit_potential < 0.1) return false;\n                    return true;\n                });\n                \n                significantInefficiencies.forEach(ineff => {\n                    inefficiencies.push({\n                        symbol,\n                        ...ineff,\n                        timestamp: new Date().toISOString(),\n                        data_source: 'REAL_MARKET_DATA'\n                    });\n                });\n                \n            } catch (error) {\n                console.log(`Error analyzing ${symbol}:`, error.message);\n            }\n        }\n        \n        inefficiencies.sort((a, b) => {\n            const scoreA = (a.profit_potential || a.strength || 0) * this.getConfidenceMultiplier(a.confidence);\n            const scoreB = (b.profit_potential || b.strength || 0) * this.getConfidenceMultiplier(b.confidence);\n            return scoreB - scoreA;\n        });\n        \n        const actionableOpportunities = inefficiencies.filter(ineff => \n            ineff.confidence === 'HIGH' && (ineff.profit_potential > 0.15 || ineff.strength > 0.7)\n        );\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            inefficiency_scan: {\n                symbols_analyzed: symbolList,\n                confidence_level: confidenceLevel,\n                total_inefficiencies: inefficiencies.length,\n                detected_inefficiencies: inefficiencies,\n                actionable_opportunities: actionableOpportunities,\n                market_efficiency_score: this.calculateMarketEfficiencyScore(inefficiencies),\n                data_quality: 'REAL_TIME_MARKET_DATA',\n                analysis_depth: 'COMPREHENSIVE'\n            }\n        };\n    }\n\n    // Continue with remaining methods...\n// ===== PART 4: INSTITUTIONAL FLOW & DETECTION METHODS =====\n    \n    // INSTITUTIONAL FLOW TRACKER WITH REAL DATA\n    async institutionalFlowTracker(symbols) {\n        console.log('🏛️ Tracking institutional flow patterns WITH REAL DATA...');\n        \n        const institutionalSignals = [];\n        const symbolList = Array.isArray(symbols) ? symbols : symbols.split(',').map(s => s.trim().toUpperCase());\n        \n        for (const symbol of symbolList) {\n            try {\n                // Get REAL institutional data\n                const realPrices = await this.exchangeManager.getRealTimePrices([symbol], ['binance', 'kraken', 'kucoin']);\n                const historicalData = await this.exchangeManager.getHistoricalData(symbol, '1h', 'binance');\n                \n                const analysis = {\n                    large_orders: await this.detectLargeOrders(symbol, realPrices, historicalData),\n                    whale_movements: await this.detectWhaleMovements(symbol, realPrices),\n                    futures_basis: await this.analyzeFuturesBasis(symbol),\n                    options_flow: await this.analyzeOptionsFlow(symbol),\n                    exchange_flows: await this.analyzeExchangeFlows(symbol, realPrices),\n                    funding_flows: await this.analyzeFundingFlows(symbol)\n                };\n                \n                const institutionalScore = this.calculateInstitutionalScore(analysis);\n                \n                if (institutionalScore.score > 65) {\n                    institutionalSignals.push({\n                        symbol,\n                        institutional_score: institutionalScore.score,\n                        primary_signal: institutionalScore.primary_signal,\n                        direction: institutionalScore.direction,\n                        confidence: institutionalScore.confidence,\n                        time_horizon: institutionalScore.time_horizon,\n                        supporting_evidence: institutionalScore.evidence,\n                        flow_strength: institutionalScore.flow_strength,\n                        market_impact_estimate: institutionalScore.market_impact,\n                        execution_urgency: institutionalScore.urgency,\n                        raw_analysis: analysis,\n                        data_quality: 'INSTITUTIONAL_GRADE',\n                        timestamp: new Date().toISOString()\n                    });\n                }\n                \n            } catch (error) {\n                console.log(`Error tracking ${symbol}:`, error.message);\n            }\n        }\n        \n        institutionalSignals.sort((a, b) => (b.institutional_score * b.confidence / 100) - (a.institutional_score * a.confidence / 100));\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            institutional_flow: {\n                symbols_tracked: symbolList,\n                signals_detected: institutionalSignals.length,\n                institutional_signals: institutionalSignals,\n                market_structure_health: this.assessMarketStructureHealth(institutionalSignals),\n                flow_intensity: this.calculateFlowIntensity(institutionalSignals),\n                sector_rotation_signals: this.detectSectorRotation(institutionalSignals),\n                trading_recommendations: institutionalSignals.map(signal => ({\n                    symbol: signal.symbol,\n                    action: signal.direction,\n                    reasoning: `Strong institutional ${signal.primary_signal} detected`,\n                    position_size: this.recommendPositionSize(signal),\n                    time_horizon: signal.time_horizon,\n                    confidence: signal.confidence,\n                    risk_level: this.assessSignalRisk(signal)\n                })),\n                data_source: 'REAL_INSTITUTIONAL_DATA'\n            }\n        };\n    }\n\n    // ALPHA GENERATION COORDINATOR WITH REAL DATA\n    async alphaGenerationCoordinator(symbols, exchanges, minProfitBps, confidenceLevel) {\n        console.log('🔍 Coordinating alpha generation opportunities WITH REAL DATA...');\n        \n        try {\n            // Gather all alpha sources using REAL data\n            const [arbitrageResult, inefficiencyResult, institutionalResult] = await Promise.all([\n                this.crossExchangeArbitrageScanner(symbols, exchanges, minProfitBps),\n                this.marketInefficiencyScanner(symbols, confidenceLevel),\n                this.institutionalFlowTracker(symbols)\n            ]);\n            \n            const allOpportunities = [];\n            \n            // Add arbitrage opportunities\n            if (arbitrageResult.success) {\n                arbitrageResult.arbitrage_scan.opportunities.forEach(opp => {\n                    allOpportunities.push({\n                        ...opp,\n                        type: 'ARBITRAGE',\n                        priority: this.calculateOpportunityPriority(opp, 'arbitrage'),\n                        risk_level: this.assessRiskLevel(opp),\n                        capital_requirement: opp.max_volume * opp.buy_price,\n                        expected_return: opp.estimated_profit_usd,\n                        execution_complexity: this.assessExecutionComplexity(opp),\n                        market_impact: this.estimateMarketImpact(opp),\n                        time_decay: this.calculateTimeDecay(opp)\n                    });\n                });\n            }\n            \n            // Add inefficiency opportunities\n            if (inefficiencyResult.success) {\n                inefficiencyResult.inefficiency_scan.actionable_opportunities.forEach(ineff => {\n                    allOpportunities.push({\n                        ...ineff,\n                        type: 'INEFFICIENCY',\n                        priority: this.calculateOpportunityPriority(ineff, 'inefficiency'),\n                        risk_level: this.assessRiskLevel(ineff),\n                        capital_requirement: this.estimateCapitalRequirement(ineff),\n                        expected_return: (ineff.profit_potential || ineff.strength || 0) * 10000,\n                        execution_complexity: this.assessExecutionComplexity(ineff),\n                        market_impact: this.estimateMarketImpact(ineff)\n                    });\n                });\n            }\n            \n            // Add institutional flow opportunities\n            if (institutionalResult.success) {\n                institutionalResult.institutional_flow.institutional_signals.forEach(signal => {\n                    allOpportunities.push({\n                        ...signal,\n                        type: 'INSTITUTIONAL_FLOW',\n                        priority: this.calculateOpportunityPriority(signal, 'institutional'),\n                        risk_level: this.assessRiskLevel(signal),\n                        capital_requirement: this.estimateCapitalRequirement(signal),\n                        expected_return: signal.institutional_score * 100,\n                        execution_complexity: this.assessExecutionComplexity(signal),\n                        market_impact: signal.market_impact_estimate || 'MEDIUM'\n                    });\n                });\n            }\n            \n            // Filter and sort opportunities\n            const executableOpportunities = allOpportunities\n                .filter(opp => {\n                    const confidenceValue = typeof opp.confidence === 'number' ? opp.confidence : \n                                           opp.confidence === 'HIGH' ? 90 : \n                                           opp.confidence === 'MEDIUM' ? 70 : 50;\n                    return confidenceValue >= this.confidenceThresholds[confidenceLevel];\n                })\n                .sort((a, b) => b.priority - a.priority)\n                .slice(0, 10); // Top 10 opportunities\n            \n            const totalExpectedReturn = executableOpportunities.reduce((sum, opp) => sum + (opp.expected_return || 0), 0);\n            const avgCapitalRequirement = executableOpportunities.length > 0 ? \n                executableOpportunities.reduce((sum, opp) => sum + (opp.capital_requirement || 0), 0) / executableOpportunities.length : 0;\n            \n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                alpha_coordination: {\n                    analysis_summary: {\n                        arbitrage_opportunities: arbitrageResult.success ? arbitrageResult.arbitrage_scan.opportunities_found : 0,\n                        inefficiency_opportunities: inefficiencyResult.success ? inefficiencyResult.inefficiency_scan.total_inefficiencies : 0,\n                        institutional_signals: institutionalResult.success ? institutionalResult.institutional_flow.signals_detected : 0,\n                        data_quality: 'INSTITUTIONAL_GRADE'\n                    },\n                    total_opportunities_found: allOpportunities.length,\n                    executable_opportunities: executableOpportunities.length,\n                    opportunities: executableOpportunities,\n                    expected_total_return: totalExpectedReturn,\n                    avg_capital_requirement: avgCapitalRequirement,\n                    confidence_threshold: this.confidenceThresholds[confidenceLevel],\n                    recommendation: executableOpportunities.length > 0 ? 'OPPORTUNITIES_AVAILABLE' : 'CONTINUE_MONITORING',\n                    market_regime: await this.detectMarketRegime(symbols, exchanges),\n                    next_scan: new Date(Date.now() + 15 * 60 * 1000).toISOString(),\n                    data_source: 'REAL_TIME_COMPREHENSIVE',\n                    opportunity_breakdown: {\n                        arbitrage: allOpportunities.filter(o => o.type === 'ARBITRAGE').length,\n                        inefficiency: allOpportunities.filter(o => o.type === 'INEFFICIENCY').length,\n                        institutional: allOpportunities.filter(o => o.type === 'INSTITUTIONAL_FLOW').length\n                    },\n                    top_opportunity: executableOpportunities[0] || null\n                }\n            };\n            \n        } catch (error) {\n            return {\n                success: false,\n                error: error.message,\n                timestamp: new Date().toISOString(),\n                data_source: 'REAL_TIME_APIS'\n            };\n        }\n    }\n\n    // ===== REAL DATA DETECTION METHODS =====\n    \n    async detectVolumePriceDivergence(symbol, realPrices, technicalData) {\n        const exchanges = Object.keys(realPrices);\n        if (exchanges.length === 0) return null;\n        \n        let totalVolume = 0;\n        let avgPriceChange = 0;\n        let validExchanges = 0;\n        \n        for (const exchange of exchanges) {\n            const priceData = realPrices[exchange][symbol];\n            if (priceData && !priceData.error) {\n                totalVolume += priceData.volume24h || 0;\n                avgPriceChange += priceData.change24h || 0;\n                validExchanges++;\n            }\n        }\n        \n        if (validExchanges === 0) return null;\n        \n        avgPriceChange = avgPriceChange / validExchanges;\n        \n        const volumeNormalized = totalVolume / 1000000; // Normalize to millions\n        const divergenceStrength = Math.abs(avgPriceChange) / (volumeNormalized + 1);\n        \n        if (divergenceStrength > 0.5) {\n            return {\n                type: 'VOLUME_PRICE_DIVERGENCE',\n                strength: Math.min(divergenceStrength, 1.0),\n                direction: avgPriceChange > 0 ? 'BULLISH' : 'BEARISH',\n                expected_reversion_time: '2-6 hours',\n                confidence: divergenceStrength > 0.8 ? 'HIGH' : 'MEDIUM',\n                volume_intensity: volumeNormalized,\n                price_change: avgPriceChange,\n                profit_potential: divergenceStrength * 0.02\n            };\n        }\n        \n        return null;\n    }\n    \n    async detectFundingRateArbitrage(symbol) {\n        try {\n            // Fetch REAL funding rates\n            const fundingRates = await Promise.all([\n                fetchBinanceFundingRate(symbol),\n                fetchBybitFundingRate(symbol),\n                fetchDeribitFundingRate(symbol)\n            ]);\n            \n            const validRates = fundingRates.filter(r => r !== null);\n            if (validRates.length === 0) return null;\n            \n            const maxRate = Math.max(...validRates);\n            const minRate = Math.min(...validRates);\n            const spread = maxRate - minRate;\n            \n            if (Math.abs(spread) > 0.0005) { // 0.05% threshold\n                return {\n                    type: 'FUNDING_RATE_ARBITRAGE',\n                    profit_potential: Math.abs(spread) * 3, // 3 funding periods per day\n                    annualized_yield: Math.abs(spread) * 3 * 365,\n                    risk_level: 'LOW',\n                    confidence: 'HIGH',\n                    funding_rate_spread: spread,\n                    max_rate: maxRate,\n                    min_rate: minRate,\n                    strategy: spread > 0 ? 'SHORT_HIGH_LONG_LOW' : 'LONG_HIGH_SHORT_LOW',\n                    data_source: 'REAL_EXCHANGE_DATA'\n                };\n            }\n            \n            return null;\n        } catch (error) {\n            console.error('Funding rate fetch failed:', error.message);\n            return null;\n        }\n    }\n\n    async detectOrderBookManipulation(symbol, realPrices) {\n        const exchanges = Object.keys(realPrices);\n        let manipulationScore = 0;\n        \n        for (const exchange of exchanges) {\n            const priceData = realPrices[exchange][symbol];\n            if (priceData && !priceData.error) {\n                const spread = priceData.ask - priceData.bid;\n                const spreadPct = (spread / priceData.price) * 100;\n                \n                if (spreadPct > 0.5) { // >0.5% spread is unusual\n                    manipulationScore += spreadPct;\n                }\n            }\n        }\n        \n        if (manipulationScore > 0.3) {\n            const avgPrice = Object.values(realPrices).reduce((sum, ex) => {\n                const p = ex[symbol];\n                return sum + (p && !p.error ? p.price : 0);\n            }, 0) / exchanges.length;\n            \n            return {\n                type: 'ORDER_BOOK_MANIPULATION',\n                significance: Math.min(manipulationScore, 1.0),\n                anomaly_type: 'WIDE_SPREADS',\n                likely_direction: avgPrice > 0 ? 'DETECTED' : 'UNCERTAIN',\n                confidence: manipulationScore > 0.7 ? 'HIGH' : 'MEDIUM',\n                profit_potential: manipulationScore * 0.01\n            };\n        }\n        \n        return null;\n    }\n\n    async detectSpreadAnomalies(symbol, realPrices) {\n        const exchanges = Object.keys(realPrices);\n        if (exchanges.length < 2) return null;\n        \n        const spreads = [];\n        for (const exchange of exchanges) {\n            const priceData = realPrices[exchange][symbol];\n            if (priceData && !priceData.error && priceData.bid && priceData.ask) {\n                const spread = (priceData.ask - priceData.bid) / priceData.price * 100;\n                spreads.push(spread);\n            }\n        }\n        \n        if (spreads.length < 2) return null;\n        \n        const avgSpread = spreads.reduce((sum, s) => sum + s, 0) / spreads.length;\n        const maxSpread = Math.max(...spreads);\n        const minSpread = Math.min(...spreads);\n        \n        const spreadVariance = maxSpread - minSpread;\n        \n        if (spreadVariance > avgSpread * 2) {\n            return {\n                type: 'SPREAD_ANOMALY',\n                variance: spreadVariance,\n                avg_spread: avgSpread,\n                max_spread: maxSpread,\n                min_spread: minSpread,\n                confidence: spreadVariance > avgSpread * 3 ? 'HIGH' : 'MEDIUM',\n                profit_potential: spreadVariance * 0.5,\n                arbitrage_opportunity: true\n            };\n        }\n        \n        return null;\n    }\n\n    async detectMomentumDivergence(symbol, technicalData) {\n        if (!technicalData || !technicalData[symbol]) return null;\n        \n        const indicators = technicalData[symbol].indicators;\n        if (!indicators) return null;\n        \n        if (indicators.rsi) {\n            const rsi = indicators.rsi;\n            let divergenceStrength = 0;\n            \n            if (rsi > 80) {\n                divergenceStrength = (rsi - 80) / 20;\n            } else if (rsi < 20) {\n                divergenceStrength = (20 - rsi) / 20;\n            }\n            \n            if (divergenceStrength > 0.3) {\n                return {\n                    type: 'MOMENTUM_DIVERGENCE',\n                    strength: divergenceStrength,\n                    indicator: 'RSI',\n                    value: rsi,\n                    expected_reversion: rsi > 50 ? 'BEARISH' : 'BULLISH',\n                    confidence: divergenceStrength > 0.7 ? 'HIGH' : 'MEDIUM',\n                    profit_potential: divergenceStrength * 0.03,\n                    time_horizon: '1-3 days'\n                };\n            }\n        }\n        \n        return null;\n    }\n\n    async detectLargeOrders(symbol, realPrices, historicalData) {\n        const avgVolume = historicalData ? historicalData.reduce((sum, d) => sum + d.volume, 0) / historicalData.length : 1000000;\n        \n        let currentVolume = 0;\n        const exchanges = Object.keys(realPrices);\n        for (const exchange of exchanges) {\n            const priceData = realPrices[exchange][symbol];\n            if (priceData && !priceData.error) {\n                currentVolume += priceData.volume24h || 0;\n            }\n        }\n        \n        const volumeRatio = currentVolume / avgVolume;\n        const netFlow = currentVolume > avgVolume ? currentVolume - avgVolume : avgVolume - currentVolume;\n        \n        return {\n            detected: volumeRatio > 1.5,\n            average_size: avgVolume,\n            current_volume: currentVolume,\n            volume_ratio: volumeRatio,\n            net_flow: volumeRatio > 1.5 ? netFlow : -netFlow\n        };\n    }\n\n    async detectWhaleMovements(symbol, realPrices) {\n        try {\n            const whaleData = await fetchWhaleAlertData(symbol);\n            const exchangeFlows = await fetchExchangeFlowData(symbol);\n            \n            const totalVolume = Object.values(realPrices).reduce((sum, exchangeData) => {\n                const priceData = exchangeData[symbol];\n                return sum + (priceData && !priceData.error ? priceData.volume24h || 0 : 0);\n            }, 0);\n            \n            return {\n                major_transfers: whaleData?.transfers || 0,\n                net_exchange_flow: exchangeFlows?.netFlow || 0,\n                accumulation_score: calculateAccumulationScore(whaleData, exchangeFlows, totalVolume),\n                whale_activity_level: determineWhaleActivityLevel(whaleData, totalVolume),\n                data_source: 'REAL_BLOCKCHAIN_DATA'\n            };\n        } catch (error) {\n            const totalVolume = Object.values(realPrices).reduce((sum, exchangeData) => {\n                const priceData = exchangeData[symbol];\n                return sum + (priceData && !priceData.error ? priceData.volume24h || 0 : 0);\n            }, 0);\n            \n            return {\n                major_transfers: 0,\n                net_exchange_flow: 0,\n                accumulation_score: Math.min(totalVolume / 1000000 * 10, 100),\n                whale_activity_level: totalVolume > 10000000 ? 'HIGH' : totalVolume > 1000000 ? 'MEDIUM' : 'LOW',\n                data_source: 'VOLUME_BASED_ESTIMATION'\n            };\n        }\n    }\n\n    async analyzeFuturesBasis(symbol) {\n        try {\n            const [spotPrice, futuresPrice] = await Promise.all([\n                fetchSpotPrice(symbol),\n                fetchFuturesPrice(symbol)\n            ]);\n            \n            if (!spotPrice || !futuresPrice) {\n                throw new Error('Failed to fetch prices');\n            }\n            \n            const basis = futuresPrice - spotPrice;\n            const basisPoints = (basis / spotPrice) * 10000;\n            \n            return {\n                basis_points: basisPoints,\n                trend: basisPoints > 0 ? 'CONTANGO' : 'BACKWARDATION',\n                term_structure: basisPoints > 0 ? 'CONTANGO' : 'BACKWARDATION',\n                carry_trade_opportunity: Math.abs(basisPoints) > 50,\n                spot_price: spotPrice,\n                futures_price: futuresPrice,\n                data_source: 'REAL_FUTURES_DATA'\n            };\n        } catch (error) {\n            console.error('Futures basis analysis failed:', error.message);\n            return {\n                basis_points: 0,\n                trend: 'UNKNOWN',\n                term_structure: 'UNKNOWN',\n                carry_trade_opportunity: false,\n                error: error.message\n            };\n        }\n    }\n\n    async analyzeOptionsFlow(symbol) {\n        try {\n            const optionsData = await fetchOptionsData(symbol);\n            \n            if (!optionsData) {\n                throw new Error('Failed to fetch options data');\n            }\n            \n            return {\n                put_call_ratio: optionsData.putCallRatio,\n                unusual_activity: optionsData.unusualActivity,\n                iv_skew: optionsData.ivSkew,\n                gamma_exposure: optionsData.gammaExposure,\n                largest_trades: optionsData.largestTrades,\n                net_delta: optionsData.netDelta,\n                data_source: 'REAL_OPTIONS_DATA'\n            };\n        } catch (error) {\n            console.error('Options flow analysis failed:', error.message);\n            return {\n                put_call_ratio: 1.0,\n                unusual_activity: false,\n                iv_skew: 0,\n                gamma_exposure: 0,\n                error: error.message\n            };\n        }\n    }\n\n    async analyzeExchangeFlows(symbol, realPrices) {\n        const flows = {};\n        const exchanges = Object.keys(realPrices);\n        \n        for (const exchange of exchanges) {\n            const priceData = realPrices[exchange][symbol];\n            if (priceData && !priceData.error) {\n                const volume = priceData.volume24h || 0;\n                const priceChange = priceData.change24h || 0;\n                \n                flows[exchange] = {\n                    inflow: priceChange > 0 ? volume * 0.6 : volume * 0.4,\n                    outflow: priceChange < 0 ? volume * 0.6 : volume * 0.4,\n                    net_flow: priceChange > 0 ? volume * 0.2 : -volume * 0.2,\n                    flow_direction: priceChange > 0 ? 'INFLOW' : 'OUTFLOW'\n                };\n            }\n        }\n        \n        return flows;\n    }\n\n    async analyzeFundingFlows(symbol) {\n        try {\n            const fundingRate = await fetchBinanceFundingRate(symbol);\n            \n            if (fundingRate !== null) {\n                return {\n                    funding_rate: fundingRate,\n                    funding_direction: fundingRate > 0 ? 'POSITIVE' : 'NEGATIVE',\n                    funding_trend: Math.abs(fundingRate) > 0.0001 ? 'INCREASING' : 'STABLE',\n                    arbitrage_opportunity: Math.abs(fundingRate) > 0.0005\n                };\n            }\n        } catch (error) {\n            console.error('Funding flow analysis failed:', error.message);\n        }\n        \n        return {\n            funding_rate: 0,\n            funding_direction: 'NEUTRAL',\n            funding_trend: 'UNKNOWN',\n            arbitrage_opportunity: false\n        };\n    }\n// ===== PART 5: SCORING METHODS & ARBITRAGE ENGINE =====\n    \n    // ===== SCORING AND CALCULATION METHODS =====\n    \n    calculateArbitrageRisk(buyExchange, sellExchange) {\n        const exchangeRisk = {\n            'binance': 5,\n            'kraken': 10,\n            'kucoin': 15,\n            'coinbase': 8\n        };\n        \n        const buyRisk = exchangeRisk[buyExchange.exchange] || 10;\n        const sellRisk = exchangeRisk[sellExchange.exchange] || 10;\n        \n        return (buyRisk + sellRisk) / 2;\n    }\n\n    calculateRealDataConfidence(exchangeCount, buyVolume, sellVolume) {\n        let baseConfidence = Math.min(exchangeCount * 20, 80);\n        \n        const avgVolume = (buyVolume + sellVolume) / 2;\n        if (avgVolume > 1000000) baseConfidence += 15;\n        else if (avgVolume > 100000) baseConfidence += 10;\n        else if (avgVolume > 10000) baseConfidence += 5;\n        \n        return Math.min(baseConfidence, 95);\n    }\n\n    assessMarketDataQuality(buyData, sellData) {\n        let quality = 'GOOD';\n        \n        if (buyData.timestamp && sellData.timestamp) {\n            const timeDiff = Math.abs(buyData.timestamp - sellData.timestamp);\n            if (timeDiff > 60000) quality = 'STALE';\n        }\n        \n        if (buyData.volume24h < 10000 || sellData.volume24h < 10000) {\n            quality = 'LOW_LIQUIDITY';\n        }\n        \n        return quality;\n    }\n\n    estimateExecutionWindow(profitBps) {\n        if (profitBps > 100) return 30;\n        if (profitBps > 50) return 60;\n        return 120;\n    }\n\n    calculateOverallDataQuality(opportunities) {\n        if (opportunities.length === 0) return 0;\n        \n        const qualityScores = opportunities.map(opp => {\n            if (opp.market_data_quality === 'GOOD') return 100;\n            if (opp.market_data_quality === 'STALE') return 70;\n            if (opp.market_data_quality === 'LOW_LIQUIDITY') return 50;\n            return 80;\n        });\n        \n        return qualityScores.reduce((sum, score) => sum + score, 0) / qualityScores.length;\n    }\n\n    async assessMarketConditions(symbols, exchanges) {\n        const conditions = {\n            volatility: 'NORMAL',\n            liquidity: 'ADEQUATE',\n            correlation: 'MEDIUM',\n            regime: 'NORMAL_TRADING'\n        };\n        \n        try {\n            const marketData = await this.exchangeManager.getRealTimePrices(symbols.slice(0, 3), exchanges.slice(0, 2));\n            \n            let totalVolatility = 0;\n            let validPairs = 0;\n            \n            for (const exchange of Object.keys(marketData)) {\n                for (const symbol of Object.keys(marketData[exchange])) {\n                    const data = marketData[exchange][symbol];\n                    if (data && !data.error && data.change24h !== undefined) {\n                        totalVolatility += Math.abs(data.change24h);\n                        validPairs++;\n                    }\n                }\n            }\n            \n            if (validPairs > 0) {\n                const avgVolatility = totalVolatility / validPairs;\n                if (avgVolatility > 10) conditions.volatility = 'HIGH';\n                else if (avgVolatility > 5) conditions.volatility = 'ELEVATED';\n                else if (avgVolatility < 1) conditions.volatility = 'LOW';\n            }\n        } catch (error) {\n            console.warn('Failed to assess market conditions:', error.message);\n        }\n        \n        return conditions;\n    }\n\n    getConfidenceMultiplier(confidence) {\n        const multipliers = {\n            'HIGH': 1.0,\n            'MEDIUM': 0.7,\n            'LOW': 0.4\n        };\n        return multipliers[confidence] || 0.5;\n    }\n\n    calculateMarketEfficiencyScore(inefficiencies) {\n        if (inefficiencies.length === 0) return 95;\n        \n        const avgSignificance = inefficiencies.reduce((sum, ineff) => \n            sum + (ineff.strength || ineff.profit_potential || 0.5), 0) / inefficiencies.length;\n        \n        return Math.max(30, 100 - (inefficiencies.length * 10 + avgSignificance * 50));\n    }\n\n    calculateInstitutionalScore(analysis) {\n        let score = 50;\n        let primarySignal = 'MIXED';\n        let direction = 'NEUTRAL';\n        let flowStrength = 'MEDIUM';\n        let marketImpact = 'LOW';\n        let urgency = 'NORMAL';\n        \n        if (analysis.large_orders.detected) {\n            score += 15;\n            primarySignal = 'LARGE_ORDER_FLOW';\n            direction = analysis.large_orders.net_flow > 0 ? 'BULLISH' : 'BEARISH';\n            flowStrength = analysis.large_orders.volume_ratio > 2 ? 'STRONG' : 'MEDIUM';\n        }\n        \n        if (analysis.whale_movements.accumulation_score > 70) {\n            score += 20;\n            if (primarySignal === 'MIXED') {\n                primarySignal = 'WHALE_ACCUMULATION';\n                direction = 'BULLISH';\n            }\n            marketImpact = 'HIGH';\n        }\n        \n        if (Math.abs(analysis.futures_basis.basis_points) > 50) {\n            score += 10;\n            if (analysis.futures_basis.carry_trade_opportunity) {\n                urgency = 'HIGH';\n            }\n        }\n        \n        if (analysis.options_flow.unusual_activity) {\n            score += 15;\n            urgency = 'HIGH';\n        }\n        \n        const exchangeFlows = Object.values(analysis.exchange_flows || {});\n        if (exchangeFlows.length > 0) {\n            const netFlow = exchangeFlows.reduce((sum, flow) => sum + (flow.net_flow || 0), 0);\n            if (Math.abs(netFlow) > 1000000) {\n                score += 10;\n                marketImpact = 'MEDIUM';\n            }\n        }\n        \n        return {\n            score: Math.min(100, score),\n            primary_signal: primarySignal,\n            direction: direction,\n            confidence: score > 80 ? 'HIGH' : score > 65 ? 'MEDIUM' : 'LOW',\n            time_horizon: score > 80 ? '1-3 days' : '3-7 days',\n            flow_strength: flowStrength,\n            market_impact: marketImpact,\n            urgency: urgency,\n            evidence: [\n                analysis.large_orders.detected ? 'Large order activity' : null,\n                analysis.whale_movements.accumulation_score > 70 ? 'Whale accumulation' : null,\n                analysis.options_flow.unusual_activity ? 'Unusual options activity' : null,\n                analysis.futures_basis.carry_trade_opportunity ? 'Carry trade opportunity' : null\n            ].filter(Boolean)\n        };\n    }\n\n    assessMarketStructureHealth(signals) {\n        if (signals.length === 0) return 'NEUTRAL';\n        \n        const bullishSignals = signals.filter(s => s.direction === 'BULLISH').length;\n        const bearishSignals = signals.filter(s => s.direction === 'BEARISH').length;\n        const totalFlow = signals.reduce((sum, s) => sum + s.institutional_score, 0);\n        \n        let health = 'NEUTRAL';\n        \n        if (bullishSignals > bearishSignals * 2) health = 'STRONG_BULLISH';\n        else if (bearishSignals > bullishSignals * 2) health = 'STRONG_BEARISH';\n        else if (bullishSignals > bearishSignals) health = 'MODERATELY_BULLISH';\n        else if (bearishSignals > bullishSignals) health = 'MODERATELY_BEARISH';\n        \n        return {\n            overall_health: health,\n            flow_intensity: totalFlow / signals.length,\n            signal_consistency: Math.abs(bullishSignals - bearishSignals) / signals.length,\n            market_participation: signals.length > 5 ? 'HIGH' : signals.length > 2 ? 'MEDIUM' : 'LOW'\n        };\n    }\n\n    calculateFlowIntensity(signals) {\n        if (signals.length === 0) return 0;\n        \n        const totalScore = signals.reduce((sum, signal) => sum + signal.institutional_score, 0);\n        const avgScore = totalScore / signals.length;\n        const highConfidenceSignals = signals.filter(s => s.confidence === 'HIGH').length;\n        \n        return {\n            average_score: avgScore,\n            intensity_level: avgScore > 80 ? 'EXTREME' : avgScore > 70 ? 'HIGH' : avgScore > 60 ? 'MEDIUM' : 'LOW',\n            high_confidence_ratio: highConfidenceSignals / signals.length,\n            flow_direction: this.calculateNetFlowDirection(signals)\n        };\n    }\n\n    calculateNetFlowDirection(signals) {\n        const bullishWeight = signals\n            .filter(s => s.direction === 'BULLISH')\n            .reduce((sum, s) => sum + s.institutional_score, 0);\n        \n        const bearishWeight = signals\n            .filter(s => s.direction === 'BEARISH')\n            .reduce((sum, s) => sum + s.institutional_score, 0);\n        \n        const netWeight = bullishWeight - bearishWeight;\n        \n        if (Math.abs(netWeight) < 50) return 'NEUTRAL';\n        return netWeight > 0 ? 'BULLISH' : 'BEARISH';\n    }\n\n    detectSectorRotation(signals) {\n        const sectorFlows = {};\n        \n        signals.forEach(signal => {\n            // Dynamic sector detection based on symbol\n            const sector = this.determineSector(signal.symbol);\n            if (!sectorFlows[sector]) {\n                sectorFlows[sector] = { score: 0, count: 0 };\n            }\n            sectorFlows[sector].score += signal.institutional_score;\n            sectorFlows[sector].count += 1;\n        });\n        \n        const sectorAverages = {};\n        Object.keys(sectorFlows).forEach(sector => {\n            sectorAverages[sector] = sectorFlows[sector].score / sectorFlows[sector].count;\n        });\n        \n        return {\n            sector_flows: sectorAverages,\n            rotation_detected: Object.keys(sectorAverages).length > 2,\n            leading_sector: Object.keys(sectorAverages).length > 0 ? \n                Object.keys(sectorAverages).reduce((a, b) => \n                    sectorAverages[a] > sectorAverages[b] ? a : b\n                ) : null,\n            lagging_sector: Object.keys(sectorAverages).length > 0 ?\n                Object.keys(sectorAverages).reduce((a, b) => \n                    sectorAverages[a] < sectorAverages[b] ? a : b\n                ) : null\n        };\n    }\n\n    determineSector(symbol) {\n        // This would be expanded with a comprehensive mapping\n        // For now, using basic categorization\n        const symbolUpper = symbol.toUpperCase();\n        \n        if (['BTC', 'LTC', 'BCH'].includes(symbolUpper)) return 'STORE_OF_VALUE';\n        if (['ETH', 'ETC'].includes(symbolUpper)) return 'SMART_CONTRACTS';\n        if (['SOL', 'ADA', 'AVAX', 'NEAR', 'ALGO'].includes(symbolUpper)) return 'LAYER1';\n        if (['DOT', 'ATOM', 'COSMOS'].includes(symbolUpper)) return 'INTEROPERABILITY';\n        if (['LINK', 'BAND', 'API3'].includes(symbolUpper)) return 'ORACLES';\n        if (['MATIC', 'ARB', 'OP'].includes(symbolUpper)) return 'SCALING';\n        if (['UNI', 'SUSHI', 'CAKE'].includes(symbolUpper)) return 'DEFI';\n        \n        return 'OTHER';\n    }\n\n    recommendPositionSize(signal) {\n        const baseSize = 1000;\n        const confidenceMultiplier = signal.confidence === 'HIGH' ? 2 : signal.confidence === 'MEDIUM' ? 1.5 : 1;\n        const scoreMultiplier = signal.institutional_score / 100;\n        \n        return Math.round(baseSize * confidenceMultiplier * scoreMultiplier);\n    }\n\n    assessSignalRisk(signal) {\n        let risk = 'MEDIUM';\n        \n        if (signal.confidence === 'HIGH' && signal.institutional_score > 80) {\n            risk = 'LOW';\n        } else if (signal.confidence === 'LOW' || signal.institutional_score < 60) {\n            risk = 'HIGH';\n        }\n        \n        if (signal.execution_urgency === 'HIGH') {\n            risk = risk === 'LOW' ? 'MEDIUM' : 'HIGH';\n        }\n        \n        return risk;\n    }\n\n    calculateOpportunityPriority(opportunity, type) {\n        let priority = 50;\n        \n        if (type === 'arbitrage') {\n            priority += opportunity.profit_bps || 0;\n            priority += opportunity.estimated_profit_usd / 100;\n            if (opportunity.risk_score < 20) priority += 10;\n            if (opportunity.confidence > 80) priority += 15;\n            if (opportunity.market_data_quality === 'GOOD') priority += 10;\n        } else if (type === 'inefficiency') {\n            priority += (opportunity.strength || opportunity.profit_potential || 0) * 100;\n            if (opportunity.confidence === 'HIGH') priority += 20;\n            priority += opportunity.profit_potential * 1000;\n        } else if (type === 'institutional') {\n            priority += opportunity.institutional_score || 0;\n            if (opportunity.confidence === 'HIGH') priority += 15;\n            if (opportunity.execution_urgency === 'HIGH') priority += 10;\n            if (opportunity.market_impact === 'HIGH') priority += 5;\n        }\n        \n        return Math.min(100, priority);\n    }\n\n    assessRiskLevel(opportunity) {\n        let risk = 'MEDIUM';\n        \n        if (opportunity.confidence > 80 && opportunity.profit_bps > 50) {\n            risk = 'LOW';\n        } else if (opportunity.confidence < 60 || (opportunity.profit_bps && opportunity.profit_bps < 25)) {\n            risk = 'HIGH';\n        }\n        \n        return risk;\n    }\n\n    assessExecutionComplexity(opportunity) {\n        if (opportunity.type === 'ARBITRAGE') {\n            return opportunity.buy_exchange === opportunity.sell_exchange ? 'LOW' : 'MEDIUM';\n        } else if (opportunity.type === 'INEFFICIENCY') {\n            return 'HIGH';\n        } else if (opportunity.type === 'INSTITUTIONAL_FLOW') {\n            return opportunity.execution_urgency === 'HIGH' ? 'HIGH' : 'MEDIUM';\n        }\n        \n        return 'MEDIUM';\n    }\n\n    estimateMarketImpact(opportunity) {\n        if (opportunity.max_volume && opportunity.max_volume > 1000000) return 'HIGH';\n        if (opportunity.capital_requirement && opportunity.capital_requirement > 100000) return 'MEDIUM';\n        return 'LOW';\n    }\n\n    calculateTimeDecay(opportunity) {\n        if (opportunity.type === 'ARBITRAGE') {\n            return opportunity.profit_bps > 100 ? 'FAST' : 'MEDIUM';\n        }\n        return 'SLOW';\n    }\n\n    estimateCapitalRequirement(opportunity) {\n        if (opportunity.type === 'INEFFICIENCY') {\n            const baseCapital = 10000;\n            const multiplier = (opportunity.profit_potential || 0.01) * 100;\n            return baseCapital * Math.max(multiplier, 0.5);\n        } else if (opportunity.type === 'INSTITUTIONAL_FLOW') {\n            return opportunity.institutional_score * 500;\n        }\n        \n        return 10000;\n    }\n\n    async generateExecutionPlan(opportunities) {\n        const plan = opportunities.map((opportunity, index) => ({\n            opportunity,\n            execution_order: index + 1,\n            expected_return: opportunity.expected_return || 0,\n            execution_priority: opportunity.priority,\n            estimated_execution_time: this.estimateExecutionTime(opportunity),\n            success_probability: this.calculateSuccessProbability(opportunity),\n            capital_requirement: opportunity.capital_requirement || 0,\n            risk_level: opportunity.risk_level || 'MEDIUM'\n        }));\n        \n        return plan;\n    }\n\n    estimateExecutionTime(opportunity) {\n        const baseTime = {\n            'ARBITRAGE': 60,\n            'INEFFICIENCY': 300,\n            'INSTITUTIONAL_FLOW': 900\n        };\n        \n        return baseTime[opportunity.type] || 300;\n    }\n\n    calculateSuccessProbability(opportunity) {\n        let probability = 0.7;\n        \n        if (opportunity.confidence === 'HIGH') probability += 0.2;\n        else if (opportunity.confidence === 'LOW') probability -= 0.2;\n        \n        if (opportunity.risk_level === 'LOW') probability += 0.1;\n        else if (opportunity.risk_level === 'HIGH') probability -= 0.1;\n        \n        if (opportunity.market_data_quality === 'GOOD') probability += 0.1;\n        \n        return Math.max(0.1, Math.min(0.95, probability));\n    }\n\n    async detectMarketRegime(symbols, exchanges) {\n        try {\n            const marketData = await this.exchangeManager.getRealTimePrices(symbols.slice(0, 3), exchanges.slice(0, 2));\n            \n            let totalVolatility = 0;\n            let totalVolume = 0;\n            let validPairs = 0;\n            \n            for (const exchange of Object.keys(marketData)) {\n                for (const symbol of Object.keys(marketData[exchange])) {\n                    const data = marketData[exchange][symbol];\n                    if (data && !data.error) {\n                        if (data.change24h !== undefined) {\n                            totalVolatility += Math.abs(data.change24h);\n                        }\n                        if (data.volume24h !== undefined) {\n                            totalVolume += data.volume24h;\n                        }\n                        validPairs++;\n                    }\n                }\n            }\n            \n            if (validPairs > 0) {\n                const avgVolatility = totalVolatility / validPairs;\n                const avgVolume = totalVolume / validPairs;\n                \n                let regime = 'NORMAL';\n                if (avgVolatility > 10 && avgVolume > 1000000) regime = 'HIGH_VOLATILITY_HIGH_VOLUME';\n                else if (avgVolatility > 10) regime = 'HIGH_VOLATILITY';\n                else if (avgVolume > 5000000) regime = 'HIGH_VOLUME';\n                else if (avgVolatility < 1) regime = 'LOW_VOLATILITY';\n                \n                return {\n                    regime: regime,\n                    volatility: avgVolatility,\n                    volume: avgVolume,\n                    confidence: validPairs > 4 ? 'HIGH' : 'MEDIUM'\n                };\n            }\n        } catch (error) {\n            console.warn('Failed to detect market regime:', error.message);\n        }\n        \n        return {\n            regime: 'UNKNOWN',\n            volatility: 0,\n            volume: 0,\n            confidence: 'LOW'\n        };\n    }\n}\n// ===== PART 6: ENTERPRISE INFRASTRUCTURE CLASSES =====\n\n// ===== ENTERPRISE SYMBOL MAPPER =====\nclass EnterpriseSymbolMapper {\n    constructor() {\n        this.symbolMappings = new Map();\n        this.reverseMapping = new Map();\n        this.alternativeSymbols = new Map();\n        \n        this.initializeSymbolMappings();\n    }\n    \n    async initializeSymbolMappings() {\n        // Fetch real symbol mappings from exchanges\n        try {\n            const [binanceSymbols, krakenAssets] = await Promise.all([\n                this.fetchBinanceSymbols(),\n                this.fetchKrakenAssets()\n            ]);\n            \n            // Build dynamic mappings from real data\n            this.buildDynamicMappings(binanceSymbols, krakenAssets);\n        } catch (error) {\n            console.error('Failed to initialize symbol mappings:', error.message);\n            // Use basic fallback structure\n            this.initializeFallbackMappings();\n        }\n    }\n    \n    async fetchBinanceSymbols() {\n        try {\n            const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');\n            if (!response.ok) throw new Error('Failed to fetch Binance symbols');\n            const data = await response.json();\n            return data.symbols;\n        } catch {\n            return [];\n        }\n    }\n    \n    async fetchKrakenAssets() {\n        try {\n            const response = await fetch('https://api.kraken.com/0/public/Assets');\n            if (!response.ok) throw new Error('Failed to fetch Kraken assets');\n            const data = await response.json();\n            return data.result;\n        } catch {\n            return {};\n        }\n    }\n    \n    buildDynamicMappings(binanceSymbols, krakenAssets) {\n        // Build mappings from real exchange data\n        const baseAssets = new Set();\n        \n        // Extract base assets from Binance\n        binanceSymbols.forEach(symbol => {\n            if (symbol.status === 'TRADING') {\n                baseAssets.add(symbol.baseAsset);\n            }\n        });\n        \n        // Build mappings for each asset\n        baseAssets.forEach(asset => {\n            const mapping = {\n                binance: `${asset}USDT`,\n                kraken: this.findKrakenPair(asset, krakenAssets),\n                kucoin: `${asset}-USDT`,\n                coinbase: `${asset}-USD`,\n                alternatives: []\n            };\n            \n            this.symbolMappings.set(asset, mapping);\n        });\n    }\n    \n    findKrakenPair(asset, krakenAssets) {\n        // Map common assets to Kraken format\n        const krakenMap = {\n            'BTC': 'XXBTZUSD',\n            'ETH': 'XETHZUSD',\n            'LTC': 'XLTCZUSD'\n        };\n        \n        return krakenMap[asset] || `${asset}USD`;\n    }\n    \n    initializeFallbackMappings() {\n        // Basic fallback mappings if API calls fail\n        const basicMappings = {\n            'BTC': {\n                binance: 'BTCUSDT',\n                kraken: 'XXBTZUSD',\n                kucoin: 'BTC-USDT',\n                coinbase: 'BTC-USD'\n            },\n            'ETH': {\n                binance: 'ETHUSDT',\n                kraken: 'XETHZUSD',\n                kucoin: 'ETH-USDT',\n                coinbase: 'ETH-USD'\n            }\n        };\n        \n        Object.entries(basicMappings).forEach(([symbol, config]) => {\n            this.symbolMappings.set(symbol, config);\n        });\n    }\n    \n    resolveSymbol(symbol, exchange) {\n        const mapping = this.symbolMappings.get(symbol.toUpperCase());\n        if (mapping && mapping[exchange]) {\n            return mapping[exchange];\n        }\n        \n        const primarySymbol = this.alternativeSymbols.get(symbol.toUpperCase());\n        if (primarySymbol) {\n            const primaryMapping = this.symbolMappings.get(primarySymbol);\n            if (primaryMapping && primaryMapping[exchange]) {\n                return primaryMapping[exchange];\n            }\n        }\n        \n        return this.generateFallbackFormat(symbol, exchange);\n    }\n    \n    generateFallbackFormat(symbol, exchange) {\n        switch (exchange) {\n            case 'binance':\n                return `${symbol.toUpperCase()}USDT`;\n            case 'kraken':\n                return `${symbol.toUpperCase()}USD`;\n            case 'kucoin':\n                return `${symbol.toUpperCase()}-USDT`;\n            case 'coinbase':\n                return `${symbol.toUpperCase()}-USD`;\n            default:\n                return symbol.toUpperCase();\n        }\n    }\n    \n    getAllAlternatives(symbol) {\n        const mapping = this.symbolMappings.get(symbol.toUpperCase());\n        return mapping?.alternatives || [];\n    }\n}\n\n// ===== ENTERPRISE CIRCUIT BREAKER SYSTEM =====\nclass ExchangeCircuitBreaker {\n    constructor() {\n        this.breakers = new Map();\n        this.healthMetrics = new Map();\n        this.config = {\n            failureThreshold: 5,\n            recoveryTimeout: 30000,\n            halfOpenMaxAttempts: 3,\n            successThreshold: 2\n        };\n    }\n    \n    async executeWithBreaker(exchangeKey, operation, fallback = null) {\n    const breaker = this.getOrCreateBreaker(exchangeKey);\n    \n    if (breaker.state === 'OPEN') {\n        if (Date.now() - breaker.lastFailure > this.config.recoveryTimeout) {\n            breaker.state = 'HALF_OPEN';\n            breaker.halfOpenAttempts = 0;\n            console.log(`⚡ Circuit breaker HALF_OPEN for ${exchangeKey}`);\n        } else {\n            if (fallback) return await fallback();\n            return null; // Return null instead of throwing\n        }\n    }\n    \n    try {\n        const result = await Promise.race([\n            operation(),\n            new Promise((_, reject) => \n                setTimeout(() => reject(new Error('Operation timeout')), 15000)\n            )\n        ]);\n        \n        this.recordSuccess(exchangeKey);\n        return result;\n        \n    } catch (error) {\n        // Don't record failure for expected errors\n        if (error.message.includes('Unknown asset') || \n            error.message.includes('Invalid symbol') ||\n            error.message.includes('No data received') ||\n            error.message.includes('EQuery:Unknown asset pair')) {\n            return fallback ? await fallback() : null;\n        }\n        \n        this.recordFailure(exchangeKey, error);\n        \n        if (fallback) {\n            console.warn(`⚠️ Using fallback for ${exchangeKey}: ${error.message}`);\n            return await fallback();\n        }\n        \n        throw error;\n    }\n    }\n    \n    getOrCreateBreaker(exchangeKey) {\n        if (!this.breakers.has(exchangeKey)) {\n            this.breakers.set(exchangeKey, {\n                state: 'CLOSED',\n                failures: 0,\n                successes: 0,\n                lastFailure: 0,\n                halfOpenAttempts: 0\n            });\n        }\n        return this.breakers.get(exchangeKey);\n    }\n    \n    recordSuccess(exchangeKey) {\n        const breaker = this.getOrCreateBreaker(exchangeKey);\n        breaker.failures = 0;\n        breaker.successes++;\n        \n        if (breaker.state === 'HALF_OPEN' && breaker.successes >= this.config.successThreshold) {\n            breaker.state = 'CLOSED';\n            console.log(`✅ Circuit breaker CLOSED for ${exchangeKey}`);\n        }\n    }\n    \n    recordFailure(exchangeKey, error) {\n        const breaker = this.getOrCreateBreaker(exchangeKey);\n        breaker.failures++;\n        breaker.lastFailure = Date.now();\n        breaker.successes = 0;\n        \n        if (breaker.state === 'HALF_OPEN') {\n            breaker.halfOpenAttempts++;\n            if (breaker.halfOpenAttempts >= this.config.halfOpenMaxAttempts) {\n                breaker.state = 'OPEN';\n                console.error(`🔴 Circuit breaker OPEN for ${exchangeKey}`);\n            }\n        } else if (breaker.failures >= this.config.failureThreshold) {\n            breaker.state = 'OPEN';\n            console.error(`🔴 Circuit breaker OPEN for ${exchangeKey} after ${breaker.failures} failures`);\n        }\n    }\n    \n    getHealthReport() {\n        const report = {};\n        this.breakers.forEach((breaker, exchangeKey) => {\n            report[exchangeKey] = {\n                state: breaker.state,\n                failures: breaker.failures,\n                successes: breaker.successes,\n                healthy: breaker.state === 'CLOSED'\n            };\n        });\n        return report;\n    }\n}\n\n// ===== INTELLIGENT RATE LIMITING SYSTEM =====\nclass ExchangeRateLimiter {\n    constructor() {\n        this.limits = new Map();\n        this.queues = new Map();\n        \n        this.rateLimits = {\n            binance: { requests: 1200, weight: 1200 },\n            kraken: { requests: 1800, weight: 1800 },\n            kucoin: { requests: 1500, weight: 1500 },\n            coinbase: { requests: 600, weight: 600 }\n        };\n    }\n    \n    async executeWithRateLimit(exchange, operation, weight = 1) {\n        const limiter = this.getOrCreateLimiter(exchange);\n        \n        await this.waitForRateLimit(exchange, weight);\n        \n        limiter.requests.push({\n            timestamp: Date.now(),\n            weight: weight\n        });\n        \n        this.cleanOldRequests(exchange);\n        \n        return await operation();\n    }\n    \n    getOrCreateLimiter(exchange) {\n        if (!this.limits.has(exchange)) {\n            this.limits.set(exchange, {\n                requests: [],\n                lastRequest: 0\n            });\n        }\n        return this.limits.get(exchange);\n    }\n    \n    async waitForRateLimit(exchange, weight) {\n        const limiter = this.getOrCreateLimiter(exchange);\n        const limit = this.rateLimits[exchange];\n        \n        if (!limit) return;\n        \n        const now = Date.now();\n        const oneMinuteAgo = now - 60000;\n        \n        const recentRequests = limiter.requests.filter(req => req.timestamp > oneMinuteAgo);\n        const currentWeight = recentRequests.reduce((sum, req) => sum + req.weight, 0);\n        \n        if (currentWeight + weight > limit.weight) {\n            const oldestRequest = recentRequests[0];\n            const waitTime = oldestRequest ? (oldestRequest.timestamp + 60000) - now : 0;\n            \n            if (waitTime > 0) {\n                console.log(`⏰ Rate limiting ${exchange}: waiting ${waitTime}ms`);\n                await new Promise(resolve => setTimeout(resolve, waitTime));\n            }\n        }\n    }\n    \n    cleanOldRequests(exchange) {\n        const limiter = this.getOrCreateLimiter(exchange);\n        const oneMinuteAgo = Date.now() - 60000;\n        limiter.requests = limiter.requests.filter(req => req.timestamp > oneMinuteAgo);\n    }\n}\n\n// ===== ENHANCED PRICE FETCHER WITH MULTIPLE FALLBACKS =====\nclass EnhancedPriceFetcher {\n    constructor(symbolMapper, circuitBreaker, rateLimiter) {\n        this.symbolMapper = symbolMapper;\n        this.circuitBreaker = circuitBreaker;\n        this.rateLimiter = rateLimiter;\n        this.priceCache = new Map();\n        this.cacheTimeout = 5000;\n    }\n    \n    async fetchExchangePrices(exchange, symbols) {\n        const prices = {};\n        const errors = [];\n        \n        for (const symbol of symbols) {\n            try {\n                const price = await this.fetchPriceWithFallback(symbol, exchange);\n                if (price !== null) {\n                    prices[symbol] = price;\n                } else {\n                    errors.push(`No price data for ${symbol}`);\n                }\n            } catch (error) {\n                console.error(`Price fetch failed for ${symbol} on ${exchange}:`, error.message);\n                errors.push(`${symbol}: ${error.message}`);\n            }\n        }\n        \n        return { prices, errors };\n    }\n    \n    async fetchPriceWithFallback(symbol, exchange) {\n        const cacheKey = `${exchange}_${symbol}`;\n        const cached = this.priceCache.get(cacheKey);\n        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n            return cached.price;\n        }\n        \n        let price = await this.attemptPriceFetch(symbol, exchange);\n        \n        if (price === null) {\n            const alternatives = this.symbolMapper.getAllAlternatives(symbol);\n            for (const altSymbol of alternatives) {\n                price = await this.attemptPriceFetch(altSymbol, exchange);\n                if (price !== null) {\n                    console.log(`✅ Found price for ${symbol} using alternative ${altSymbol}`);\n                    break;\n                }\n            }\n        }\n        \n        if (price !== null) {\n            this.priceCache.set(cacheKey, {\n                price: price,\n                timestamp: Date.now()\n            });\n        }\n        \n        return price;\n    }\n    \n    async attemptPriceFetch(symbol, exchange) {\n        const exchangeSymbol = this.symbolMapper.resolveSymbol(symbol, exchange);\n        \n        return await this.circuitBreaker.executeWithBreaker(\n            `${exchange}_price`,\n            async () => await this.rateLimiter.executeWithRateLimit(\n                exchange,\n                async () => await this.fetchFromExchange(exchangeSymbol, exchange)\n            ),\n            async () => null\n        );\n    }\n    \n    async fetchFromExchange(symbol, exchange) {\n        switch (exchange) {\n            case 'binance':\n                return await this.fetchBinancePrice(symbol);\n            case 'kraken':\n                return await this.fetchKrakenPrice(symbol);\n            case 'kucoin':\n                return await this.fetchKuCoinPrice(symbol);\n            case 'coinbase':\n                return await this.fetchCoinbasePrice(symbol);\n            default:\n                throw new Error(`Unsupported exchange: ${exchange}`);\n        }\n    }\n    \n    async fetchBinancePrice(symbol) {\n        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`, {\n            timeout: 10000,\n            headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Binance API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        const price = parseFloat(data.price);\n        \n        // Fetch order book for real bid/ask\n        try {\n            const obResponse = await fetch(`https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=5`);\n            if (obResponse.ok) {\n                const obData = await obResponse.json();\n                return {\n                    bid: parseFloat(obData.bids[0][0]),\n                    ask: parseFloat(obData.asks[0][0]),\n                    last: price,\n                    timestamp: Date.now()\n                };\n            }\n        } catch {\n            // Fallback to estimated bid/ask\n        }\n        \n        return {\n            bid: price * 0.9995,\n            ask: price * 1.0005,\n            last: price,\n            timestamp: Date.now()\n        };\n    }\n    \n    async fetchKrakenPrice(symbol) {\n        const response = await fetch(`https://api.kraken.com/0/public/Ticker?pair=${symbol}`, {\n            timeout: 10000,\n            headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Kraken API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.error && data.error.length > 0) {\n            throw new Error(`Kraken API errors: ${data.error.join(', ')}`);\n        }\n        \n        const ticker = Object.values(data.result)[0];\n        if (!ticker) {\n            throw new Error('Invalid ticker data from Kraken');\n        }\n        \n        return {\n            bid: parseFloat(ticker.b[0]),\n            ask: parseFloat(ticker.a[0]),\n            last: parseFloat(ticker.c[0]),\n            timestamp: Date.now()\n        };\n    }\n    \n    async fetchKuCoinPrice(symbol) {\n        const response = await fetch(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${symbol}`, {\n            timeout: 10000,\n            headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`KuCoin API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (!data.data) {\n            throw new Error('No data received from KuCoin');\n        }\n        \n        return {\n            bid: parseFloat(data.data.bestBid),\n            ask: parseFloat(data.data.bestAsk),\n            last: parseFloat(data.data.price),\n            timestamp: Date.now()\n        };\n    }\n    \n    async fetchCoinbasePrice(symbol) {\n        const response = await fetch(`https://api.exchange.coinbase.com/products/${symbol}/ticker`, {\n            timeout: 10000,\n            headers: { 'User-Agent': 'Crypto-Universe-Enterprise/2.0' }\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Coinbase API error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        return {\n            bid: parseFloat(data.bid),\n            ask: parseFloat(data.ask),\n            last: parseFloat(data.price),\n            timestamp: Date.now()\n        };\n    }\n}\n// ===== PART 7: ENTERPRISE ARBITRAGE ENGINE =====\n\nclass EnterpriseArbitrageEngine {\n    constructor(exchangeManager) {\n        this.exchangeManager = exchangeManager;\n        this.symbolMapper = new EnterpriseSymbolMapper();\n        this.circuitBreaker = new ExchangeCircuitBreaker();\n        this.rateLimiter = new ExchangeRateLimiter();\n        this.priceFetcher = new EnhancedPriceFetcher(this.symbolMapper, this.circuitBreaker, this.rateLimiter);\n    }\n\n    async scanArbitrageOpportunities(exchangeList, minProfit, maxCapital, filter) {\n        console.log('🔍 Scanning enhanced arbitrage opportunities...');\n        \n        const exchangesToScan = this.parseExchangeList(exchangeList);\n        const assetsToScan = await this.getAssetsToScan(filter);\n        const opportunities = [];\n        const exchangeHealthReport = this.circuitBreaker.getHealthReport();\n        \n        console.log(`Scanning ${assetsToScan.length} assets across ${exchangesToScan.length} exchanges`);\n        \n        for (const asset of assetsToScan) {\n            try {\n                const exchangePrices = {};\n                const priceErrors = [];\n                \n                // Fetch prices from all exchanges using REAL data\n                for (const exchange of exchangesToScan) {\n                    try {\n                        const priceData = await this.priceFetcher.fetchPriceWithFallback(asset, exchange);\n                        if (priceData) {\n                            exchangePrices[exchange] = priceData;\n                        } else {\n                            priceErrors.push(`${exchange}: No price data`);\n                        }\n                    } catch (error) {\n                        priceErrors.push(`${exchange}: ${error.message}`);\n                    }\n                }\n                \n                if (Object.keys(exchangePrices).length < 2) {\n                    console.warn(`Skipping ${asset} - insufficient price data`);\n                    continue;\n                }\n                \n                // Find best buy and sell opportunities\n                const exchanges = Object.keys(exchangePrices);\n                let bestBuyExchange = null;\n                let bestSellExchange = null;\n                let lowestAsk = Infinity;\n                let highestBid = 0;\n                \n                exchanges.forEach(exchange => {\n                    const price = exchangePrices[exchange];\n                    if (price.ask < lowestAsk) {\n                        lowestAsk = price.ask;\n                        bestBuyExchange = exchange;\n                    }\n                    if (price.bid > highestBid) {\n                        highestBid = price.bid;\n                        bestSellExchange = exchange;\n                    }\n                });\n                \n                if (bestBuyExchange && bestSellExchange && bestBuyExchange !== bestSellExchange) {\n                    const rawProfit = highestBid - lowestAsk;\n                    const profitBps = (rawProfit / lowestAsk) * 10000;\n                    \n                    if (profitBps >= minProfit) {\n                        const buyFee = this.getExchangeFee(bestBuyExchange) * lowestAsk;\n                        const sellFee = this.getExchangeFee(bestSellExchange) * highestBid;\n                        const maxQuantity = Math.min(maxCapital / lowestAsk, 100);\n                        \n                        const netProfitUsd = (rawProfit * maxQuantity) - (buyFee * maxQuantity) - (sellFee * maxQuantity);\n                        \n                        opportunities.push({\n                            asset: asset,\n                            buy_exchange: bestBuyExchange,\n                            sell_exchange: bestSellExchange,\n                            buy_price: lowestAsk,\n                            sell_price: highestBid,\n                            profit_bps: Math.round(profitBps),\n                            profit_usd: parseFloat(netProfitUsd.toFixed(2)),\n                            max_quantity: maxQuantity,\n                            confidence: this.calculateConfidence(exchangePrices, priceErrors.length),\n                            execution_time_estimate: this.estimateExecutionTime(bestBuyExchange, bestSellExchange),\n                            market_impact: this.estimateMarketImpact(maxQuantity, exchangePrices[bestBuyExchange], exchangePrices[bestSellExchange]),\n                            timestamp: new Date().toISOString()\n                        });\n                    }\n                }\n                \n            } catch (error) {\n                console.error(`Error processing ${asset}:`, error.message);\n            }\n        }\n        \n        opportunities.sort((a, b) => b.profit_usd - a.profit_usd);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            arbitrage_scan: {\n                exchanges_scanned: exchangesToScan,\n                assets_scanned: assetsToScan.length,\n                opportunities_found: opportunities.length,\n                top_opportunities: opportunities.slice(0, 10),\n                total_potential_profit: opportunities.reduce((sum, opp) => sum + opp.profit_usd, 0),\n                min_profit_threshold: minProfit,\n                exchange_health: exchangeHealthReport,\n                scanning_performance: {\n                    total_assets_processed: assetsToScan.length,\n                    successful_scans: opportunities.length,\n                    failed_assets: assetsToScan.length - opportunities.length\n                }\n            }\n        };\n    }\n\n    async scanTriangularArbitrage(exchangeList, minProfit, maxCapital) {\n        console.log('🔺 Scanning triangular arbitrage opportunities...');\n        \n        const exchangesToScan = this.parseExchangeList(exchangeList);\n        const opportunities = [];\n        \n        for (const exchange of exchangesToScan) {\n            try {\n                const triangularPaths = await this.getTriangularPaths();\n                \n                for (const path of triangularPaths) {\n                    const pathOpportunity = await this.calculateTriangularArbitrageProfit(exchange, path, minProfit, maxCapital);\n                    if (pathOpportunity && pathOpportunity.profit_bps >= minProfit) {\n                        opportunities.push(pathOpportunity);\n                    }\n                }\n            } catch (error) {\n                console.error(`Triangular arbitrage scan error on ${exchange}:`, error.message);\n            }\n        }\n        \n        opportunities.sort((a, b) => b.profit_usd - a.profit_usd);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            triangular_arbitrage: {\n                exchanges_scanned: exchangesToScan,\n                opportunities_found: opportunities.length,\n                top_opportunities: opportunities.slice(0, 5),\n                total_potential_profit: opportunities.reduce((sum, opp) => sum + opp.profit_usd, 0),\n                complexity: 'HIGH',\n                min_profit_threshold: minProfit,\n                exchange_health: this.circuitBreaker.getHealthReport()\n            }\n        };\n    }\n\n    async scanCrossAssetArbitrage(exchangeList, minProfit, maxCapital) {\n        console.log('🔄 Scanning cross-asset arbitrage opportunities...');\n        \n        const exchangesToScan = this.parseExchangeList(exchangeList);\n        const crossAssetOpportunities = [];\n        \n        // Get dynamically discovered asset pairs\n        const assetPairs = await this.getDynamicAssetPairs();\n        \n        for (const exchange of exchangesToScan) {\n            for (const [assetA, assetB] of assetPairs) {\n                try {\n                    const crossOpportunity = await this.calculateCrossAssetRatio(exchange, assetA, assetB, minProfit, maxCapital);\n                    if (crossOpportunity && crossOpportunity.profit_bps >= minProfit) {\n                        crossAssetOpportunities.push(crossOpportunity);\n                    }\n                } catch (error) {\n                    console.error(`Cross-asset arbitrage scan error on ${exchange} for ${assetA}/${assetB}:`, error.message);\n                }\n            }\n        }\n        \n        crossAssetOpportunities.sort((a, b) => b.profit_usd - a.profit_usd);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            cross_asset_arbitrage: {\n                exchanges_scanned: exchangesToScan,\n                pairs_analyzed: assetPairs.length,\n                opportunities_found: crossAssetOpportunities.length,\n                top_opportunities: crossAssetOpportunities.slice(0, 5),\n                total_potential_profit: crossAssetOpportunities.reduce((sum, opp) => sum + opp.profit_usd, 0),\n                complexity: 'MEDIUM',\n                min_profit_threshold: minProfit,\n                exchange_health: this.circuitBreaker.getHealthReport()\n            }\n        };\n    }\n\n    async monitorArbitrageSpreads(exchangeList, minProfit) {\n        console.log('📊 Monitoring enhanced arbitrage spreads...');\n        \n        const exchangesToScan = this.parseExchangeList(exchangeList);\n        const assets = await this.getDynamicTopAssets();\n        const spreadData = {};\n        \n        for (const asset of assets) {\n            try {\n                const prices = [];\n                \n                for (const exchange of exchangesToScan) {\n                    try {\n                        const priceData = await this.priceFetcher.fetchPriceWithFallback(asset, exchange);\n                        if (priceData) {\n                            prices.push({\n                                exchange: exchange,\n                                bid: priceData.bid,\n                                ask: priceData.ask,\n                                spread: priceData.ask - priceData.bid,\n                                health: this.circuitBreaker.breakers.get(`${exchange}_price`)?.state || 'CLOSED'\n                            });\n                        }\n                    } catch (error) {\n                        console.error(`Failed to fetch ${asset} price from ${exchange}: ${error.message}`);\n                    }\n                }\n                \n                if (prices.length >= 2) {\n                    const minAsk = Math.min(...prices.map(p => p.ask));\n                    const maxBid = Math.max(...prices.map(p => p.bid));\n                    const potentialProfit = maxBid - minAsk;\n                    const profitBps = (potentialProfit / minAsk) * 10000;\n                    \n                    spreadData[asset] = {\n                        prices: prices,\n                        min_ask: minAsk,\n                        max_bid: maxBid,\n                        potential_profit: potentialProfit,\n                        profit_bps: Math.round(profitBps),\n                        profitable: profitBps >= minProfit,\n                        best_buy_exchange: prices.find(p => p.ask === minAsk)?.exchange,\n                        best_sell_exchange: prices.find(p => p.bid === maxBid)?.exchange,\n                        liquidity_score: this.calculateLiquidityScore(prices),\n                        risk_score: this.calculateRiskScore(prices),\n                        execution_window: this.estimateExecutionWindow(profitBps)\n                    };\n                }\n            } catch (error) {\n                console.error(`Error monitoring spreads for ${asset}:`, error.message);\n            }\n        }\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            spread_monitoring: {\n                assets_monitored: assets,\n                exchanges_monitored: exchangesToScan,\n                spread_data: spreadData,\n                profitable_opportunities: Object.values(spreadData).filter(data => data.profitable).length,\n                exchange_health: this.circuitBreaker.getHealthReport(),\n                monitoring_quality: this.calculateMonitoringQuality(spreadData)\n            }\n        };\n    }\n\n    async calculateArbitrageProfit(exchangeList, maxCapital, filter) {\n        console.log('💰 Calculating enhanced arbitrage profits...');\n        \n        const scanResult = await this.scanArbitrageOpportunities(exchangeList, 25, 100000, filter);\n        \n        if (!scanResult.success) {\n            throw new Error('Failed to scan arbitrage opportunities for profit calculation');\n        }\n        \n        const opportunities = scanResult.arbitrage_scan.top_opportunities;\n        const totalPotentialProfit = opportunities.reduce((sum, opp) => sum + opp.profit_usd, 0);\n        const averageProfit = opportunities.length > 0 ? totalPotentialProfit / opportunities.length : 0;\n        \n        const highConfidenceOpps = opportunities.filter(opp => opp.confidence >= 80);\n        const riskAdjustedProfit = highConfidenceOpps.reduce((sum, opp) => sum + opp.profit_usd, 0);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            profit_analysis: {\n                total_opportunities: opportunities.length,\n                high_confidence_opportunities: highConfidenceOpps.length,\n                total_potential_profit: totalPotentialProfit.toFixed(2),\n                risk_adjusted_profit: riskAdjustedProfit.toFixed(2),\n                average_profit_per_trade: averageProfit.toFixed(2),\n                max_single_profit: opportunities.length > 0 ? Math.max(...opportunities.map(opp => opp.profit_usd)).toFixed(2) : '0.00',\n                profit_distribution: this.calculateProfitDistribution(opportunities),\n                confidence_analysis: this.calculateConfidenceAnalysis(opportunities),\n                exchange_health: this.circuitBreaker.getHealthReport()\n            }\n        };\n    }\n\n    // ===== HELPER FUNCTIONS =====\n    \n    parseExchangeList(exchangeList) {\n        if (exchangeList === 'all') {\n            return ['binance', 'kraken', 'kucoin'];\n        } else if (exchangeList === 'major') {\n            return ['binance', 'kraken', 'kucoin'];\n        } else if (exchangeList === 'custom') {\n            return ['binance', 'kraken'];\n        } else if (typeof exchangeList === 'string') {\n            return exchangeList.split(',').map(e => e.trim().toLowerCase());\n        } else {\n            return exchangeList;\n        }\n    }\n\n    async getAssetsToScan(filter) {\n        // Dynamically get assets based on filter\n        if (filter === 'all' || filter === 'ALL_DISCOVERED_ASSETS') {\n            try {\n                const discovery = await this.exchangeManager.discoverExchangeAssets();\n                if (discovery.consolidatedAssets && discovery.consolidatedAssets.length > 0) {\n                    // Return all discovered assets, no limit\n                    return discovery.consolidatedAssets;\n                }\n            } catch (error) {\n                console.error('Asset discovery failed:', error.message);\n            }\n        }\n        \n        // Fallback to discovered assets from specific exchanges\n        try {\n            const assets = await this.exchangeManager.fetchBinanceAssets();\n            if (assets && assets.length > 0) {\n                return filter === 'major' ? assets.slice(0, 20) : \n                       filter === 'liquid' ? assets.slice(0, 10) : \n                       assets.slice(0, 50);\n            }\n        } catch (error) {\n            console.error('Failed to fetch assets:', error.message);\n        }\n        \n        // Last resort fallback - minimal set\n        return ['BTC', 'ETH', 'SOL', 'ADA', 'DOT'];\n    }\n\n    async getDynamicTopAssets() {\n        try {\n            const discovery = await this.exchangeManager.discoverExchangeAssets();\n            if (discovery.consolidatedAssets && discovery.consolidatedAssets.length > 0) {\n                return discovery.consolidatedAssets.slice(0, 20);\n            }\n        } catch (error) {\n            console.error('Failed to get dynamic top assets:', error.message);\n        }\n        \n        return ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'MATIC', 'LINK', 'AVAX'];\n    }\n\n    async getDynamicAssetPairs() {\n        try {\n            const assets = await this.getDynamicTopAssets();\n            const pairs = [];\n            \n            // Create pairs from top assets\n            for (let i = 0; i < Math.min(assets.length, 10); i++) {\n                for (let j = i + 1; j < Math.min(assets.length, 10); j++) {\n                    pairs.push([assets[i], assets[j]]);\n                }\n            }\n            \n            return pairs.slice(0, 10); // Limit to 10 pairs\n        } catch (error) {\n            console.error('Failed to get dynamic asset pairs:', error.message);\n        }\n        \n        // Fallback pairs\n        return [\n            ['BTC', 'ETH'], ['ETH', 'SOL'], ['BTC', 'SOL'],\n            ['MATIC', 'ADA'], ['LINK', 'DOT']\n        ];\n    }\n\n    async getTriangularPaths() {\n        try {\n            const assets = await this.getDynamicTopAssets();\n            const paths = [];\n            \n            // Create triangular paths from top assets\n            if (assets.length >= 3) {\n                for (let i = 0; i < Math.min(assets.length, 5); i++) {\n                    for (let j = i + 1; j < Math.min(assets.length, 5); j++) {\n                        for (let k = j + 1; k < Math.min(assets.length, 5); k++) {\n                            paths.push({\n                                path: `${assets[i]}->${assets[j]}->${assets[k]}->${assets[i]}`,\n                                assets: [assets[i], assets[j], assets[k]]\n                            });\n                        }\n                    }\n                }\n            }\n            \n            return paths.slice(0, 5); // Limit to 5 paths\n        } catch (error) {\n            console.error('Failed to get triangular paths:', error.message);\n        }\n        \n        // Fallback paths\n        return [\n            { path: 'BTC->ETH->SOL->BTC', assets: ['BTC', 'ETH', 'SOL'] },\n            { path: 'ETH->ADA->DOT->ETH', assets: ['ETH', 'ADA', 'DOT'] }\n        ];\n    }\n\n    getExchangeFee(exchange) {\n        const fees = {\n            binance: 0.001,\n            kraken: 0.0026,\n            kucoin: 0.001,\n            coinbase: 0.005\n        };\n        return fees[exchange] || 0.002;\n    }\n\n    calculateConfidence(exchangePrices, errorCount) {\n        const exchangeCount = Object.keys(exchangePrices).length;\n        const baseConfidence = Math.min(exchangeCount * 25, 100);\n        const errorPenalty = errorCount * 10;\n        return Math.max(baseConfidence - errorPenalty, 10);\n    }\n\n    estimateExecutionTime(buyExchange, sellExchange) {\n        const exchangeTimes = {\n            binance: 30,\n            kraken: 60,\n            kucoin: 45,\n            coinbase: 90\n        };\n        \n        const buyTime = exchangeTimes[buyExchange] || 60;\n        const sellTime = exchangeTimes[sellExchange] || 60;\n        \n        return Math.max(buyTime, sellTime);\n    }\n\n    estimateMarketImpact(quantity, buyPrice, sellPrice) {\n        const avgPrice = (buyPrice.last + sellPrice.last) / 2;\n        const notionalValue = quantity * avgPrice;\n        \n        if (notionalValue > 100000) return 'HIGH';\n        if (notionalValue > 10000) return 'MEDIUM';\n        return 'LOW';\n    }\n\n    calculateLiquidityScore(prices) {\n        const avgSpread = prices.reduce((sum, p) => sum + p.spread, 0) / prices.length;\n        const avgPrice = prices.reduce((sum, p) => sum + (p.bid + p.ask) / 2, 0) / prices.length;\n        const spreadPercentage = (avgSpread / avgPrice) * 100;\n        return Math.max(100 - spreadPercentage * 10, 0);\n    }\n\n    calculateRiskScore(prices) {\n        const avgPrice = prices.reduce((sum, p) => sum + (p.bid + p.ask) / 2, 0) / prices.length;\n        const variance = prices.reduce((sum, p) => {\n            const price = (p.bid + p.ask) / 2;\n            return sum + Math.pow(price - avgPrice, 2);\n        }, 0) / prices.length;\n        const standardDev = Math.sqrt(variance);\n        return Math.min((standardDev / avgPrice) * 1000, 100);\n    }\n\n    estimateExecutionWindow(profitBps) {\n        if (profitBps > 100) return 30;\n        if (profitBps > 50) return 60;\n        return 120;\n    }\n\n    calculateMonitoringQuality(spreadData) {\n        const assets = Object.keys(spreadData);\n        const avgExchanges = assets.reduce((sum, asset) => \n            sum + spreadData[asset].prices.length, 0) / assets.length;\n        return Math.round((avgExchanges / 4) * 100);\n    }\n\n    calculateProfitDistribution(opportunities) {\n        const ranges = { low: 0, medium: 0, high: 0, premium: 0 };\n        opportunities.forEach(opp => {\n            if (opp.profit_bps < 100) ranges.low++;\n            else if (opp.profit_bps < 200) ranges.medium++;\n            else if (opp.profit_bps < 500) ranges.high++;\n            else ranges.premium++;\n        });\n        return ranges;\n    }\n\n    calculateConfidenceAnalysis(opportunities) {\n        const confidence = { low: 0, medium: 0, high: 0, premium: 0 };\n        opportunities.forEach(opp => {\n            if (opp.confidence < 50) confidence.low++;\n            else if (opp.confidence < 70) confidence.medium++;\n            else if (opp.confidence < 90) confidence.high++;\n            else confidence.premium++;\n        });\n        return confidence;\n    }\n\n    async calculateTriangularArbitrageProfit(exchange, path, minProfit, maxCapital) {\n        try {\n            const prices = {};\n            for (const asset of path.assets) {\n                prices[asset] = await this.priceFetcher.fetchPriceWithFallback(asset, exchange);\n                if (!prices[asset]) {\n                    return null;\n                }\n            }\n            \n            const startAsset = path.assets[0];\n            const startAmount = 1000;\n            let currentAmount = startAmount;\n            let totalFees = 0;\n            \n            for (let i = 0; i < path.assets.length; i++) {\n                const fromAsset = path.assets[i];\n                const toAsset = path.assets[(i + 1) % path.assets.length];\n                \n                if (fromAsset === toAsset) continue;\n                \n                const rate = this.calculateExchangeRate(prices[fromAsset], prices[toAsset]);\n                const fee = this.getExchangeFee(exchange);\n                \n                currentAmount = currentAmount * rate * (1 - fee);\n                totalFees += currentAmount * fee;\n            }\n            \n            const profit = currentAmount - startAmount;\n            const profitBps = (profit / startAmount) * 10000;\n            \n            if (profitBps >= minProfit) {\n                return {\n                    path: path.path,\n                    exchange: exchange,\n                    profit_bps: Math.round(profitBps),\n                    profit_usd: profit,\n                    complexity: 'HIGH',\n                    execution_steps: path.assets.length\n                };\n            }\n            \n            return null;\n        } catch (error) {\n            console.error(`Triangular arbitrage calculation failed:`, error.message);\n            return null;\n        }\n    }\n\n    async calculateCrossAssetRatio(exchange, assetA, assetB, minProfit, maxCapital) {\n        try {\n            const priceA = await this.priceFetcher.fetchPriceWithFallback(assetA, exchange);\n            const priceB = await this.priceFetcher.fetchPriceWithFallback(assetB, exchange);\n            \n            if (!priceA || !priceB) return null;\n            \n            const ratio = priceA.last / priceB.last;\n            const historicalRatio = await this.getHistoricalRatio(assetA, assetB);\n            \n            const ratioDeviation = Math.abs(ratio - historicalRatio) / historicalRatio;\n            const profitBps = ratioDeviation * 10000;\n            \n            if (profitBps >= minProfit) {\n                return {\n                    pair: `${assetA}/${assetB}`,\n                    exchange: exchange,\n                    current_ratio: ratio,\n                    historical_ratio: historicalRatio,\n                    deviation: ratioDeviation,\n                    profit_bps: Math.round(profitBps),\n                    profit_usd: (ratioDeviation * maxCapital * 0.5),\n                    suggested_action: ratio > historicalRatio ? `SELL ${assetA}, BUY ${assetB}` : `BUY ${assetA}, SELL ${assetB}`\n                };\n            }\n            \n            return null;\n        } catch (error) {\n            console.error(`Cross-asset ratio calculation failed:`, error.message);\n            return null;\n        }\n    }\n\n    calculateExchangeRate(fromPrice, toPrice) {\n        return fromPrice.last / toPrice.last;\n    }\n\n    async getHistoricalRatio(assetA, assetB) {\n        // Calculate real historical ratio from data\n        try {\n            const [historicalA, historicalB] = await Promise.all([\n                this.exchangeManager.getHistoricalData(assetA, '1d', 'binance'),\n                this.exchangeManager.getHistoricalData(assetB, '1d', 'binance')\n            ]);\n            \n            if (historicalA && historicalB && historicalA.length > 0 && historicalB.length > 0) {\n                const avgA = historicalA.reduce((sum, d) => sum + d.close, 0) / historicalA.length;\n                const avgB = historicalB.reduce((sum, d) => sum + d.close, 0) / historicalB.length;\n                return avgA / avgB;\n            }\n        } catch (error) {\n            console.error('Failed to get historical ratio:', error.message);\n        }\n        \n        // Fallback to current ratio\n        return 1.0;\n    }\n}\n// ===== PART 8: MAIN SERVICE FUNCTION & COMPREHENSIVE ANALYSIS =====\n\n// ===== MAIN SERVICE FUNCTION =====\nasync function marketAnalysisService(functionType, ...params) {\n    console.log(`🔍 Market Analysis Service called with function: ${functionType}`);\n    \n    try {\n        // Validate functionType parameter\n        if (!functionType || typeof functionType !== 'string') {\n            console.error('❌ Invalid functionType parameter:', functionType);\n            return {\n                success: false,\n                error: 'functionType parameter is required and must be a string',\n                received_type: typeof functionType,\n                received_value: functionType,\n                available_functions: [\n                    'discover_exchange_assets', 'get_real_time_prices', 'perform_technical_analysis',\n                    'cross_exchange_arbitrage_scanner', 'market_inefficiency_scanner', 'institutional_flow_tracker', 'alpha_generation_coordinator',\n                    'scan_arbitrage', 'triangular_arbitrage', 'cross_asset_arbitrage', 'monitor_arbitrage_spreads', 'calculate_arbitrage_profit',\n                    'comprehensive_market_scan', 'unified_opportunity_analysis', 'market_health_assessment', 'real_time_monitoring',\n                    'complete_market_assessment', 'realtime_price_tracking', 'marketanalysisservice'\n                ],\n                timestamp: new Date().toISOString()\n            };\n        }\n        \n        // Initialize all components with REAL DATA integration\n        const exchangeManager = new DynamicExchangeManager();\n        const alphaGenerator = new EnhancedAlphaGenerator(exchangeManager);\n        const arbitrageEngine = new EnterpriseArbitrageEngine(exchangeManager);\n        \n        switch (functionType.toLowerCase()) {\n            // ===== MARKET INTELLIGENCE FUNCTIONS =====\n            case 'discover_exchange_assets':\n                return await exchangeManager.discoverExchangeAssets();\n                \n            case 'get_real_time_prices':\n            case 'realtime_price_tracking':\n                console.log('📊 Getting real-time prices...');\n                const [symbols_prices, exchanges_prices] = params;\n                return await exchangeManager.getRealTimePrices(symbols_prices, exchanges_prices);\n                \n            case 'perform_technical_analysis':\n                const [symbols_ta, timeframe, exchanges_ta] = params;\n                return await exchangeManager.performTechnicalAnalysis(symbols_ta, timeframe, exchanges_ta);\n            // Add aliases for commonly called variations\n            case 'technical_analysis':\n                return await marketAnalysisService('perform_technical_analysis', ...params);\n            \n            case 'market_sentiment':\n                // This function doesn't exist - return honest response\n                return { \n                    success: true, \n                    message: 'Market sentiment analysis not yet implemented',\n                    suggestion: 'Use institutional_flow_tracker for sentiment insights'\n                };\n            \n            case 'volatility_analysis':\n                // Use technical analysis with volatility focus\n                const [vol_symbols, vol_timeframe = '1h', vol_exchanges] = params;\n                const technicalResult = await exchangeManager.performTechnicalAnalysis(vol_symbols, vol_timeframe, vol_exchanges);\n                // Extract volatility metrics from technical analysis\n                return {\n                    success: true,\n                    volatility_analysis: technicalResult,\n                    note: 'Volatility extracted from technical indicators (ATR, Bollinger Bands)'\n                };\n            \n            case 'support_resistance_detection':\n                // Use technical analysis for support/resistance\n                const [sr_symbols, sr_timeframe = '4h', sr_exchanges] = params;\n                const srResult = await exchangeManager.performTechnicalAnalysis(sr_symbols, sr_timeframe, sr_exchanges);\n                return {\n                    success: true,\n                    support_resistance: srResult,\n                    note: 'Support/resistance derived from Bollinger Bands and price levels'\n                };\n            \n            case 'trend_analysis':\n                // Use technical analysis for trends\n                const [trend_symbols, trend_timeframe = '1d', trend_exchanges] = params;\n                const trendResult = await exchangeManager.performTechnicalAnalysis(trend_symbols, trend_timeframe, trend_exchanges);\n                return {\n                    success: true,\n                    trend_analysis: trendResult,\n                    note: 'Trends derived from EMA, MACD, and price action'\n                };\n            \n            case 'volume_analysis':\n                // Extract volume from real-time prices\n                const [vol_analysis_symbols, vol_analysis_exchanges] = params;\n                const priceData = await exchangeManager.getRealTimePrices(vol_analysis_symbols, vol_analysis_exchanges);\n                const volumeMetrics = {};\n                Object.keys(priceData).forEach(exchange => {\n                    Object.keys(priceData[exchange]).forEach(symbol => {\n                        if (!volumeMetrics[symbol]) volumeMetrics[symbol] = {};\n                        volumeMetrics[symbol][exchange] = priceData[exchange][symbol].volume24h || 0;\n                    });\n                });\n                return {\n                    success: true,\n                    volume_analysis: volumeMetrics,\n                    timestamp: new Date().toISOString()\n                };\n            \n            case 'momentum_indicators':\n                // Use technical analysis for momentum\n                const [mom_symbols, mom_timeframe = '1h', mom_exchanges] = params;\n                const momResult = await exchangeManager.performTechnicalAnalysis(mom_symbols, mom_timeframe, mom_exchanges);\n                return {\n                    success: true,\n                    momentum_indicators: momResult,\n                    note: 'Momentum from RSI, MACD, Stochastic indicators'\n                };\n            \n            case 'cross_exchange_price_comparison':\n                // Use real-time prices for comparison\n                const [comp_symbols, comp_exchanges] = params;\n                return await exchangeManager.getRealTimePrices(comp_symbols, comp_exchanges);\n            \n            case 'monitor_spreads':\n                // Use arbitrage spread monitoring\n                const [spread_exchanges, spread_minProfit] = params;\n                return await arbitrageEngine.monitorArbitrageSpreads(spread_exchanges, spread_minProfit || 25);\n            \n            case 'calculate_profit':\n                // Use arbitrage profit calculation\n                const [profit_exchanges, profit_capital, profit_filter] = params;\n                return await arbitrageEngine.calculateArbitrageProfit(profit_exchanges, profit_capital || 100000, profit_filter);\n                \n            case 'get_historical_data':\n                const [symbol_hist, timeframe_hist, exchange_hist] = params;\n                return await exchangeManager.getHistoricalData(symbol_hist, timeframe_hist, exchange_hist);\n            \n            // ===== ALPHA GENERATION FUNCTIONS =====\n            case 'cross_exchange_arbitrage_scanner':\n                const [symbols_arb, exchanges_arb, minProfitBps_arb] = params;\n                return await alphaGenerator.crossExchangeArbitrageScanner(symbols_arb, exchanges_arb, minProfitBps_arb);\n                \n            case 'market_inefficiency_scanner':\n                const [symbols_ineff, confidenceLevel_ineff] = params;\n                return await alphaGenerator.marketInefficiencyScanner(symbols_ineff, confidenceLevel_ineff);\n                \n            case 'institutional_flow_tracker':\n                const [symbols_inst] = params;\n                return await alphaGenerator.institutionalFlowTracker(symbols_inst);\n                \n            case 'alpha_generation_coordinator':\n                const [symbols_alpha, exchanges_alpha, minProfitBps_alpha, confidenceLevel_alpha] = params;\n                return await alphaGenerator.alphaGenerationCoordinator(symbols_alpha, exchanges_alpha, minProfitBps_alpha, confidenceLevel_alpha);\n            \n            // ===== MULTI EXCHANGE ARBITRAGE FUNCTIONS =====\n            case 'scan_arbitrage':\n                const [exchangeList_scan, minProfit_scan, maxCapital_scan, filter_scan] = params;\n                return await arbitrageEngine.scanArbitrageOpportunities(\n                exchangeList_scan || 'all', \n                minProfit_scan || 25, \n                maxCapital_scan || 100000,  // Default to 100k if not provided\n                filter_scan || 'all'\n                );\n                \n            case 'triangular_arbitrage':\n                const [exchangeList_tri, minProfit_tri, maxCapital_tri] = params;\n                return await arbitrageEngine.scanTriangularArbitrage(exchangeList_tri, minProfit_tri, maxCapital_tri);\n                \n            case 'cross_asset_arbitrage':\n                const [exchangeList_cross, minProfit_cross, maxCapital_cross] = params;\n                return await arbitrageEngine.scanCrossAssetArbitrage(exchangeList_cross, minProfit_cross, maxCapital_cross);\n                \n            case 'monitor_arbitrage_spreads':\n                const [exchangeList_monitor, minProfit_monitor] = params;\n                return await arbitrageEngine.monitorArbitrageSpreads(exchangeList_monitor, minProfit_monitor);\n                \n            case 'calculate_arbitrage_profit':\n                const [exchangeList_calc, maxCapital_calc, filter_calc] = params;\n                return await arbitrageEngine.calculateArbitrageProfit(exchangeList_calc, maxCapital_calc, filter_calc);\n            \n            // ===== COMPREHENSIVE ANALYSIS FUNCTIONS =====\n            case 'comprehensive_market_scan':\n            case 'complete_market_assessment':\n            case 'marketanalysisservice':\n                console.log('🔍 Performing comprehensive market scan...');\n                \n                // Handle Flowise parameters\n                if (functionType.toLowerCase() === 'complete_market_assessment' || \n                    functionType.toLowerCase() === 'marketanalysisservice') {\n                    \n                    // Check for Flowise $ parameters\n                    let symbols_scan, exchanges_scan, minProfit_scan;\n                    \n                    if (typeof $symbols !== 'undefined') {\n                        symbols_scan = $symbols;\n                        exchanges_scan = (typeof $exchanges !== 'undefined') ? $exchanges : 'all';\n                        minProfit_scan = (typeof $min_profit_bps !== 'undefined') ? $min_profit_bps : 5;\n                        \n                        console.log('✅ Using Flowise parameters:', { symbols_scan, exchanges_scan, minProfit_scan });\n                        return await comprehensiveMarketScan([symbols_scan, exchanges_scan, minProfit_scan]);\n                    }\n                }\n                \n                return await comprehensiveMarketScan(params);\n                \n            case 'unified_opportunity_analysis':\n                return await unifiedOpportunityAnalysis(params);\n                \n            case 'market_health_assessment':\n                return await marketHealthAssessment(params);\n                \n            case 'real_time_monitoring':\n                return await realTimeMonitoring(params);\n\n            default:\n                console.warn(`Unknown function type: ${functionType}`);\n                return {\n                    success: false,\n                    error: `Unknown function type: ${functionType}`,\n                    available_functions: [\n                        'discover_exchange_assets', 'get_real_time_prices', 'perform_technical_analysis',\n                        'cross_exchange_arbitrage_scanner', 'market_inefficiency_scanner', 'institutional_flow_tracker', 'alpha_generation_coordinator',\n                        'scan_arbitrage', 'triangular_arbitrage', 'cross_asset_arbitrage', 'monitor_arbitrage_spreads', 'calculate_arbitrage_profit',\n                        'comprehensive_market_scan', 'unified_opportunity_analysis', 'market_health_assessment', 'real_time_monitoring',\n                        'complete_market_assessment', 'realtime_price_tracking', 'marketanalysisservice'\n                    ],\n                    timestamp: new Date().toISOString()\n                };\n        }\n        \n    } catch (error) {\n        console.error(`Market Analysis Service Error (${functionType}):`, error);\n        return {\n            success: false,\n            error: error.message,\n            function_type: functionType,\n            timestamp: new Date().toISOString(),\n            stack_trace: error.stack\n        };\n    }\n\n}\n\n// ===== COMPREHENSIVE ANALYSIS FUNCTIONS =====\n\nasync function comprehensiveMarketScan(params) {\n    console.log('🔍 Performing comprehensive market scan...');\n    \n    const [symbols = 'ALL_DISCOVERED_ASSETS', exchanges = 'all', minProfit = 25] = params;\n    \n    try {\n        const exchangeManager = new DynamicExchangeManager();\n        const alphaGenerator = new EnhancedAlphaGenerator(exchangeManager);\n        const arbitrageEngine = new EnterpriseArbitrageEngine(exchangeManager);\n        \n        console.log('Starting parallel market analysis...');\n        \n        // Handle ALL_DISCOVERED_ASSETS\n        let actualSymbols = symbols;\n        let discoveredAssets = null;\n        \n        if (symbols === 'ALL_DISCOVERED_ASSETS' || symbols === 'all' || symbols === 'ALL') {\n            console.log('🔍 Discovering assets across all exchanges...');\n            discoveredAssets = await exchangeManager.discoverExchangeAssets();\n            \n            if (discoveredAssets && discoveredAssets.consolidatedAssets) {\n                // Use ALL discovered assets, no limit\n                actualSymbols = discoveredAssets.consolidatedAssets.join(',');\n                console.log(`📊 Using ${discoveredAssets.consolidatedAssets.length} discovered assets for analysis`);\n            } else {\n                console.log('⚠️ Asset discovery incomplete, discovering from Binance...');\n                const binanceAssets = await exchangeManager.fetchBinanceAssets();\n                actualSymbols = binanceAssets.join(',');\n            }\n        }\n        // ===== ADD THIS NEW TIER HANDLING RIGHT HERE ===== \n        else if (symbols === 'TIER1_ASSETS') {\n            console.log('🎯 Using Tier-1 assets only (top 30)...');\n            discoveredAssets = await exchangeManager.discoverExchangeAssets();\n            if (discoveredAssets && discoveredAssets.tier1) {\n                actualSymbols = discoveredAssets.tier1.join(',');\n                console.log(`📊 Using ${discoveredAssets.tier1.length} Tier-1 assets`);\n            }\n        }\n        else if (symbols === 'TIER2_ASSETS') {\n            console.log('🎯 Using Tier-2 assets (31-100)...');\n            discoveredAssets = await exchangeManager.discoverExchangeAssets();\n            if (discoveredAssets && discoveredAssets.tier2) {\n                actualSymbols = discoveredAssets.tier2.join(',');\n                console.log(`📊 Using ${discoveredAssets.tier2.length} Tier-2 assets`);\n            }\n        }\n        else if (symbols === 'TIER3_ASSETS') {\n            console.log('🎯 Using Tier-3 assets (101+)...');\n            discoveredAssets = await exchangeManager.discoverExchangeAssets();\n            if (discoveredAssets && discoveredAssets.tier3) {\n                actualSymbols = discoveredAssets.tier3.join(',');\n                console.log(`📊 Using ${discoveredAssets.tier3.length} Tier-3 assets`);\n            }\n        }\n        // ===== ADD THIS AFTER TIER3_ASSETS HANDLING =====\nelse if (symbols === 'SMART_ADAPTIVE') {\n    console.log('🎯 Using Smart Adaptive selection (optimal profit/performance)...');\n    discoveredAssets = await exchangeManager.discoverExchangeAssets();\n    if (discoveredAssets) {\n        // Take best from each tier for optimal coverage\n        const smartSelection = [\n            ...(discoveredAssets.tier1 || []),                    // All 30 tier1 (highest volume/opportunity)\n            ...(discoveredAssets.tier2 || []).slice(0, 10),      // Top 10 tier2 (emerging opportunities)\n            ...(discoveredAssets.tier3 || []).slice(0, 5)        // Top 5 tier3 (high-risk/high-reward)\n        ];\n        actualSymbols = smartSelection.join(',');\n        console.log(`📊 Smart Adaptive: Using ${smartSelection.length} optimized assets`);\n    }\n}\nelse if (symbols === 'PROGRESSIVE_SCAN') {\n    console.log('🔄 Using Progressive Scan (time-based rotation)...');\n    const currentMinute = new Date().getMinutes();\n    discoveredAssets = await exchangeManager.discoverExchangeAssets();\n    \n    if (currentMinute % 3 === 0) {\n        // Focus on Tier 1 for arbitrage\n        actualSymbols = discoveredAssets.tier1.join(',');\n        console.log(`📊 Progressive: Tier-1 focus (${discoveredAssets.tier1.length} assets)`);\n    } else if (currentMinute % 3 === 1) {\n        // Tier 2 for momentum plays\n        actualSymbols = discoveredAssets.tier2.join(',');\n        console.log(`📊 Progressive: Tier-2 focus (${discoveredAssets.tier2.length} assets)`);\n    } else {\n        // Tier 3 for high-risk opportunities\n        actualSymbols = discoveredAssets.tier3.join(',');\n        console.log(`📊 Progressive: Tier-3 focus (${discoveredAssets.tier3.length} assets)`);\n    }\n}\n        \n        let actualExchanges = exchanges === 'all' ? 'binance,kraken,kucoin' : exchanges;\n        \n        const alphaOpportunities = await alphaGenerator.alphaGenerationCoordinator(actualSymbols, actualExchanges, minProfit, 'medium');\n        const arbitrageOpportunities = await arbitrageEngine.scanArbitrageOpportunities(actualExchanges, minProfit, 100000, 'all');\n        \n        const unifiedOpportunities = [];\n        \n        if (alphaOpportunities.success && alphaOpportunities.alpha_coordination.opportunities) {\n            alphaOpportunities.alpha_coordination.opportunities.forEach(opp => {\n                unifiedOpportunities.push({\n                    ...opp,\n                    source: 'ALPHA_GENERATION',\n                    unified_score: calculateUnifiedScore(opp, 'alpha')\n                });\n            });\n        }\n        \n        if (arbitrageOpportunities.success && arbitrageOpportunities.arbitrage_scan.top_opportunities) {\n            arbitrageOpportunities.arbitrage_scan.top_opportunities.forEach(opp => {\n                unifiedOpportunities.push({\n                    ...opp,\n                    source: 'ARBITRAGE_SCAN',\n                    unified_score: calculateUnifiedScore(opp, 'arbitrage')\n                });\n            });\n        }\n        \n        unifiedOpportunities.sort((a, b) => b.unified_score - a.unified_score);\n        \n        const portfolioAllocation = generatePortfolioAllocation(unifiedOpportunities, 100000);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            unified_analysis: {\n                total_opportunities: unifiedOpportunities.length,\n                opportunities: unifiedOpportunities.slice(0, 15),\n                portfolio_allocation: portfolioAllocation,\n                risk_metrics: calculateRiskMetrics(unifiedOpportunities),\n                diversification_score: calculateDiversificationScore(unifiedOpportunities),\n                expected_portfolio_return: portfolioAllocation.total_expected_return,\n                recommended_actions: generateUnifiedRecommendations(unifiedOpportunities, portfolioAllocation),\n                discovery_mode: 'REAL_TIME_DYNAMIC'\n            }\n        };\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\nasync function marketHealthAssessment(params) {\n    console.log('🏥 Performing market health assessment...');\n    \n    let [symbols = null, exchanges = 'binance,kraken,kucoin'] = params;\n    \n    // Dynamic symbol discovery if not provided\n    if (!symbols) {\n        const exchangeManager = new DynamicExchangeManager();\n        const discovery = await exchangeManager.discoverExchangeAssets();\n        if (discovery && discovery.consolidatedAssets) {\n            symbols = discovery.consolidatedAssets.slice(0, 20).join(',');\n        } else {\n            symbols = 'BTC,ETH,SOL,ADA,DOT';\n        }\n    }\n    \n    try {\n        const exchangeManager = new DynamicExchangeManager();\n        const alphaGenerator = new EnhancedAlphaGenerator(exchangeManager);\n        \n        const [realTimePrices, technicalAnalysis, inefficiencies] = await Promise.all([\n            exchangeManager.getRealTimePrices(symbols.split(','), exchanges.split(',')),\n            exchangeManager.performTechnicalAnalysis(symbols.split(','), '4h', exchanges.split(',')),\n            alphaGenerator.marketInefficiencyScanner(symbols, 'low')\n        ]);\n        \n        const healthMetrics = {\n            liquidity_health: calculateLiquidityHealth(realTimePrices),\n            volatility_health: calculateVolatilityHealth(realTimePrices, technicalAnalysis),\n            efficiency_health: calculateEfficiencyHealth(inefficiencies),\n            technical_health: calculateTechnicalHealth(technicalAnalysis),\n            correlation_health: calculateCorrelationHealth(realTimePrices),\n            volume_health: calculateVolumeHealth(realTimePrices)\n        };\n        \n        const overallHealthScore = Object.values(healthMetrics).reduce((sum, metric) => sum + metric.score, 0) / Object.keys(healthMetrics).length;\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            market_health: {\n                overall_score: Math.round(overallHealthScore),\n                health_rating: getHealthRating(overallHealthScore),\n                detailed_metrics: healthMetrics,\n                market_conditions: assessMarketConditions(healthMetrics),\n                trading_recommendations: generateHealthBasedRecommendations(healthMetrics),\n                risk_warnings: generateRiskWarnings(healthMetrics),\n                opportunity_outlook: generateOpportunityOutlook(healthMetrics)\n            }\n        };\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\nasync function realTimeMonitoring(params) {\n    console.log('📡 Starting real-time market monitoring...');\n    \n    let [symbols = null, exchanges = 'binance,kraken', minProfit = 25, duration = 300] = params;\n    \n    // Dynamic symbol discovery if not provided\n    if (!symbols) {\n        const exchangeManager = new DynamicExchangeManager();\n        const discovery = await exchangeManager.discoverExchangeAssets();\n        if (discovery && discovery.consolidatedAssets) {\n            symbols = discovery.consolidatedAssets.slice(0, 10).join(',');\n        } else {\n            symbols = 'BTC,ETH,SOL';\n        }\n    }\n    \n    try {\n        const exchangeManager = new DynamicExchangeManager();\n        const arbitrageEngine = new EnterpriseArbitrageEngine(exchangeManager);\n        \n        const monitoringResults = [];\n        const startTime = Date.now();\n        const endTime = startTime + (duration * 1000);\n        \n        let iteration = 0;\n        while (Date.now() < endTime && iteration < 10) {\n            try {\n                iteration++;\n                console.log(`Monitoring iteration ${iteration}`);\n                \n                const snapshot = await arbitrageEngine.monitorArbitrageSpreads(exchanges, minProfit);\n                \n                if (snapshot.success) {\n                    monitoringResults.push({\n                        iteration: iteration,\n                        timestamp: new Date().toISOString(),\n                        spread_data: snapshot.spread_monitoring.spread_data,\n                        profitable_opportunities: snapshot.spread_monitoring.profitable_opportunities,\n                        exchange_health: snapshot.spread_monitoring.exchange_health\n                    });\n                }\n                \n                if (Date.now() < endTime) {\n                    await new Promise(resolve => setTimeout(resolve, 30000));\n                }\n                \n            } catch (iterationError) {\n                console.error(`Monitoring iteration ${iteration} failed:`, iterationError.message);\n                monitoringResults.push({\n                    iteration: iteration,\n                    timestamp: new Date().toISOString(),\n                    error: iterationError.message\n                });\n            }\n        }\n        \n        const analysis = analyzeMonitoringResults(monitoringResults);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            real_time_monitoring: {\n                monitoring_duration: Math.round((Date.now() - startTime) / 1000),\n                total_iterations: iteration,\n                successful_iterations: monitoringResults.filter(r => !r.error).length,\n                monitoring_results: monitoringResults,\n                analysis: analysis,\n                persistent_opportunities: analysis.persistent_opportunities,\n                trend_analysis: analysis.trend_analysis,\n                recommendations: analysis.recommendations\n            }\n        };\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\n// ===== ANALYSIS HELPER FUNCTIONS =====\n\nfunction calculateComprehensiveSummary(results) {\n    const summary = {\n        total_opportunities: 0,\n        total_potential_profit: 0,\n        high_confidence_opportunities: 0,\n        data_sources_healthy: 0,\n        market_efficiency_score: 0\n    };\n    \n    if (results.arbitrage_opportunities && results.arbitrage_opportunities.arbitrage_scan) {\n        summary.total_opportunities += results.arbitrage_opportunities.arbitrage_scan.opportunities_found || 0;\n        summary.total_potential_profit += results.arbitrage_opportunities.arbitrage_scan.total_potential_profit || 0;\n    }\n    \n    if (results.market_inefficiencies && results.market_inefficiencies.inefficiency_scan) {\n        summary.total_opportunities += results.market_inefficiencies.inefficiency_scan.total_inefficiencies || 0;\n    }\n    \n    if (results.institutional_flow && results.institutional_flow.institutional_flow) {\n        summary.total_opportunities += results.institutional_flow.institutional_flow.signals_detected || 0;\n    }\n    \n    return summary;\n}\n\nfunction generateActionableRecommendations(results) {\n    const recommendations = [];\n    \n    if (results.arbitrage_opportunities && results.arbitrage_opportunities.success) {\n        const opportunities = results.arbitrage_opportunities.arbitrage_scan.opportunities_found || 0;\n        if (opportunities > 5) {\n            recommendations.push({\n                type: 'ARBITRAGE',\n                action: 'EXECUTE_TOP_OPPORTUNITIES',\n                priority: 'HIGH',\n                reason: `${opportunities} arbitrage opportunities detected with high profit potential`\n            });\n        }\n    }\n    \n    if (results.technical_analysis) {\n        Object.keys(results.technical_analysis).forEach(symbol => {\n            const analysis = results.technical_analysis[symbol];\n            if (analysis.signals && analysis.signals.overall_signal !== 'HOLD') {\n                recommendations.push({\n                    type: 'TECHNICAL',\n                    action: analysis.signals.overall_signal,\n                    symbol: symbol,\n                    priority: analysis.signals.signal_strength > 3 ? 'HIGH' : 'MEDIUM',\n                    reason: `Technical signals suggest ${analysis.signals.overall_signal} for ${symbol}`\n                });\n            }\n        });\n    }\n    \n    if (results.institutional_flow && results.institutional_flow.success) {\n        const signals = results.institutional_flow.institutional_flow.institutional_signals || [];\n        signals.forEach(signal => {\n            if (signal.confidence === 'HIGH') {\n                recommendations.push({\n                    type: 'INSTITUTIONAL',\n                    action: signal.direction,\n                    symbol: signal.symbol,\n                    priority: 'HIGH',\n                    reason: `Strong institutional ${signal.primary_signal} detected`\n                });\n            }\n        });\n    }\n    \n    return recommendations.slice(0, 10);\n}\n\nfunction assessDataQuality(results) {\n    let totalSources = 0;\n    let healthySources = 0;\n    \n    Object.keys(results).forEach(key => {\n        totalSources++;\n        if (results[key] && !results[key].error) {\n            healthySources++;\n        }\n    });\n    \n    const healthPercentage = (healthySources / totalSources) * 100;\n    \n    return {\n        healthy_sources: healthySources,\n        total_sources: totalSources,\n        health_percentage: Math.round(healthPercentage),\n        quality_rating: healthPercentage > 80 ? 'EXCELLENT' : healthPercentage > 60 ? 'GOOD' : healthPercentage > 40 ? 'FAIR' : 'POOR'\n    };\n}\n\nfunction prioritizeOpportunities(results) {\n    const priorities = [];\n    \n    if (results.arbitrage_opportunities && results.arbitrage_opportunities.arbitrage_scan) {\n        const opps = results.arbitrage_opportunities.arbitrage_scan.top_opportunities || [];\n        opps.forEach(opp => {\n            priorities.push({\n                type: 'ARBITRAGE',\n                symbol: opp.asset,\n                profit_potential: opp.profit_usd,\n                confidence: opp.confidence,\n                priority_score: opp.profit_usd * (opp.confidence / 100)\n            });\n        });\n    }\n    \n    return priorities.sort((a, b) => b.priority_score - a.priority_score).slice(0, 5);\n}\n\nfunction calculateUnifiedScore(opportunity, type) {\n    let score = 50;\n    \n    if (type === 'alpha') {\n        score += opportunity.priority || 0;\n        score += (opportunity.confidence || 50) * 0.5;\n        if (opportunity.risk_level === 'LOW') score += 10;\n        if (opportunity.risk_level === 'HIGH') score -= 10;\n    } else if (type === 'arbitrage') {\n        score += (opportunity.profit_bps || 0) * 0.1;\n        score += (opportunity.confidence || 50) * 0.3;\n        score += (opportunity.profit_usd || 0) * 0.01;\n    }\n    \n    return Math.min(100, Math.max(0, score));\n}\n\nfunction generatePortfolioAllocation(opportunities, maxCapital) {\n    const allocation = {\n        allocations: [],\n        total_allocated: 0,\n        total_expected_return: 0,\n        diversification_level: 'MEDIUM'\n    };\n    \n    let remainingCapital = maxCapital;\n    \n    for (const opp of opportunities.slice(0, 5)) {\n        const allocationPercentage = Math.min(0.3, opp.unified_score / 100 * 0.4);\n        const allocatedAmount = Math.min(remainingCapital * allocationPercentage, opp.capital_requirement || 0);\n        \n        if (allocatedAmount > 1000) {\n            allocation.allocations.push({\n                opportunity: opp,\n                allocated_capital: allocatedAmount,\n                allocation_percentage: (allocatedAmount / maxCapital) * 100,\n                expected_return: opp.expected_return || 0,\n                risk_level: opp.risk_level || 'MEDIUM'\n            });\n            \n            allocation.total_allocated += allocatedAmount;\n            allocation.total_expected_return += opp.expected_return || 0;\n            remainingCapital -= allocatedAmount;\n        }\n    }\n    \n    return allocation;\n}\n\nfunction calculateRiskMetrics(opportunities) {\n    const riskLevels = { LOW: 0, MEDIUM: 0, HIGH: 0 };\n    \n    opportunities.forEach(opp => {\n        const risk = opp.risk_level || 'MEDIUM';\n        riskLevels[risk]++;\n    });\n    \n    return {\n        risk_distribution: riskLevels,\n        avg_risk_score: opportunities.length > 0 ? (riskLevels.LOW * 1 + riskLevels.MEDIUM * 2 + riskLevels.HIGH * 3) / opportunities.length : 0,\n        high_risk_percentage: opportunities.length > 0 ? (riskLevels.HIGH / opportunities.length) * 100 : 0\n    };\n}\n\nfunction calculateDiversificationScore(opportunities) {\n    const sources = new Set(opportunities.map(opp => opp.source));\n    const symbols = new Set(opportunities.map(opp => opp.symbol || opp.asset));\n    \n    const sourceScore = Math.min(sources.size * 25, 100);\n    const symbolScore = Math.min(symbols.size * 15, 100);\n    \n    return Math.round((sourceScore + symbolScore) / 2);\n}\n\nfunction generateUnifiedRecommendations(opportunities, allocation) {\n    const recommendations = [];\n    \n    if (allocation.total_allocated < allocation.total_allocated * 0.8) {\n        recommendations.push({\n            type: 'CAPITAL_ALLOCATION',\n            message: 'Consider increasing capital allocation to capture more opportunities',\n            priority: 'MEDIUM'\n        });\n    }\n    \n    const highRiskOpps = opportunities.filter(opp => opp.risk_level === 'HIGH').length;\n    if (highRiskOpps > opportunities.length * 0.3) {\n        recommendations.push({\n            type: 'RISK_MANAGEMENT',\n            message: 'High concentration of high-risk opportunities detected',\n            priority: 'HIGH'\n        });\n    }\n    \n    return recommendations;\n}\n\n// Health calculation functions\nfunction calculateLiquidityHealth(priceData) {\n    let totalVolume = 0;\n    let validPairs = 0;\n    \n    Object.keys(priceData).forEach(exchange => {\n        Object.keys(priceData[exchange]).forEach(symbol => {\n            const data = priceData[exchange][symbol];\n            if (data && !data.error && data.volume24h) {\n                totalVolume += data.volume24h;\n                validPairs++;\n            }\n        });\n    });\n    \n    const avgVolume = validPairs > 0 ? totalVolume / validPairs : 0;\n    const score = Math.min((avgVolume / 1000000) * 20, 100);\n    \n    return {\n        score: Math.round(score),\n        avg_volume: avgVolume,\n        status: score > 70 ? 'HEALTHY' : score > 40 ? 'MODERATE' : 'POOR'\n    };\n}\n\nfunction calculateVolatilityHealth(priceData, technicalData) {\n    let totalVolatility = 0;\n    let validPairs = 0;\n    \n    Object.keys(priceData).forEach(exchange => {\n        Object.keys(priceData[exchange]).forEach(symbol => {\n            const data = priceData[exchange][symbol];\n            if (data && !data.error && data.change24h !== undefined) {\n                totalVolatility += Math.abs(data.change24h);\n                validPairs++;\n            }\n        });\n    });\n    \n    const avgVolatility = validPairs > 0 ? totalVolatility / validPairs : 0;\n    \n    let score = 100;\n    if (avgVolatility > 15) score = 30;\n    else if (avgVolatility > 8) score = 60;\n    else if (avgVolatility < 0.5) score = 40;\n    \n    return {\n        score: Math.round(score),\n        avg_volatility: avgVolatility,\n        status: score > 70 ? 'OPTIMAL' : score > 40 ? 'SUBOPTIMAL' : 'POOR'\n    };\n}\n\nfunction calculateEfficiencyHealth(inefficiencies) {\n    if (!inefficiencies || !inefficiencies.success) {\n        return { score: 50, status: 'UNKNOWN' };\n    }\n    \n    const totalInefficiencies = inefficiencies.inefficiency_scan.total_inefficiencies || 0;\n    const score = Math.max(100 - (totalInefficiencies * 5), 0);\n    \n    return {\n        score: Math.round(score),\n        inefficiencies_detected: totalInefficiencies,\n        status: score > 80 ? 'EFFICIENT' : score > 60 ? 'MODERATE' : 'INEFFICIENT'\n    };\n}\n\nfunction calculateTechnicalHealth(technicalData) {\n    if (!technicalData) {\n        return { score: 50, status: 'UNKNOWN' };\n    }\n    \n    let bullishSignals = 0;\n    let bearishSignals = 0;\n    let totalSignals = 0;\n    \n    Object.keys(technicalData).forEach(symbol => {\n        const analysis = technicalData[symbol];\n        if (analysis.signals) {\n            totalSignals++;\n            if (analysis.signals.overall_signal === 'BUY') bullishSignals++;\n            else if (analysis.signals.overall_signal === 'SELL') bearishSignals++;\n        }\n    });\n    \n    const neutralSignals = totalSignals - bullishSignals - bearishSignals;\n    const balance = totalSignals > 0 ? Math.abs(bullishSignals - bearishSignals) / totalSignals : 0;\n    const score = Math.round((1 - balance) * 100);\n    \n    return {\n        score: score,\n        bullish_signals: bullishSignals,\n        bearish_signals: bearishSignals,\n        neutral_signals: neutralSignals,\n        status: score > 70 ? 'BALANCED' : 'IMBALANCED'\n    };\n}\n\nfunction calculateCorrelationHealth(priceData) {\n    const changes = [];\n    \n    Object.keys(priceData).forEach(exchange => {\n        Object.keys(priceData[exchange]).forEach(symbol => {\n            const data = priceData[exchange][symbol];\n            if (data && !data.error && data.change24h !== undefined) {\n                changes.push(data.change24h);\n            }\n        });\n    });\n    \n    if (changes.length < 2) {\n        return { score: 50, status: 'INSUFFICIENT_DATA' };\n    }\n    \n    const avgChange = changes.reduce((sum, change) => sum + change, 0) / changes.length;\n    const variance = changes.reduce((sum, change) => sum + Math.pow(change - avgChange, 2), 0) / changes.length;\n    \n    const score = Math.min(variance * 10, 100);\n    \n    return {\n        score: Math.round(score),\n        variance: variance,\n        status: score > 60 ? 'DIVERSIFIED' : score > 30 ? 'MODERATE' : 'HIGHLY_CORRELATED'\n    };\n}\n\nfunction calculateVolumeHealth(priceData) {\n    let exchangeVolumes = {};\n    \n    Object.keys(priceData).forEach(exchange => {\n        let exchangeTotal = 0;\n        let symbolCount = 0;\n        \n        Object.keys(priceData[exchange]).forEach(symbol => {\n            const data = priceData[exchange][symbol];\n            if (data && !data.error && data.volume24h) {\n                exchangeTotal += data.volume24h;\n                symbolCount++;\n            }\n        });\n        \n        if (symbolCount > 0) {\n            exchangeVolumes[exchange] = exchangeTotal / symbolCount;\n        }\n    });\n    \n    const volumes = Object.values(exchangeVolumes);\n    const avgVolume = volumes.length > 0 ? volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length : 0;\n    const score = Math.min((avgVolume / 5000000) * 100, 100);\n    \n    return {\n        score: Math.round(score),\n        avg_volume: avgVolume,\n        exchange_volumes: exchangeVolumes,\n        status: score > 70 ? 'HIGH' : score > 40 ? 'MODERATE' : 'LOW'\n    };\n}\n\nfunction getHealthRating(score) {\n    if (score >= 80) return 'EXCELLENT';\n    if (score >= 60) return 'GOOD';\n    if (score >= 40) return 'FAIR';\n    return 'POOR';\n}\n\nfunction assessMarketConditions(healthMetrics) {\n    const conditions = [];\n    \n    if (healthMetrics.volatility_health.score < 40) {\n        conditions.push('HIGH_VOLATILITY');\n    }\n    \n    if (healthMetrics.liquidity_health.score < 50) {\n        conditions.push('LOW_LIQUIDITY');\n    }\n    \n    if (healthMetrics.efficiency_health.score < 60) {\n        conditions.push('MARKET_INEFFICIENCIES');\n    }\n    \n    if (conditions.length === 0) {\n        conditions.push('NORMAL_TRADING');\n    }\n    \n    return conditions;\n}\n\nfunction generateHealthBasedRecommendations(healthMetrics) {\n    const recommendations = [];\n    \n    if (healthMetrics.liquidity_health.score < 50) {\n        recommendations.push({\n            type: 'LIQUIDITY',\n            message: 'Low liquidity detected - reduce position sizes and increase execution time',\n            priority: 'HIGH'\n        });\n    }\n    \n    if (healthMetrics.volatility_health.score < 40) {\n        recommendations.push({\n            type: 'VOLATILITY',\n            message: 'High volatility - implement stricter risk management',\n            priority: 'HIGH'\n        });\n    }\n    \n    if (healthMetrics.efficiency_health.score < 60) {\n        recommendations.push({\n            type: 'EFFICIENCY',\n            message: 'Market inefficiencies present - opportunity for alpha generation',\n            priority: 'MEDIUM'\n        });\n    }\n    \n    return recommendations;\n}\n\nfunction generateRiskWarnings(healthMetrics) {\n    const warnings = [];\n    \n    if (healthMetrics.correlation_health.score < 30) {\n        warnings.push({\n            level: 'HIGH',\n            message: 'High correlation detected - systemic risk elevated'\n        });\n    }\n    \n    if (healthMetrics.volatility_health.score < 30) {\n        warnings.push({\n            level: 'HIGH',\n            message: 'Extreme volatility - potential for significant losses'\n        });\n    }\n    \n    return warnings;\n}\n\nfunction generateOpportunityOutlook(healthMetrics) {\n    let outlook = 'NEUTRAL';\n    let reasoning = [];\n    \n    if (healthMetrics.efficiency_health.score < 70) {\n        outlook = 'POSITIVE';\n        reasoning.push('Market inefficiencies present');\n    }\n    \n    if (healthMetrics.volatility_health.score > 60 && healthMetrics.volatility_health.score < 80) {\n        outlook = 'POSITIVE';\n        reasoning.push('Optimal volatility for trading');\n    }\n    \n    if (healthMetrics.liquidity_health.score > 70) {\n        reasoning.push('Good liquidity for execution');\n    }\n    \n    return {\n        outlook: outlook,\n        reasoning: reasoning,\n        confidence: reasoning.length > 1 ? 'HIGH' : 'MEDIUM'\n    };\n}\n\nfunction analyzeMonitoringResults(results) {\n    const successfulResults = results.filter(r => !r.error);\n    \n    if (successfulResults.length === 0) {\n        return {\n            persistent_opportunities: [],\n            trend_analysis: { trend: 'UNKNOWN' },\n            recommendations: []\n        };\n    }\n    \n    const opportunityTracker = new Map();\n    \n    successfulResults.forEach(result => {\n        Object.keys(result.spread_data || {}).forEach(symbol => {\n            const data = result.spread_data[symbol];\n            if (data.profitable) {\n                if (!opportunityTracker.has(symbol)) {\n                    opportunityTracker.set(symbol, []);\n                }\n                opportunityTracker.get(symbol).push({\n                    iteration: result.iteration,\n                    profit_bps: data.profit_bps,\n                    timestamp: result.timestamp\n                });\n            }\n        });\n    });\n    \n    const persistentOpportunities = [];\n    opportunityTracker.forEach((occurrences, symbol) => {\n        if (occurrences.length >= Math.max(2, successfulResults.length * 0.3)) {\n            persistentOpportunities.push({\n                symbol: symbol,\n                occurrences: occurrences.length,\n                avg_profit_bps: occurrences.reduce((sum, occ) => sum + occ.profit_bps, 0) / occurrences.length,\n                persistence_rate: occurrences.length / successfulResults.length\n            });\n        }\n    });\n    \n    return {\n        persistent_opportunities: persistentOpportunities,\n        trend_analysis: {\n            trend: persistentOpportunities.length > 0 ? 'STABLE_OPPORTUNITIES' : 'VOLATILE_MARKET',\n            opportunity_count_trend: 'STABLE'\n        },\n        recommendations: persistentOpportunities.length > 0 ? [\n            {\n                type: 'EXECUTION',\n                message: `${persistentOpportunities.length} persistent opportunities detected - consider execution`,\n                priority: 'HIGH'\n            }\n        ] : []\n    };\n}\n\n\n\n// ===== EXPORT FOR FLOWISE =====\nreturn await marketAnalysisService(\n    (typeof $function !== 'undefined') ? $function : null,\n    (typeof $symbols !== 'undefined') ? $symbols : null,\n    (typeof $exchanges !== 'undefined') ? $exchanges : null,\n    (typeof $timeframe !== 'undefined') ? $timeframe : null,\n    (typeof $min_profit_bps !== 'undefined') ? $min_profit_bps : null\n);",
  "workspaceId": "9b1b9829-f76f-472f-867f-4bac66fb62c0"
}