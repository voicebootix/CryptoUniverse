{
  "name": "Multi_Exchange_Portfolio_Risk_Service",
  "description": "V2: Unified multi-exchange portfolio management with institutional-grade risk controls across KuCoin, Kraken, and Binance - VaR calculation, position sizing, portfolio optimization, and dynamic capital allocation",
  "color": "linear-gradient(rgb(41,254,147), rgb(23,235,216))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"function\",\"type\":\"string\",\"description\":\"Function: 'get_portfolio', 'risk_analysis', 'optimize_allocation', 'position_sizing', 'correlation_analysis', 'stress_test', 'complete_assessment'\",\"required\":true},{\"id\":1,\"property\":\"strategy\",\"type\":\"string\",\"description\":\"Strategy for optimization: 'risk_parity', 'equal_weight', 'max_sharpe', 'min_variance', 'kelly_criterion', 'adaptive'\",\"required\":false},{\"id\":2,\"property\":\"opportunity\",\"type\":\"string\",\"description\":\"Trading opportunity JSON for position sizing: '{\\\"symbol\\\": \\\"BTC\\\", \\\"confidence\\\": 85, \\\"expected_return\\\": 15}'\",\"required\":false},{\"id\":3,\"property\":\"mode\",\"type\":\"string\",\"description\":\"Trading mode: 'conservative', 'balanced', 'aggressive', 'beast_mode'\",\"required\":false},{\"id\":4,\"property\":\"exchange_filter\",\"type\":\"string\",\"description\":\"Exchange filter: 'all', 'kraken', 'binance', 'kucoin', 'kraken,binance' (default: all)\",\"required\":false}]",
  "func": "// MULTI-EXCHANGE PORTFOLIO AND RISK SERVICE - Unified Portfolio Management\nconst fetch = require('node-fetch');\nconst crypto = require('crypto');\n\n// Monotonic Kraken nonce + small delay helper (enterprise-safe)\n// Replace the getKrakenNonce function with this improved version:\nlet KRAKEN_LAST_NONCE = BigInt(Date.now()) * 1000000n; // Start with current time in microseconds\n\nfunction getKrakenNonce() {\n    const now = BigInt(Date.now()) * 1000000n; // Microseconds\n    \n    // Always increment, never use the same nonce twice\n    if (now > KRAKEN_LAST_NONCE) {\n        KRAKEN_LAST_NONCE = now;\n    } else {\n        KRAKEN_LAST_NONCE = KRAKEN_LAST_NONCE + 1n;\n    }\n    \n    // Add random component to ensure uniqueness across restarts\n    const randomComponent = BigInt(Math.floor(Math.random() * 1000));\n    return (KRAKEN_LAST_NONCE + randomComponent).toString();\n}\nfunction delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n\nasync function multiExchangePortfolioService(functionType, strategy, opportunity, mode, exchangeFilter) {\n    console.log(`🛡️ Multi-Exchange Portfolio Service - Function: ${functionType}`);\n    \n    try {\n        const tradingMode = mode || 'balanced';\n        const optimizationStrategy = strategy || 'risk_parity';\n        const exchanges = parseExchangeFilter(exchangeFilter || 'all');\n        \n        // Route to specific function\n        switch (functionType.toLowerCase()) {\n            case 'get_portfolio':\n                return await getMultiExchangePortfolio(exchanges);\n            case 'risk_analysis':\n                return await performMultiExchangeRiskAnalysis(exchanges);\n            case 'optimize_allocation':\n                return await optimizeMultiExchangeAllocation(optimizationStrategy, tradingMode, exchanges);\n            case 'position_sizing':\n                return await calculateMultiExchangePositionSizing(opportunity, tradingMode, exchanges);\n            case 'correlation_analysis':\n                return await analyzeMultiExchangeCorrelations(exchanges);\n            case 'stress_test':\n                return await performMultiExchangeStressTest(exchanges);\n            case 'complete_assessment':\n                return await getCompleteMultiExchangeAssessment(optimizationStrategy, tradingMode, exchanges);\n            case 'adaptive_kelly_sizing':\n                return await adaptiveKellySizing(opportunity, tradingMode, exchanges);\n            case 'portfolio_heat_monitor':\n                return await portfolioHeatMonitor(exchanges);\n            case 'adaptive_exit_levels':\n                return await adaptiveExitLevels(opportunity, tradingMode);\n            default:\n                throw new Error(`Unknown function: ${functionType}`);\n        }\n        \n        // ===== CORE FUNCTIONS =====\n        \n        async function getMultiExchangePortfolio(exchanges) {\n    console.log('💰 Fetching multi-exchange portfolio data...');\n    \n    const results = {\n        individual_portfolios: {},\n        consolidated: {\n            total_value_usd: 0,\n            holdings: {},\n            exchange_breakdown: {}\n        }\n    };\n    \n    let totalValueUSD = 0;\n    const consolidatedHoldings = {};\n    \n    for (const exchange of exchanges) {\n        try {\n            console.log(`Fetching portfolio from ${exchange}...`);\n            let portfolio = null;\n            \n            // REAL API CALLS - NO MOCK DATA\n            switch (exchange) {\n                case 'kraken':\n                    if ($vars.KRAKEN_API_KEY && $vars.KRAKEN_PRIVATE_KEY) {\n                        portfolio = await fetchKrakenPortfolio();\n                    }\n                    break;\n                case 'binance':\n                    if ($vars.BINANCE_API_KEY && $vars.BINANCE_SECRET_KEY) {\n                        portfolio = await fetchBinancePortfolio();\n                    }\n                    break;\n                case 'kucoin':\n                    if ($vars.KUCOIN_API_KEY && $vars.KUCOIN_SECRET_KEY) {\n                        portfolio = await fetchKucoinPortfolio();\n                    }\n                    break;\n            }\n            \n            if (portfolio && portfolio.success) {\n                results.individual_portfolios[exchange] = portfolio;\n                \n                // Consolidate holdings\n                for (const [asset, data] of Object.entries(portfolio.holdings)) {\n                    if (data.quantity > 0) {\n                        if (!consolidatedHoldings[asset]) {\n                            consolidatedHoldings[asset] = {\n                                quantity: 0,\n                                value_usd: 0,\n                                exchanges: []\n                            };\n                        }\n                        consolidatedHoldings[asset].quantity += data.quantity;\n                        consolidatedHoldings[asset].value_usd += data.value_usd;\n                        consolidatedHoldings[asset].exchanges.push(exchange);\n                    }\n                }\n                \n                totalValueUSD += portfolio.total_value_usd;\n                results.consolidated.exchange_breakdown[exchange] = portfolio.total_value_usd;\n            } else {\n                console.warn(`❌ Failed to fetch ${exchange} portfolio`);\n                results.individual_portfolios[exchange] = { success: false, error: 'API unavailable' };\n            }\n            \n        } catch (error) {\n            console.error(`❌ Error fetching ${exchange} portfolio:`, error.message);\n            results.individual_portfolios[exchange] = { success: false, error: error.message };\n        }\n    }\n    \n    // Calculate percentages for consolidated holdings\n    for (const [asset, data] of Object.entries(consolidatedHoldings)) {\n        consolidatedHoldings[asset].percentage = totalValueUSD > 0 ? \n            ((data.value_usd / totalValueUSD) * 100).toFixed(2) : 0;\n    }\n    \n    results.consolidated.total_value_usd = totalValueUSD;\n    results.consolidated.holdings = consolidatedHoldings;\n    \n    return {\n        success: true,\n        timestamp: new Date().toISOString(),\n        multi_exchange_portfolio: results\n    };\n}        \n        async function fetchExchangePortfolio(exchange) {\n            switch (exchange.toLowerCase()) {\n                case 'kraken':\n                    return await fetchKrakenPortfolio();\n                case 'binance':\n                    return await fetchBinancePortfolio();\n                case 'kucoin':\n                    return await fetchKucoinPortfolio();\n                default:\n                    throw new Error(`Unsupported exchange: ${exchange}`);\n            }\n        }\n        \n        async function fetchKrakenPortfolio() {\n            const apiKey = $vars.KRAKEN_API_KEY;\n            const privateKey = $vars.KRAKEN_PRIVATE_KEY;\n            \n            if (!apiKey || !privateKey) {\n                throw new Error('Kraken API credentials not configured');\n            }\n            \n            // SURGICAL FIX: Strictly monotonic nonce to prevent \"Invalid nonce\"\n            const urlPath = '/0/private/Balance';\n            let attempt = 0;\n            while (true) {\n                attempt++;\n                const nonce = getKrakenNonce();\n                const requestData = { nonce: nonce };\n                const postData = Object.keys(requestData)\n                    .map(key => `${key}=${encodeURIComponent(requestData[key])}`)\n                    .join('&');\n                const encoded = nonce + postData;\n                const sha256Hash = crypto.createHash('sha256').update(encoded).digest();\n                const message = Buffer.concat([Buffer.from(urlPath, 'utf8'), sha256Hash]);\n                const secretBuffer = Buffer.from(privateKey, 'base64');\n                const signature = crypto.createHmac('sha512', secretBuffer).update(message).digest('base64');\n                \n                const response = await fetch(`https://api.kraken.com${urlPath}`, {\n                    method: 'POST',\n                    headers: {\n                        'API-Key': apiKey,\n                        'API-Sign': signature,\n                        'Content-Type': 'application/x-www-form-urlencoded'\n                    },\n                    body: postData\n                });\n                \n                if (!response.ok) {\n                    throw new Error(`Kraken API error: ${response.status}`);\n                }\n                \n                const data = await response.json();\n                if (data.error && data.error.length > 0) {\n                    const combined = data.error.join(', ');\n                    if (combined.includes('EAPI:Invalid nonce') && attempt < 3) {\n                        console.warn('Kraken Invalid nonce, retrying with new nonce...');\n                        await delay(15 * attempt);\n                        continue;\n                    }\n                    throw new Error(`Kraken API errors: ${combined}`);\n                }\n                \n                return await processKrakenBalances(data.result);\n            }\n        }\n        \n        async function fetchBinancePortfolio() {\n            const apiKey = $vars.BINANCE_API_KEY;\n            const secretKey = $vars.BINANCE_SECRET_KEY;\n            \n            if (!apiKey || !secretKey) {\n                throw new Error('Binance API credentials not configured');\n            }\n            \n            const timestamp = Date.now();\n            const queryString = `timestamp=${timestamp}`;\n            const signature = crypto.createHmac('sha256', secretKey).update(queryString).digest('hex');\n            \n            const response = await fetch(`https://api.binance.com/api/v3/account?${queryString}&signature=${signature}`, {\n                method: 'GET',\n                headers: {\n                    'X-MBX-APIKEY': apiKey\n                }\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Binance API error: ${response.status}`);\n            }\n            \n            const data = await response.json();\n            return await processBinanceBalances(data.balances);\n        }\n        \n        async function fetchKucoinPortfolio() {\n            const apiKey = $vars.KUCOIN_API_KEY;\n            const secretKey = $vars.KUCOIN_SECRET_KEY;\n            const passphrase = $vars.KUCOIN_PASSPHRASE;\n            \n            if (!apiKey || !secretKey || !passphrase) {\n                throw new Error('KuCoin API credentials not configured');\n            }\n            \n            const timestamp = Date.now();\n            const method = 'GET';\n            const endpoint = '/api/v1/accounts';\n            const str_to_sign = timestamp + method + endpoint;\n            \n            const signature = crypto.createHmac('sha256', secretKey).update(str_to_sign).digest('base64');\n            const passphrase_hmac = crypto.createHmac('sha256', secretKey).update(passphrase).digest('base64');\n            \n            const response = await fetch(`https://api.kucoin.com${endpoint}`, {\n                method: 'GET',\n                headers: {\n                    'KC-API-KEY': apiKey,\n                    'KC-API-SIGN': signature,\n                    'KC-API-TIMESTAMP': timestamp.toString(),\n                    'KC-API-PASSPHRASE': passphrase_hmac,\n                    'KC-API-KEY-VERSION': '2'\n                }\n            });\n            \n            if (!response.ok) {\n                throw new Error(`KuCoin API error: ${response.status}`);\n            }\n            \n            const data = await response.json();\n            \n            if (data.code !== '200000') {\n                throw new Error(`KuCoin API error: ${data.msg}`);\n            }\n            \n            return await processKucoinBalances(data.data);\n        }\n        \n        async function processKrakenBalances(balances) {\n            const holdings = {};\n            let totalValue = 0;\n            \n            const priceData = await getCurrentPrices(Object.keys(balances), 'kraken');\n            \n            for (const [currency, balance] of Object.entries(balances)) {\n                const numBalance = parseFloat(balance);\n                if (numBalance > 0.001) {\n                    const normalizedCurrency = normalizeKrakenCurrency(currency);\n                    const price = priceData[normalizedCurrency];\n                    \n                    // Only include assets with valid prices\n                    if (price !== null && price !== undefined && price > 0) {\n                        const value = numBalance * price;\n                        \n                        holdings[normalizedCurrency] = {\n                            balance: numBalance,\n                            price_usd: price,\n                            value_usd: value,\n                            percentage: 0,\n                            exchange: 'kraken'\n                        };\n                        \n                        totalValue += value;\n                    } else {\n    // Try fallback price sources for missing data\n    let fallbackPrice = null;\n    \n    try {\n        // Attempt CoinGecko fallback for major currencies\n        if (['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'MATIC', 'AVAX'].includes(normalizedCurrency)) {\n            fallbackPrice = await getCoinGeckoPrice(normalizedCurrency);\n        }\n        \n        if (fallbackPrice && fallbackPrice > 0) {\n            const value = numBalance * fallbackPrice;\n            \n            holdings[normalizedCurrency] = {\n                balance: numBalance,\n                price_usd: fallbackPrice,\n                value_usd: value,\n                percentage: 0,\n                exchange: 'kraken',\n                price_source: 'fallback'\n            };\n            \n            totalValue += value;\n            console.log(`✅ Used fallback price for ${normalizedCurrency}: $${fallbackPrice}`);\n        } else {\n            console.log(`⚠️  Skipping ${normalizedCurrency} - no price data available (balance: ${numBalance})`);\n            \n            // Still track the asset with zero value for portfolio completeness\n            holdings[normalizedCurrency] = {\n                balance: numBalance,\n                price_usd: 0,\n                value_usd: 0,\n                percentage: 0,\n                exchange: 'kraken',\n                price_source: 'unavailable'\n            };\n        }\n    } catch (fallbackError) {\n        console.log(`⚠️  Skipping ${normalizedCurrency} - price fetch failed: ${fallbackError.message}`);\n        \n        // Track failed asset\n        holdings[normalizedCurrency] = {\n            balance: numBalance,\n            price_usd: 0,\n            value_usd: 0,\n            percentage: 0,\n            exchange: 'kraken',\n            price_source: 'error',\n            error: fallbackError.message\n        };\n    }\n}\n                }\n            }\n            \n            // Calculate percentages\n            for (const holding of Object.values(holdings)) {\n                holding.percentage = totalValue > 0 ? (holding.value_usd / totalValue) * 100 : 0;\n            }\n            \n            return {\n                success: true,\n                holdings: holdings,\n                total_value_usd: totalValue,\n                exchange: 'kraken',\n                last_updated: new Date().toISOString()\n            };\n        }\n        \n        async function processBinanceBalances(balances) {\n            const holdings = {};\n            let totalValue = 0;\n            \n            const currencies = balances.filter(b => parseFloat(b.free) > 0.001).map(b => b.asset);\n            const priceData = await getCurrentPrices(currencies, 'binance');\n            \n            for (const balance of balances) {\n                const numBalance = parseFloat(balance.free) + parseFloat(balance.locked);\n                if (numBalance > 0.001) {\n                    const currency = balance.asset;\n                    const price = priceData[currency];\n                    \n                    // Only include assets with valid prices\n                    if (price !== null && price !== undefined && price > 0) {\n                        const value = numBalance * price;\n                        \n                        holdings[currency] = {\n                            balance: numBalance,\n                            free: parseFloat(balance.free),\n                            locked: parseFloat(balance.locked),\n                            price_usd: price,\n                            value_usd: value,\n                            percentage: 0,\n                            exchange: 'binance'\n                        };\n                        \n                        totalValue += value;\n                    } else {\n                        console.log(`Skipping ${currency} - no price data available`);\n                    }\n                }\n            }\n            \n            // Calculate percentages\n            for (const holding of Object.values(holdings)) {\n                holding.percentage = totalValue > 0 ? (holding.value_usd / totalValue) * 100 : 0;\n            }\n            \n            return {\n                success: true,\n                holdings: holdings,\n                total_value_usd: totalValue,\n                exchange: 'binance',\n                last_updated: new Date().toISOString()\n            };\n        }\n        \n        async function processKucoinBalances(accounts) {\n            const holdings = {};\n            let totalValue = 0;\n            \n            const currencies = accounts.filter(acc => parseFloat(acc.balance) > 0.001).map(acc => acc.currency);\n            const priceData = await getCurrentPrices(currencies, 'kucoin');\n            \n            for (const account of accounts) {\n                const numBalance = parseFloat(account.balance);\n                if (numBalance > 0.001) {\n                    const currency = account.currency;\n                    const price = priceData[currency];\n                    \n                    // Only include assets with valid prices\n                    if (price !== null && price !== undefined && price > 0) {\n                        const value = numBalance * price;\n                        \n                        holdings[currency] = {\n                            balance: numBalance,\n                            available: parseFloat(account.available),\n                            holds: parseFloat(account.holds),\n                            price_usd: price,\n                            value_usd: value,\n                            percentage: 0,\n                            exchange: 'kucoin',\n                            account_type: account.type\n                        };\n                        \n                        totalValue += value;\n                    } else {\n                        console.log(`Skipping ${currency} - no price data available`);\n                    }\n                }\n            }\n            \n            // Calculate percentages\n            for (const holding of Object.values(holdings)) {\n                holding.percentage = totalValue > 0 ? (holding.value_usd / totalValue) * 100 : 0;\n            }\n            \n            return {\n                success: true,\n                holdings: holdings,\n                total_value_usd: totalValue,\n                exchange: 'kucoin',\n                last_updated: new Date().toISOString()\n            };\n        }\n        \n        function normalizeKrakenCurrency(currency) {\n            // Remove Kraken's X/Z prefixes\n            if (currency.startsWith('X') || currency.startsWith('Z')) {\n                return currency.substring(1);\n            }\n            return currency;\n        }\n        \n        async function getCurrentPrices(currencies, exchangeSource) {\n            const prices = {};\n            \n            for (const currency of currencies) {\n                // Handle stablecoins\n                if (['USD', 'USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDP', 'GUSD'].includes(currency.toUpperCase())) {\n                    prices[currency] = 1;\n                    continue;\n                }\n                \n                let price = null;\n                \n                try {\n                    // Try exchange-specific pricing first for accuracy\n                    if (exchangeSource === 'binance') {\n                        // Try multiple quote currencies\n                        const quoteCurrencies = ['USDT', 'BUSD', 'USDC'];\n                        for (const quote of quoteCurrencies) {\n                            try {\n                                const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${currency}${quote}`);\n                                if (response.ok) {\n                                    const data = await response.json();\n                                    if (data.price) {\n                                        price = parseFloat(data.price);\n                                        break;\n                                    }\n                                }\n                            } catch (e) {\n                                // Try next quote currency\n                            }\n                        }\n                        \n                        // Special handling for exchange notations like 1000PEPPER\n                        if (price === null && currency.match(/^\\d+[A-Z]/)) {\n                            const baseSymbol = currency.replace(/^\\d+/, '');\n                            const multiplier = parseInt(currency.match(/^\\d+/)[0]);\n                            \n                            for (const quote of quoteCurrencies) {\n                                try {\n                                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${baseSymbol}${quote}`);\n                                    if (response.ok) {\n                                        const data = await response.json();\n                                        if (data.price) {\n                                            price = parseFloat(data.price) * multiplier;\n                                            break;\n                                        }\n                                    }\n                                } catch (e) {\n                                    // Try next\n                                }\n                            }\n                        }\n                        \n                    } else if (exchangeSource === 'kucoin') {\n                        // KuCoin API\n                        const response = await fetch(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${currency}-USDT`);\n                        if (response.ok) {\n                            const data = await response.json();\n                            if (data.data && data.data.price) {\n                                price = parseFloat(data.data.price);\n                            }\n                        }\n                        \n                        // Try USDC if USDT fails\n                        if (price === null) {\n                            const response2 = await fetch(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${currency}-USDC`);\n                            if (response2.ok) {\n                                const data = await response2.json();\n                                if (data.data && data.data.price) {\n                                    price = parseFloat(data.data.price);\n                                }\n                            }\n                        }\n                        \n                    } else if (exchangeSource === 'kraken') {\n                        // Kraken API - handle their special pair notation\n                        const pairMappings = {\n                            'BTC': 'XXBTZUSD',\n                            'ETH': 'XETHZUSD',\n                            'XBT': 'XXBTZUSD',\n                            'ETHW': 'ETHWUSD'\n                        };\n                        \n                        const pair = pairMappings[currency] || `${currency}USD`;\n                        const response = await fetch(`https://api.kraken.com/0/public/Ticker?pair=${pair}`);\n                        \n                        if (response.ok) {\n                            const data = await response.json();\n                            if (data.result) {\n                                const ticker = Object.values(data.result)[0];\n                                if (ticker && ticker.c) {\n                                    price = parseFloat(ticker.c[0]);\n                                }\n                            }\n                        }\n                    }\n                    \n                    // Fallback to CoinGecko if exchange price not available\n                    if (price === null) {\n                        price = await getCoinGeckoPrice(currency);\n                    }\n                    \n                } catch (error) {\n                    console.log(`Price fetch failed for ${currency} from ${exchangeSource}: ${error.message}`);\n                }\n                \n                // Store the price or null (never default to 1 for unknown assets)\n                prices[currency] = price;\n            }\n            \n            return prices;\n        }\n        \n        async function getCoinGeckoPrice(symbol) {\n            try {\n                // First try to search for the coin ID dynamically\n                const searchResponse = await fetch(`https://api.coingecko.com/api/v3/search?query=${symbol}`);\n                if (searchResponse.ok) {\n                    const searchData = await searchResponse.json();\n                    if (searchData.coins && searchData.coins.length > 0) {\n                        // Find exact symbol match\n                        const exactMatch = searchData.coins.find(coin => \n                            coin.symbol.toUpperCase() === symbol.toUpperCase()\n                        );\n                        \n                        if (exactMatch) {\n                            // Get price using the found coin ID\n                            const priceResponse = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${exactMatch.id}&vs_currencies=usd`);\n                            if (priceResponse.ok) {\n                                const priceData = await priceResponse.json();\n                                if (priceData[exactMatch.id] && priceData[exactMatch.id].usd) {\n                                    return priceData[exactMatch.id].usd;\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(`CoinGecko price fetch failed for ${symbol}: ${error.message}`);\n            }\n            \n            return null;\n        }\n        \n        function consolidatePortfolios(exchangePortfolios) {\n            const consolidated = {\n                holdings: {},\n                total_value_usd: 0,\n                significant_holdings: {},\n                number_of_positions: 0,\n                largest_position_percentage: 0,\n                diversification_score: 0,\n                exchange_distribution: {}\n            };\n            \n            let totalValue = 0;\n            \n            // Consolidate holdings across exchanges\n            for (const [exchange, portfolio] of Object.entries(exchangePortfolios)) {\n                if (portfolio.error) continue;\n                \n                totalValue += portfolio.total_value_usd;\n                consolidated.exchange_distribution[exchange] = {\n                    value_usd: portfolio.total_value_usd,\n                    percentage: 0\n                };\n                \n                for (const [currency, holding] of Object.entries(portfolio.holdings)) {\n                    if (!consolidated.holdings[currency]) {\n                        consolidated.holdings[currency] = {\n                            total_balance: 0,\n                            total_value_usd: 0,\n                            price_usd: holding.price_usd,\n                            exchanges: {},\n                            percentage: 0\n                        };\n                    }\n                    \n                    consolidated.holdings[currency].total_balance += holding.balance;\n                    consolidated.holdings[currency].total_value_usd += holding.value_usd;\n                    consolidated.holdings[currency].exchanges[exchange] = {\n                        balance: holding.balance,\n                        value_usd: holding.value_usd,\n                        percentage: holding.percentage\n                    };\n                }\n            }\n            \n            consolidated.total_value_usd = totalValue;\n            \n            // Calculate exchange distribution percentages\n            for (const exchange of Object.values(consolidated.exchange_distribution)) {\n                exchange.percentage = totalValue > 0 ? (exchange.value_usd / totalValue) * 100 : 0;\n            }\n            \n            // Calculate asset percentages and metrics\n            let largestPosition = 0;\n            for (const holding of Object.values(consolidated.holdings)) {\n                holding.percentage = totalValue > 0 ? (holding.total_value_usd / totalValue) * 100 : 0;\n                if (holding.percentage >= 5) {\n                    consolidated.significant_holdings[Object.keys(consolidated.holdings).find(k => consolidated.holdings[k] === holding)] = holding;\n                }\n                if (holding.total_value_usd > largestPosition) {\n                    largestPosition = holding.total_value_usd;\n                }\n                consolidated.number_of_positions++;\n            }\n            \n            consolidated.largest_position_percentage = totalValue > 0 ? (largestPosition / totalValue) * 100 : 0;\n            consolidated.diversification_score = calculateDiversificationScore(consolidated.holdings);\n            \n            return consolidated;\n        }\n        \n        function calculateDiversificationScore(holdings) {\n            const positions = Object.values(holdings);\n            if (positions.length <= 1) return 0;\n            \n            const hhi = positions.reduce((sum, holding) => {\n                const weight = holding.percentage / 100;\n                return sum + (weight * weight);\n            }, 0);\n            \n            return Math.max(0, Math.min(100, (1 - hhi) * 100));\n        }\n        \n        function findCrossExchangeOpportunities(exchangePortfolios) {\n            const opportunities = [];\n            const exchangeNames = Object.keys(exchangePortfolios).filter(ex => !exchangePortfolios[ex].error);\n            \n            // Find assets available on multiple exchanges\n            const assetExchangeMap = {};\n            \n            for (const [exchange, portfolio] of Object.entries(exchangePortfolios)) {\n                if (portfolio.error) continue;\n                \n                for (const [asset, holding] of Object.entries(portfolio.holdings)) {\n                    if (!assetExchangeMap[asset]) {\n                        assetExchangeMap[asset] = {};\n                    }\n                    assetExchangeMap[asset][exchange] = holding.price_usd;\n                }\n            }\n            \n            // Find arbitrage opportunities\n            for (const [asset, exchanges] of Object.entries(assetExchangeMap)) {\n                const exchangeList = Object.keys(exchanges);\n                if (exchangeList.length < 2) continue;\n                \n                const prices = Object.values(exchanges);\n                const minPrice = Math.min(...prices);\n                const maxPrice = Math.max(...prices);\n                const priceDiff = ((maxPrice - minPrice) / minPrice) * 100;\n                \n                if (priceDiff > 0.5) { // 0.5% threshold\n                    const minExchange = exchangeList.find(ex => exchanges[ex] === minPrice);\n                    const maxExchange = exchangeList.find(ex => exchanges[ex] === maxPrice);\n                    \n                    opportunities.push({\n                        asset: asset,\n                        arbitrage_opportunity: priceDiff.toFixed(2) + '%',\n                        buy_exchange: minExchange,\n                        sell_exchange: maxExchange,\n                        buy_price: minPrice,\n                        sell_price: maxPrice,\n                        potential_profit_pct: priceDiff.toFixed(2)\n                    });\n                }\n            }\n            \n            return opportunities.sort((a, b) => parseFloat(b.potential_profit_pct) - parseFloat(a.potential_profit_pct));\n        }\n        \n        function assessExchangeHealth(exchangePortfolios) {\n            const health = {};\n            \n            for (const [exchange, portfolio] of Object.entries(exchangePortfolios)) {\n                if (portfolio.error) {\n                    health[exchange] = {\n                        status: 'ERROR',\n                        error: portfolio.error,\n                        last_successful_fetch: null\n                    };\n                } else {\n                    health[exchange] = {\n                        status: 'HEALTHY',\n                        total_value: portfolio.total_value_usd,\n                        asset_count: Object.keys(portfolio.holdings).length,\n                        last_updated: portfolio.last_updated\n                    };\n                }\n            }\n            \n            return health;\n        }\n        \n        async function performMultiExchangeRiskAnalysis(exchanges) {\n    console.log('📊 Performing multi-exchange risk analysis...');\n    \n    try {\n        const portfolioData = await getMultiExchangePortfolio(exchanges);\n        if (!portfolioData.success) {\n            throw new Error('Failed to get portfolio data for risk analysis');\n        }\n        \n        const consolidated = portfolioData.multi_exchange_portfolio.consolidated;\n        \n        // SAFE DATA ACCESS with extensive validation\n        const exchangeDistribution = consolidated ? consolidated.exchange_breakdown : null;\n        const holdings = consolidated ? consolidated.holdings : null;\n        \n        // BULLETPROOF correlation risk calculation\n        let correlationRisk;\n        try {\n            // Try the individual portfolios first\n            const individualPortfolios = portfolioData.multi_exchange_portfolio ? \n                portfolioData.multi_exchange_portfolio.individual_portfolios : null;\n            \n            correlationRisk = await calculateCrossExchangeCorrelationRisk(individualPortfolios);\n        } catch (correlationError) {\n            console.error('❌ Correlation calculation failed:', correlationError);\n            // Fallback correlation risk\n            correlationRisk = {\n                exchange_count: 0,\n                correlation_risk: 'ERROR',\n                diversification_benefit: 'UNKNOWN',\n                error: correlationError.message\n            };\n        }\n        \n        // Multi-exchange specific risks with safe defaults\n        const riskMetrics = {\n            portfolio_value: consolidated ? (consolidated.total_value_usd || 0) : 0,\n            exchange_concentration_risk: exchangeDistribution ? \n                calculateExchangeConcentrationRisk(exchangeDistribution) : \n                { risk_level: 'UNKNOWN', max_exchange_concentration: '0%' },\n            asset_concentration_risk: holdings ? \n                calculateAssetConcentrationRisk(holdings) : \n                { risk_level: 'UNKNOWN', largest_position: '0%' },\n            cross_exchange_correlation_risk: correlationRisk,\n            operational_risk: portfolioData.exchange_health ? \n                assessOperationalRisk(portfolioData.exchange_health) : \n                { operational_risk: 'UNKNOWN' },\n            liquidity_risk: holdings ? \n                assessMultiExchangeLiquidityRisk(holdings) : \n                { risk_level: 'UNKNOWN' },\n            counterparty_risk: assessCounterpartyRisk(exchanges),\n            var_analysis: consolidated ? \n                calculateMultiExchangeVaR(consolidated) : \n                { '95%_confidence': { '1_day': 0 } },\n            stress_test_results: await performMultiExchangeStressTest(exchanges)\n        };\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            multi_exchange_risk_analysis: riskMetrics,\n            recommendations: generateMultiExchangeRiskRecommendations(riskMetrics)\n        };\n        \n    } catch (error) {\n        console.error('❌ Risk analysis error:', error);\n        \n        // BULLETPROOF error handling - never crash the system\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString(),\n            multi_exchange_risk_analysis: {\n                portfolio_value: 0,\n                exchange_concentration_risk: { risk_level: 'UNKNOWN' },\n                asset_concentration_risk: { risk_level: 'UNKNOWN' },\n                cross_exchange_correlation_risk: { correlation_risk: 'ERROR' },\n                operational_risk: { operational_risk: 'UNKNOWN' },\n                liquidity_risk: { risk_level: 'UNKNOWN' },\n                counterparty_risk: { overall_rating: 'UNKNOWN' },\n                var_analysis: { '95%_confidence': { '1_day': 0 } },\n                message: 'Risk analysis temporarily unavailable',\n                error_details: error.message\n            },\n            recommendations: [{\n                priority: 'CRITICAL',\n                category: 'System Error',\n                issue: 'Risk analysis system temporarily unavailable',\n                action: 'Check system logs and restart services if needed',\n                target: 'Restore full risk analysis functionality'\n            }]\n        };\n    }\n}\n        \n        function calculateExchangeConcentrationRisk(exchangeDistribution) {\n            const distributions = exchangeDistribution ? Object.values(exchangeDistribution) : [];\n            const maxConcentration = Math.max(...distributions.map(d => d.percentage || 0));\n            \n            return {\n                max_exchange_concentration: maxConcentration.toFixed(1) + '%',\n                risk_level: maxConcentration > 70 ? 'HIGH' : maxConcentration > 50 ? 'MEDIUM' : 'LOW',\n                diversification_benefit: maxConcentration < 60 ? 'GOOD' : 'LIMITED'\n            };\n        }\n        \n        function calculateAssetConcentrationRisk(holdings) {\n            const positions = Object.values(holdings || {});\n            const maxPosition = positions.length > 0 ? Math.max(...positions.map(p => p.percentage || 0)) : 0;\n            \n            return {\n                largest_position: maxPosition.toFixed(1) + '%',\n                risk_level: maxPosition > 50 ? 'EXTREME' : maxPosition > 25 ? 'HIGH' : maxPosition > 15 ? 'MEDIUM' : 'LOW'\n            };\n        }\n        \n        async function calculateCrossExchangeCorrelationRisk(exchangePortfolios) {\n    console.log('🔍 Calculating cross-exchange correlation risk...');\n    if (!exchangePortfolios || typeof exchangePortfolios !== 'object') {\n        return {\n        exchange_count: 0,\n        correlation_risk: 'UNKNOWN',\n        diversification_benefit: 'UNKNOWN',\n        message: 'Insufficient data for correlation analysis'\n        };\n    }\n    // BULLETPROOF NULL/UNDEFINED CHECKS\n    if (!exchangePortfolios) {\n        console.warn('⚠️ exchangePortfolios is null or undefined');\n        return {\n            exchange_count: 0,\n            correlation_risk: 'UNKNOWN', \n            diversification_benefit: 'UNKNOWN',\n            message: 'No exchange portfolio data provided'\n        };\n    }\n    \n    if (typeof exchangePortfolios !== 'object') {\n        console.warn('⚠️ exchangePortfolios is not an object:', typeof exchangePortfolios);\n        return {\n            exchange_count: 0,\n            correlation_risk: 'UNKNOWN', \n            diversification_benefit: 'UNKNOWN',\n            message: 'Invalid exchange portfolio data type'\n        };\n    }\n    \n    // SAFE Object.keys() with try/catch\n    let activeExchanges = [];\n    try {\n        const allKeys = Object.keys(exchangePortfolios);\n        console.log('🔍 Found exchange keys:', allKeys);\n        \n        activeExchanges = allKeys.filter(ex => {\n            const portfolio = exchangePortfolios[ex];\n            return portfolio && !portfolio.error && portfolio.success !== false;\n        });\n        \n        console.log('✅ Active exchanges after filtering:', activeExchanges);\n        \n    } catch (error) {\n        console.error('❌ Error in Object.keys() operation:', error);\n        return {\n            exchange_count: 0,\n            correlation_risk: 'ERROR',\n            diversification_benefit: 'UNKNOWN',\n            error: `Object.keys failed: ${error.message}`,\n            message: 'Cannot analyze correlation due to data structure error'\n        };\n    }\n    \n    // SAFE CALCULATION\n    const exchangeCount = activeExchanges.length;\n    \n    let correlationRisk = 'UNKNOWN';\n    let diversificationBenefit = 'UNKNOWN';\n    \n    if (exchangeCount === 0) {\n        correlationRisk = 'CRITICAL';\n        diversificationBenefit = 'NONE';\n    } else if (exchangeCount === 1) {\n        correlationRisk = 'HIGH';\n        diversificationBenefit = 'NONE';\n    } else if (exchangeCount === 2) {\n        correlationRisk = 'MEDIUM';\n        diversificationBenefit = 'MEDIUM';\n    } else {\n        correlationRisk = 'LOW';\n        diversificationBenefit = 'HIGH';\n    }\n    \n    return {\n        exchange_count: exchangeCount,\n        correlation_risk: correlationRisk,\n        diversification_benefit: diversificationBenefit,\n        active_exchanges: activeExchanges,\n        message: `Correlation analysis completed for ${exchangeCount} exchanges`\n    };\n}\n        \n        function assessOperationalRisk(exchangeHealth) {\n            const totalExchanges = Object.keys(exchangeHealth).length;\n            const healthyExchanges = Object.values(exchangeHealth).filter(h => h.status === 'HEALTHY').length;\n            const healthRatio = healthyExchanges / totalExchanges;\n            \n            return {\n                healthy_exchanges: healthyExchanges,\n                total_exchanges: totalExchanges,\n                health_ratio: (healthRatio * 100).toFixed(1) + '%',\n                operational_risk: healthRatio > 0.8 ? 'LOW' : healthRatio > 0.6 ? 'MEDIUM' : 'HIGH'\n            };\n        }\n        \n        function assessMultiExchangeLiquidityRisk(holdings) {\n            // Enhanced liquidity assessment for multi-exchange setup\n            let totalLiquidityScore = 0;\n            let totalValue = 0;\n            \n            for (const [asset, holding] of Object.entries(holdings)) {\n                const assetLiquidity = getAssetLiquidity(asset);\n                const exchangeCount = Object.keys(holding.exchanges).length;\n                const exchangeBonus = Math.min(exchangeCount * 10, 30); // Up to 30% bonus for multiple exchanges\n                \n                const adjustedLiquidity = Math.min(assetLiquidity + exchangeBonus, 100);\n                totalLiquidityScore += adjustedLiquidity * holding.total_value_usd;\n                totalValue += holding.total_value_usd;\n            }\n            \n            const avgLiquidityScore = totalValue > 0 ? totalLiquidityScore / totalValue : 0;\n            \n            return {\n                liquidity_score: Math.round(avgLiquidityScore),\n                risk_level: avgLiquidityScore > 80 ? 'LOW' : avgLiquidityScore > 60 ? 'MEDIUM' : 'HIGH',\n                multi_exchange_benefit: 'Improved liquidity through exchange diversification'\n            };\n        }\n        \n        function getAssetLiquidity(asset) {\n            const liquidityScores = {\n                'BTC': 95, 'ETH': 90, 'ADA': 70, 'SOL': 75, 'DOT': 65,\n                'LINK': 70, 'MATIC': 65, 'AVAX': 60, 'UNI': 65, 'LTC': 80,\n                'USD': 100, 'USDT': 95, 'USDC': 95, 'XRP': 75, 'DOGE': 70,\n                'SHIB': 60, 'BNB': 85, 'KCS': 50\n            };\n            return liquidityScores[asset] || 30;\n        }\n        \n        function assessCounterpartyRisk(exchanges) {\n            const riskProfiles = {\n                'kraken': { risk_score: 20, rating: 'LOW' },\n                'binance': { risk_score: 30, rating: 'LOW-MEDIUM' },\n                'kucoin': { risk_score: 40, rating: 'MEDIUM' }\n            };\n            \n            const totalRisk = exchanges.reduce((sum, ex) => sum + (riskProfiles[ex]?.risk_score || 50), 0);\n            const avgRisk = totalRisk / exchanges.length;\n            \n            return {\n                average_risk_score: Math.round(avgRisk),\n                overall_rating: avgRisk < 25 ? 'LOW' : avgRisk < 40 ? 'MEDIUM' : 'HIGH',\n                exchange_diversification_benefit: exchanges.length > 1 ? 'GOOD' : 'NONE'\n            };\n        }\n        \n        function calculateMultiExchangeVaR(consolidated) {\n            const totalValue = consolidated.total_value_usd;\n            \n            if (totalValue === 0) {\n                return {\n                    '95%_confidence': { '1_day': 0, '7_day': 0, '30_day': 0 },\n                    '99%_confidence': { '1_day': 0, '7_day': 0, '30_day': 0 }\n                };\n            }\n            \n            // Enhanced VaR calculation considering multi-exchange setup\n            let portfolioVolatility = 0;\n            for (const [asset, holding] of Object.entries(consolidated.holdings)) {\n                const weight = holding.percentage / 100;\n                const assetVolatility = getAssetVolatility(asset);\n                const exchangeDiversificationFactor = Object.keys(holding.exchanges).length > 1 ? 0.9 : 1.0;\n                portfolioVolatility += weight * assetVolatility * exchangeDiversificationFactor;\n            }\n            \n            const var95_1d = totalValue * portfolioVolatility * 1.645 / Math.sqrt(365);\n            const var99_1d = totalValue * portfolioVolatility * 2.326 / Math.sqrt(365);\n            \n            return {\n                portfolio_volatility: (portfolioVolatility * 100).toFixed(2) + '%',\n                '95%_confidence': {\n                    '1_day': var95_1d.toFixed(2),\n                    '7_day': (var95_1d * Math.sqrt(7)).toFixed(2),\n                    '30_day': (var95_1d * Math.sqrt(30)).toFixed(2)\n                },\n                '99%_confidence': {\n                    '1_day': var99_1d.toFixed(2),\n                    '7_day': (var99_1d * Math.sqrt(7)).toFixed(2),\n                    '30_day': (var99_1d * Math.sqrt(30)).toFixed(2)\n                },\n                multi_exchange_benefit: 'Reduced VaR through exchange diversification'\n            };\n        }\n        \n        function getAssetVolatility(asset) {\n            const volatilities = {\n                'BTC': 0.80, 'ETH': 0.85, 'ADA': 1.20, 'SOL': 1.50,\n                'DOT': 1.30, 'LINK': 1.40, 'MATIC': 1.60, 'AVAX': 1.70,\n                'UNI': 1.50, 'LTC': 0.90, 'USD': 0.02, 'USDT': 0.05, 'USDC': 0.05,\n                'XRP': 1.10, 'DOGE': 1.80, 'SHIB': 2.00, 'BNB': 0.90, 'KCS': 1.40\n            };\n            return volatilities[asset] || 1.00;\n        }\n        \n        async function performMultiExchangeStressTest(exchanges) {\n            const portfolioData = await getMultiExchangePortfolio(exchanges);\n            const consolidated = portfolioData.multi_exchange_portfolio.consolidated;\n            const totalValue = consolidated.total_value_usd;\n            \n            const stressScenarios = {\n                crypto_winter: {\n                    name: 'Crypto Winter (Multi-Exchange)',\n                    shocks: { 'BTC': -0.70, 'ETH': -0.75, 'ADA': -0.85, 'SOL': -0.90, 'USD': 0.00 },\n                    exchange_failure_probability: 0.1\n                },\n                exchange_hack: {\n                    name: 'Major Exchange Security Breach',\n                    shocks: { 'BTC': -0.15, 'ETH': -0.20, 'ADA': -0.25, 'SOL': -0.30, 'USD': 0.00 },\n                    exchange_failure_probability: 0.33\n                },\n                regulatory_crackdown: {\n                    name: 'Global Regulatory Restrictions',\n                    shocks: { 'BTC': -0.40, 'ETH': -0.50, 'ADA': -0.60, 'SOL': -0.65, 'USD': 0.00 },\n                    exchange_failure_probability: 0.2\n                },\n                liquidity_crisis: {\n                    name: 'Multi-Exchange Liquidity Crisis',\n                    shocks: { 'BTC': -0.25, 'ETH': -0.30, 'ADA': -0.60, 'SOL': -0.70, 'USD': 0.00 },\n                    exchange_failure_probability: 0.15\n                }\n            };\n            \n            const stressResults = {};\n            \n            for (const [scenarioKey, scenario] of Object.entries(stressScenarios)) {\n                let portfolioLoss = 0;\n                let exchangeFailureLoss = 0;\n                \n                // Calculate market impact\n                for (const [asset, holding] of Object.entries(consolidated.holdings)) {\n                    const shock = scenario.shocks[asset] || 0;\n                    const assetLoss = holding.total_value_usd * shock;\n                    portfolioLoss += assetLoss;\n                }\n                \n                // Calculate exchange failure impact\n                const worstExchangeValue = Math.max(...Object.values(consolidated.exchange_breakdown).map(d => d || 0));\n                exchangeFailureLoss = worstExchangeValue * scenario.exchange_failure_probability;\n                \n                const totalLoss = portfolioLoss + exchangeFailureLoss;\n                const lossPercentage = (totalLoss / totalValue) * 100;\n                \n                stressResults[scenarioKey] = {\n                    scenario_name: scenario.name,\n                    market_loss_usd: portfolioLoss.toFixed(2),\n                    exchange_risk_loss_usd: exchangeFailureLoss.toFixed(2),\n                    total_loss_usd: totalLoss.toFixed(2),\n                    total_loss_percentage: lossPercentage.toFixed(2) + '%',\n                    remaining_value_usd: (totalValue + totalLoss).toFixed(2),\n                    severity: Math.abs(lossPercentage) > 50 ? 'EXTREME' :\n                             Math.abs(lossPercentage) > 30 ? 'HIGH' :\n                             Math.abs(lossPercentage) > 15 ? 'MEDIUM' : 'LOW'\n                };\n            }\n            \n            return stressResults;\n        }\n        \n        function generateMultiExchangeRiskRecommendations(riskMetrics) {\n            const recommendations = [];\n            \n            if (riskMetrics.exchange_concentration_risk.risk_level === 'HIGH') {\n                recommendations.push({\n                    priority: 'HIGH',\n                    category: 'Exchange Concentration',\n                    issue: 'High concentration on single exchange',\n                    action: 'Redistribute assets across multiple exchanges',\n                    target: 'No single exchange should hold >60% of portfolio'\n                });\n            }\n            \n            if (riskMetrics.operational_risk.operational_risk === 'HIGH') {\n                recommendations.push({\n                    priority: 'CRITICAL',\n                    category: 'Operational Risk',\n                    issue: 'Multiple exchange connectivity issues',\n                    action: 'Investigate and resolve exchange API issues',\n                    target: 'Maintain >80% exchange health ratio'\n                });\n            }\n            \n            if (riskMetrics.asset_concentration_risk.risk_level === 'EXTREME' || riskMetrics.asset_concentration_risk.risk_level === 'HIGH') {\n                recommendations.push({\n                    priority: 'HIGH',\n                    category: 'Asset Concentration',\n                    issue: `Largest position is ${riskMetrics.asset_concentration_risk.largest_position} of portfolio`,\n                    action: 'Diversify asset allocation across multiple cryptocurrencies',\n                    target: 'Reduce largest position to below 25% of total portfolio'\n                });\n            }\n            \n            if (riskMetrics.counterparty_risk.overall_rating === 'HIGH') {\n                recommendations.push({\n                    priority: 'MEDIUM',\n                    category: 'Counterparty Risk',\n                    issue: 'High counterparty risk exposure',\n                    action: 'Consider using more established exchanges or cold storage',\n                    target: 'Reduce counterparty risk to MEDIUM or below'\n                });\n            }\n            \n            return recommendations;\n        }\n        \n        async function optimizeMultiExchangeAllocation(strategy, mode, exchanges) {\n            console.log(`📈 Optimizing multi-exchange allocation with ${strategy} strategy in ${mode} mode...`);\n            \n            const portfolioData = await getMultiExchangePortfolio(exchanges);\n            const consolidated = portfolioData.multi_exchange_portfolio.consolidated;\n            \n            const optimizationResult = {\n                current_allocation: {},\n                recommended_allocation: {},\n                rebalancing_actions: [],\n                expected_improvement: {}\n            };\n            \n            // Get current allocation\n            for (const [asset, holding] of Object.entries(consolidated.holdings)) {\n                optimizationResult.current_allocation[asset] = holding.percentage.toFixed(2) + '%';\n            }\n            \n            // Generate optimized allocation based on strategy\n            switch (strategy) {\n                case 'risk_parity':\n                    optimizationResult.recommended_allocation = generateRiskParityAllocation(consolidated, mode);\n                    break;\n                case 'equal_weight':\n                    optimizationResult.recommended_allocation = generateEqualWeightAllocation(consolidated);\n                    break;\n                case 'max_sharpe':\n                    optimizationResult.recommended_allocation = generateMaxSharpeAllocation(consolidated, mode);\n                    break;\n                case 'min_variance':\n                    optimizationResult.recommended_allocation = generateMinVarianceAllocation(consolidated, mode);\n                    break;\n                case 'kelly_criterion':\n                    optimizationResult.recommended_allocation = generateKellyAllocation(consolidated, mode);\n                    break;\n                case 'adaptive':\n                    optimizationResult.recommended_allocation = generateAdaptiveAllocation(consolidated, mode);\n                    break;\n                default:\n                    optimizationResult.recommended_allocation = optimizationResult.current_allocation;\n            }\n            \n            // Generate rebalancing actions\n            for (const [asset, currentPct] of Object.entries(optimizationResult.current_allocation)) {\n                const current = parseFloat(currentPct);\n                const recommended = parseFloat(optimizationResult.recommended_allocation[asset] || '0');\n                const diff = recommended - current;\n                \n                if (Math.abs(diff) > 1) {\n                    optimizationResult.rebalancing_actions.push({\n                        asset: asset,\n                        action: diff > 0 ? 'BUY' : 'SELL',\n                        percentage_change: diff.toFixed(2) + '%',\n                        value_change_usd: (consolidated.total_value_usd * diff / 100).toFixed(2)\n                    });\n                }\n            }\n            \n            optimizationResult.expected_improvement = {\n                risk_reduction: '15-20%',\n                expected_return_increase: '5-10%',\n                diversification_improvement: '25%'\n            };\n            \n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                multi_exchange_optimization: optimizationResult,\n                strategy_used: strategy,\n                trading_mode: mode,\n                exchanges_optimized: exchanges\n            };\n        }\n        \n        function generateRiskParityAllocation(consolidated, mode) {\n            const allocation = {};\n            const assets = Object.keys(consolidated.holdings);\n            \n            assets.forEach(asset => {\n                const volatility = getAssetVolatility(asset);\n                const inverseVol = 1 / volatility;\n                allocation[asset] = inverseVol;\n            });\n            \n            // Normalize to 100%\n            const total = Object.values(allocation).reduce((sum, val) => sum + val, 0);\n            Object.keys(allocation).forEach(asset => {\n                allocation[asset] = ((allocation[asset] / total) * 100).toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function generateEqualWeightAllocation(consolidated) {\n            const allocation = {};\n            const assets = Object.keys(consolidated.holdings);\n            const equalWeight = 100 / assets.length;\n            \n            assets.forEach(asset => {\n                allocation[asset] = equalWeight.toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function generateMaxSharpeAllocation(consolidated, mode) {\n            const allocation = {};\n            const modeMultipliers = {\n                'conservative': 0.5,\n                'balanced': 1.0,\n                'aggressive': 1.5,\n                'beast_mode': 2.0\n            };\n            const multiplier = modeMultipliers[mode] || 1.0;\n            \n            // Simplified Sharpe optimization\n            const assets = Object.keys(consolidated.holdings);\n            assets.forEach(asset => {\n                const expectedReturn = getExpectedReturn(asset) * multiplier;\n                const volatility = getAssetVolatility(asset);\n                const sharpe = expectedReturn / volatility;\n                allocation[asset] = Math.max(0, sharpe);\n            });\n            \n            // Normalize to 100%\n            const total = Object.values(allocation).reduce((sum, val) => sum + val, 0);\n            Object.keys(allocation).forEach(asset => {\n                allocation[asset] = ((allocation[asset] / total) * 100).toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function generateMinVarianceAllocation(consolidated, mode) {\n            const allocation = {};\n            const assets = Object.keys(consolidated.holdings);\n            \n            // Inverse volatility weighting for minimum variance\n            assets.forEach(asset => {\n                const volatility = getAssetVolatility(asset);\n                allocation[asset] = 1 / (volatility * volatility);\n            });\n            \n            // Normalize to 100%\n            const total = Object.values(allocation).reduce((sum, val) => sum + val, 0);\n            Object.keys(allocation).forEach(asset => {\n                allocation[asset] = ((allocation[asset] / total) * 100).toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function generateKellyAllocation(consolidated, mode) {\n            const allocation = {};\n            const modeMultipliers = {\n                'conservative': 0.25,\n                'balanced': 0.5,\n                'aggressive': 0.75,\n                'beast_mode': 1.0\n            };\n            const kellyFraction = modeMultipliers[mode] || 0.5;\n            \n            const assets = Object.keys(consolidated.holdings);\n            assets.forEach(asset => {\n                const expectedReturn = getExpectedReturn(asset);\n                const volatility = getAssetVolatility(asset);\n                const kellyPercentage = (expectedReturn / (volatility * volatility)) * kellyFraction;\n                allocation[asset] = Math.max(0, Math.min(25, kellyPercentage));\n            });\n            \n            // Normalize to 100%\n            const total = Object.values(allocation).reduce((sum, val) => sum + val, 0);\n            Object.keys(allocation).forEach(asset => {\n                allocation[asset] = ((allocation[asset] / total) * 100).toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function generateAdaptiveAllocation(consolidated, mode) {\n            // Adaptive allocation based on current market conditions\n            const allocation = {};\n            const assets = Object.keys(consolidated.holdings);\n            \n            assets.forEach(asset => {\n                const currentWeight = consolidated.holdings[asset].percentage;\n                const targetWeight = getAdaptiveTargetWeight(asset, mode);\n                allocation[asset] = ((currentWeight + targetWeight) / 2).toFixed(2) + '%';\n            });\n            \n            return allocation;\n        }\n        \n        function getExpectedReturn(asset) {\n            const expectedReturns = {\n                'BTC': 0.15, 'ETH': 0.20, 'ADA': 0.25, 'SOL': 0.30,\n                'DOT': 0.25, 'LINK': 0.22, 'MATIC': 0.28, 'AVAX': 0.26,\n                'UNI': 0.24, 'LTC': 0.12, 'USD': 0.01, 'USDT': 0.01, 'USDC': 0.01,\n                'XRP': 0.18, 'DOGE': 0.35, 'SHIB': 0.40, 'BNB': 0.16, 'KCS': 0.20\n            };\n            return expectedReturns[asset] || 0.10;\n        }\n        \n        function getAdaptiveTargetWeight(asset, mode) {\n            const baseWeights = {\n                'BTC': 30, 'ETH': 25, 'USD': 10, 'USDT': 5, 'USDC': 5\n            };\n            \n            const modeAdjustments = {\n                'conservative': { 'BTC': 10, 'USD': 20 },\n                'balanced': {},\n                'aggressive': { 'BTC': -10, 'ETH': -5, 'SOL': 10 },\n                'beast_mode': { 'BTC': -15, 'ETH': -10, 'SOL': 15, 'ADA': 10 }\n            };\n            \n            const baseWeight = baseWeights[asset] || 5;\n            const adjustment = modeAdjustments[mode]?.[asset] || 0;\n            \n            return Math.max(0, Math.min(40, baseWeight + adjustment));\n        }\n        \n        async function calculateMultiExchangePositionSizing(opportunity, mode, exchanges) {\n    console.log(`📐 Calculating multi-exchange position sizing for ${mode} mode...`);\n    \n    let opp;\n    try {\n        opp = typeof opportunity === 'string' ? JSON.parse(opportunity) : opportunity;\n    } catch (error) {\n        throw new Error('Invalid opportunity format. Expected JSON.');\n    }\n    \n    // Get REAL portfolio data\n    const portfolioData = await getMultiExchangePortfolio(exchanges);\n    if (!portfolioData.success) {\n        throw new Error('Failed to get portfolio data for position sizing');\n    }\n    \n    const totalValue = portfolioData.multi_exchange_portfolio.consolidated.total_value_usd;\n    \n    // If portfolio is empty or very small, use conservative sizing\n    if (totalValue < 100) {\n        console.warn('⚠️ Portfolio value very low, using minimum position size');\n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            position_sizing: {\n                position_size_usd: 50, // Minimum $50 position\n                position_size_percentage: 5,\n                recommended_quantity: null, // Will be calculated by Trade Execution\n                confidence: opp.confidence || 75,\n                risk_level: 'LOW'\n            }\n        };\n    }\n    \n    const modeParameters = {\n        'conservative': { maxPositionPct: 2, confidence_threshold: 85, kelly_fraction: 0.25 },\n        'balanced': { maxPositionPct: 5, confidence_threshold: 75, kelly_fraction: 0.50 },\n        'aggressive': { maxPositionPct: 10, confidence_threshold: 65, kelly_fraction: 0.75 },\n        'beast_mode': { maxPositionPct: 15, confidence_threshold: 60, kelly_fraction: 1.00 }\n    };\n    \n    const params = modeParameters[mode] || modeParameters.balanced;\n    \n    // Kelly Criterion calculation\n    const confidence = opp.confidence || 75;\n    const expectedReturn = opp.expected_return || 10;\n    const winProbability = confidence / 100;\n    const lossProbability = 1 - winProbability;\n    const winAmount = expectedReturn / 100;\n    const lossAmount = 0.05; // Assume 5% stop loss\n    \n    const kellyPercentage = ((winProbability * winAmount) - (lossProbability * lossAmount)) / winAmount;\n    const adjustedKelly = kellyPercentage * params.kelly_fraction;\n    \n    // Final position size as percentage of portfolio\n    const positionPercentage = Math.min(\n        Math.max(adjustedKelly * 100, 0.5), // Min 0.5%\n        params.maxPositionPct // Max based on mode\n    );\n    \n    const positionSizeUSD = (totalValue * positionPercentage) / 100;\n    \n    // CRITICAL: Return USD amount, Trade Execution will convert to quantity\n    return {\n        success: true,\n        timestamp: new Date().toISOString(),\n        position_sizing: {\n            total_portfolio_value_usd: totalValue,\n            position_size_usd: positionSizeUSD,\n            position_size_percentage: positionPercentage,\n            kelly_percentage: adjustedKelly * 100,\n            confidence: confidence,\n            expected_return: expectedReturn,\n            risk_level: positionPercentage > 8 ? 'HIGH' : positionPercentage > 4 ? 'MEDIUM' : 'LOW',\n            trading_mode: mode\n        }\n    };\n}\n        \n        async function selectBestExchangeForTrade(symbol, tradeSize, exchanges) {\n            // Logic to select best exchange based on liquidity, fees, and current balances\n            let bestExchange = exchanges[0];\n            let bestScore = -1;\n            \n            for (const exchange of exchanges) {\n                let score = 100;\n                \n                // Factor in exchange fees\n                const fees = {\n                    'kraken': 0.26,\n                    'binance': 0.10,\n                    'kucoin': 0.10\n                };\n                score -= (fees[exchange] || 0.20) * 100;\n                \n                // Factor in liquidity (simplified)\n                const liquidityBonus = {\n                    'binance': 20,\n                    'kraken': 15,\n                    'kucoin': 10\n                };\n                score += liquidityBonus[exchange] || 0;\n                \n                if (score > bestScore) {\n                    bestScore = score;\n                    bestExchange = exchange;\n                }\n            }\n            \n            return bestExchange;\n        }\n        \n        async function analyzeMultiExchangeCorrelations(exchanges) {\n            console.log('📊 Analyzing multi-exchange correlations...');\n            \n            const portfolioData = await getMultiExchangePortfolio(exchanges);\n            const holdings = portfolioData.multi_exchange_portfolio.consolidated.holdings;\n            \n            const correlationMatrix = {};\n            const assets = Object.keys(holdings);\n            \n            // Generate correlation matrix (simplified)\n            assets.forEach(asset1 => {\n                correlationMatrix[asset1] = {};\n                assets.forEach(asset2 => {\n                    if (asset1 === asset2) {\n                        correlationMatrix[asset1][asset2] = 1.00;\n                    } else {\n                        correlationMatrix[asset1][asset2] = calculateAssetCorrelation(asset1, asset2);\n                    }\n                });\n            });\n            \n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                multi_exchange_correlations: {\n                    correlation_matrix: correlationMatrix,\n                    highly_correlated_pairs: findHighlyCorrelatedPairs(correlationMatrix),\n                    diversification_opportunities: findDiversificationOpportunities(correlationMatrix),\n                    exchange_correlation: calculateExchangeCorrelation(portfolioData.multi_exchange_portfolio.individual_portfolios)\n                }\n            };\n        }\n        \n        function calculateAssetCorrelation(asset1, asset2) {\n            // Simplified correlation calculation\n            const correlations = {\n                'BTC': { 'ETH': 0.85, 'ADA': 0.70, 'SOL': 0.75, 'USD': -0.10 },\n                'ETH': { 'BTC': 0.85, 'ADA': 0.80, 'SOL': 0.82, 'USD': -0.08 },\n                'ADA': { 'BTC': 0.70, 'ETH': 0.80, 'SOL': 0.78, 'USD': -0.05 },\n                'SOL': { 'BTC': 0.75, 'ETH': 0.82, 'ADA': 0.78, 'USD': -0.06 }\n            };\n            \n            return correlations[asset1]?.[asset2] || 0.50;\n        }\n        \n        function findHighlyCorrelatedPairs(correlationMatrix) {\n            const pairs = [];\n            const processed = new Set();\n            \n            Object.entries(correlationMatrix).forEach(([asset1, correlations]) => {\n                Object.entries(correlations).forEach(([asset2, correlation]) => {\n                    if (asset1 !== asset2 && correlation > 0.8 && !processed.has(`${asset2}-${asset1}`)) {\n                        pairs.push({\n                            pair: `${asset1}-${asset2}`,\n                            correlation: correlation\n                        });\n                        processed.add(`${asset1}-${asset2}`);\n                    }\n                });\n            });\n            \n            return pairs.sort((a, b) => b.correlation - a.correlation);\n        }\n        \n        function findDiversificationOpportunities(correlationMatrix) {\n            const opportunities = [];\n            const processed = new Set();\n            \n            Object.entries(correlationMatrix).forEach(([asset1, correlations]) => {\n                Object.entries(correlations).forEach(([asset2, correlation]) => {\n                    if (asset1 !== asset2 && correlation < 0.3 && !processed.has(`${asset2}-${asset1}`)) {\n                        opportunities.push({\n                            pair: `${asset1}-${asset2}`,\n                            correlation: correlation,\n                            benefit: 'Low correlation provides diversification'\n                        });\n                        processed.add(`${asset1}-${asset2}`);\n                    }\n                });\n            });\n            \n            return opportunities;\n        }\n        \n        function calculateExchangeCorrelation(exchangePortfolios) {\n            // Calculate how correlated the holdings are across exchanges\n            const exchangeList = Object.keys(exchangePortfolios || {}).filter(ex => !exchangePortfolios[ex].error);\n            \n            if (exchangeList.length < 2) {\n                return { message: 'Insufficient exchanges for correlation analysis' };\n            }\n            \n            return {\n                exchange_overlap: 'Medium',\n                recommendation: 'Consider diversifying holdings across exchanges'\n            };\n        }\n        \n        async function getCompleteMultiExchangeAssessment(strategy, mode, exchanges) {\n            console.log('🎯 Generating complete multi-exchange assessment...');\n            \n            try {\n                const [portfolio, riskAnalysis] = await Promise.all([\n                    getMultiExchangePortfolio(exchanges),\n                    performMultiExchangeRiskAnalysis(exchanges)\n                ]);\n                \n                const executiveSummary = {\n                    total_portfolio_value: portfolio.multi_exchange_portfolio.consolidated.total_value_usd,\n                    active_exchanges: Object.keys(portfolio.multi_exchange_portfolio.individual_portfolios).filter(ex => !portfolio.multi_exchange_portfolio.individual_portfolios[ex].error).length,\n                    total_assets: Object.keys(portfolio.multi_exchange_portfolio.consolidated.holdings).length,\n                    overall_risk_rating: calculateOverallRiskRating(riskAnalysis.multi_exchange_risk_analysis),\n                    cross_exchange_opportunities: findCrossExchangeOpportunities(portfolio.multi_exchange_portfolio.individual_portfolios).length,\n                    key_recommendations: extractKeyRecommendations(riskAnalysis.recommendations)\n                };\n                \n                return {\n                    success: true,\n                    timestamp: new Date().toISOString(),\n                    complete_multi_exchange_assessment: {\n                        executive_summary: executiveSummary,\n                        portfolio_data: portfolio.multi_exchange_portfolio,\n                        risk_analysis: riskAnalysis.multi_exchange_risk_analysis,\n                        exchange_health: assessExchangeHealth(portfolio.multi_exchange_portfolio.individual_portfolios),\n                        cross_exchange_opportunities: findCrossExchangeOpportunities(portfolio.multi_exchange_portfolio.individual_portfolios)\n                    },\n                    trading_mode: mode,\n                    optimization_strategy: strategy,\n                    exchanges_analyzed: exchanges\n                };\n                \n            } catch (error) {\n                console.error('Complete assessment error:', error);\n                throw error;\n            }\n        }\n        \n        function calculateOverallRiskRating(riskAnalysis) {\n            const riskFactors = [\n                riskAnalysis.exchange_concentration_risk.risk_level,\n                riskAnalysis.asset_concentration_risk.risk_level,\n                riskAnalysis.operational_risk.operational_risk,\n                riskAnalysis.liquidity_risk.risk_level\n            ];\n            \n            const riskScores = {\n                'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'EXTREME': 4\n            };\n            \n            const avgScore = riskFactors.reduce((sum, factor) => sum + (riskScores[factor] || 2), 0) / riskFactors.length;\n            \n            if (avgScore <= 1.5) return 'LOW';\n            if (avgScore <= 2.5) return 'MEDIUM';\n            if (avgScore <= 3.5) return 'HIGH';\n            return 'EXTREME';\n        }\n        \n        function extractKeyRecommendations(recommendations) {\n            // Extract top 3 recommendations from risk analysis\n            return recommendations.slice(0, 3).map(rec => rec.action);\n        }\n        \n        function parseExchangeFilter(filter) {\n          // Handle if filter is already an array\n          if (Array.isArray(filter)) {\n              return filter.map(ex => ex.toLowerCase());\n          }\n    \n          // Handle string inputs\n          if (typeof filter === 'string') {\n            if (filter === 'all') {\n              return ['kraken', 'binance', 'kucoin'];\n          } else if (filter.includes(',')) {\n              return filter.split(',').map(ex => ex.trim().toLowerCase());\n          } else {\n              return [filter.toLowerCase()];\n          }\n        }\n    \n    // Default fallback\n    return ['kraken', 'binance', 'kucoin'];\n        }\n        \n    } catch (error) {\n        console.error('❌ Multi-Exchange Portfolio Service error:', error);\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString(),\n            function_attempted: functionType\n        };\n    }\n}\n\n// ===== NEW ENHANCED RISK FUNCTIONS =====\n\nasync function adaptiveKellySizing(opportunity, tradingMode, exchanges) {\n    try {\n        console.log('🎯 Calculating adaptive Kelly position sizing...');\n        \n        // Get portfolio data for Kelly calculation\n        const portfolioData = await multiExchangePortfolioService('get_portfolio', null, null, null, exchanges);\n        if (!portfolioData.success) {\n            throw new Error('Failed to get portfolio data for Kelly sizing');\n        }\n        \n        const totalValue = portfolioData.multi_exchange_portfolio.consolidated.total_value_usd;\n        \n        // Simplified Kelly calculation - enhance with real trade history\n        const winRate = 0.55;  // 50-60% base win rate\n        const avgWin = 0.02 + Math.random() * 0.01; // 2-3% average win\n        const avgLoss = 0.01 + Math.random() * 0.005; // 1-1.5% average loss\n        const winLossRatio = avgWin / avgLoss;\n        \n        // Kelly: f = (bp - q) / b\n        const kellyFraction = (winLossRatio * winRate - (1 - winRate)) / winLossRatio;\n        \n        // Market regime adjustment\n        const regimeMultiplier = {\n            'conservative': 0.6,\n            'balanced': 1.0,\n            'aggressive': 1.3\n        }[tradingMode] || 1.0;\n        \n        const adjustedKelly = Math.max(0.01, Math.min(0.25, kellyFraction * regimeMultiplier));\n        const positionSize = totalValue * adjustedKelly;\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            kelly_sizing: {\n                kelly_fraction: kellyFraction,\n                adjusted_kelly: adjustedKelly,\n                regime_multiplier: regimeMultiplier,\n                position_size_usd: positionSize,\n                win_rate: winRate,\n                win_loss_ratio: winLossRatio,\n                confidence: winRate > 0.55 ? 'HIGH' : 'MEDIUM',\n                recommendation: adjustedKelly > 0.15 ? 'AGGRESSIVE' : adjustedKelly > 0.08 ? 'MODERATE' : 'CONSERVATIVE'\n            }\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\n// SURGICAL FIX 5: Enhanced portfolioHeatMonitor with better error handling\nasync function portfolioHeatMonitor(exchanges, maxDrawdownPercent = 0.15) {\n    try {\n        console.log('🌡️ Monitoring portfolio heat levels...');\n        \n        // Parse exchanges parameter with fallback - FIXED VERSION\n        const parsedExchanges = Array.isArray(exchanges) ? exchanges : \n                               typeof exchanges === 'string' ? [exchanges] : \n                               ['kraken', 'binance', 'kucoin'];\n        \n        console.log(`Analyzing portfolio across: ${parsedExchanges.join(', ')}`);\n        \n        // SCOPE FIX: Obtain data via service to avoid inner-scope dependency\n        let portfolioData;\n        try {\n            portfolioData = await multiExchangePortfolioService('get_portfolio', null, null, null, parsedExchanges);\n        } catch (portfolioError) {\n            console.error('Portfolio data error:', portfolioError);\n            // Return safe default instead of crashing\n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                portfolio_heat: {\n                    current_drawdown: 0,\n                    max_allowable_drawdown: maxDrawdownPercent,\n                    heat_level: 'UNKNOWN',\n                    concentration_risk: 0,\n                    total_value: 0,\n                    unrealized_pnl: 0,\n                    action_required: 'MONITOR',\n                    position_reduction_pct: 0,\n                    message: 'Portfolio data temporarily unavailable - continuing normal operations'\n                }\n            };\n        }\n        \n        if (!portfolioData.success) {\n            console.log('ℹ️ Portfolio heat monitor: No portfolio value detected');\n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                portfolio_heat: {\n                    current_drawdown: 0,\n                    max_allowable_drawdown: maxDrawdownPercent,\n                    heat_level: 'LOW',\n                    concentration_risk: 0,\n                    total_value: 0,\n                    unrealized_pnl: 0,\n                    action_required: 'NO_PORTFOLIO',\n                    position_reduction_pct: 0,\n                    message: 'No portfolio value detected - may be normal for new account'\n                }\n            };\n        }\n        \n        const consolidated = portfolioData.multi_exchange_portfolio.consolidated;\n        const totalValue = consolidated.total_value_usd || 0;\n        \n        if (totalValue <= 0) {\n            console.log('ℹ️ Portfolio heat monitor: Zero portfolio value');\n            return {\n                success: true,\n                timestamp: new Date().toISOString(),\n                portfolio_heat: {\n                    current_drawdown: 0,\n                    max_allowable_drawdown: maxDrawdownPercent,\n                    heat_level: 'LOW',\n                    concentration_risk: 0,\n                    total_value: 0,\n                    unrealized_pnl: 0,\n                    action_required: 'NO_PORTFOLIO',\n                    position_reduction_pct: 0,\n                    message: 'No portfolio value detected - may be normal for new account'\n                }\n            };\n        }\n        \n        // Calculate risk metrics from consolidated data\n        const holdings = Object.values(consolidated.holdings || {});\n        const maxPosition = holdings.length > 0 ? \n            holdings.reduce((max, holding) => Math.max(max, holding.percentage || 0), 0) : 0;\n        \n        const concentrationRisk = maxPosition / 100;\n        const estimatedDrawdown = Math.min(concentrationRisk * 0.3, 0.05);\n        const unrealizedPnL = -estimatedDrawdown * totalValue;\n        \n        // Risk-based action determination\n        const heatLevel = estimatedDrawdown > maxDrawdownPercent * 0.8 ? 'HIGH' : \n                         estimatedDrawdown > maxDrawdownPercent * 0.5 ? 'MEDIUM' : 'LOW';\n        \n        let actionRequired = 'MONITOR';\n        let positionReductionPct = 0;\n        \n        if (estimatedDrawdown > maxDrawdownPercent) {\n            actionRequired = 'REDUCE_POSITIONS';\n            positionReductionPct = Math.min(0.5, (estimatedDrawdown - maxDrawdownPercent) * 2);\n        } else if (concentrationRisk > 0.4) {\n            actionRequired = 'DIVERSIFY';\n        }\n        \n        // Count successful exchanges\n        const successfulExchanges = Object.keys(portfolioData.multi_exchange_portfolio.individual_portfolios || {})\n            .filter(ex => {\n                const portfolio = portfolioData.multi_exchange_portfolio.individual_portfolios[ex];\n                return portfolio && portfolio.success;\n            }).length;\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            portfolio_heat: {\n                current_drawdown: estimatedDrawdown,\n                max_allowable_drawdown: maxDrawdownPercent,\n                heat_level: heatLevel,\n                concentration_risk: concentrationRisk,\n                total_value: totalValue,\n                unrealized_pnl: unrealizedPnL,\n                action_required: actionRequired,\n                position_reduction_pct: positionReductionPct,\n                largest_position_pct: maxPosition,\n                number_of_positions: holdings.length,\n                exchanges_analyzed: parsedExchanges,\n                successful_exchanges: successfulExchanges\n            }\n        };\n        \n    } catch (error) {\n        console.error('⚠️ Portfolio heat monitor error:', error);\n        \n        // Graceful degradation instead of system shutdown\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString(),\n            portfolio_heat: {\n                current_drawdown: 0,\n                max_allowable_drawdown: maxDrawdownPercent,\n                heat_level: 'UNKNOWN',\n                concentration_risk: 0,\n                total_value: 0,\n                unrealized_pnl: 0,\n                action_required: 'MONITOR',\n                position_reduction_pct: 0,\n                message: 'Heat monitoring temporarily unavailable - continuing normal operations'\n            }\n        };\n    }\n}\n\nasync function adaptiveExitLevels(opportunity, tradingMode) {\n    try {\n        console.log('🎯 Calculating adaptive exit levels...');\n        \n        if (!opportunity || typeof opportunity === 'string') {\n            return {\n                success: false,\n                error: 'Valid opportunity object required for exit level calculation'\n            };\n        }\n        \n        const entryPrice = opportunity.entry_price || opportunity.price || 100; // Default for testing\n        const direction = opportunity.direction || opportunity.action || 'LONG';\n        const confidence = opportunity.confidence || 'MEDIUM';\n        \n        // Simulate ATR calculation - replace with real volatility data\n        const atr = entryPrice * 0.015;// 1-2% ATR\n        \n        // Calculate base levels\n        const baseStopDistance = atr * 1.5;\n        const baseTakeDistance = atr * 2.5;\n        \n        let stopLoss, takeProfit;\n        \n        if (direction.toUpperCase().includes('LONG') || direction.toUpperCase() === 'BUY') {\n            stopLoss = entryPrice - baseStopDistance;\n            takeProfit = entryPrice + baseTakeDistance;\n        } else {\n            stopLoss = entryPrice + baseStopDistance;\n            takeProfit = entryPrice - baseTakeDistance;\n        }\n        \n        // Confidence-based adjustments\n        const confidenceMultiplier = {\n            'HIGH': 1.2,\n            'MEDIUM': 1.0,\n            'LOW': 0.7\n        }[confidence.toUpperCase()] || 1.0;\n        \n        // Adjust take profit based on confidence\n        if (direction.toUpperCase().includes('LONG') || direction.toUpperCase() === 'BUY') {\n            takeProfit = entryPrice + (takeProfit - entryPrice) * confidenceMultiplier;\n        } else {\n            takeProfit = entryPrice - (entryPrice - takeProfit) * confidenceMultiplier;\n        }\n        \n        const riskRewardRatio = Math.abs(takeProfit - entryPrice) / Math.abs(entryPrice - stopLoss);\n        \n        return {\n            success: true,\n            timestamp: new Date().toISOString(),\n            exit_levels: {\n                entry_price: entryPrice,\n                stop_loss: stopLoss,\n                take_profit: takeProfit,\n                direction: direction,\n                risk_reward_ratio: riskRewardRatio,\n                stop_distance_pct: Math.abs(entryPrice - stopLoss) / entryPrice * 100,\n                take_distance_pct: Math.abs(takeProfit - entryPrice) / entryPrice * 100,\n                confidence_multiplier: confidenceMultiplier,\n                atr_value: atr,\n                quality_score: riskRewardRatio >= 2.0 && confidence === 'HIGH' ? 'A+' :\n                              riskRewardRatio >= 1.5 ? 'A' : \n                              riskRewardRatio >= 1.0 ? 'B' : 'C'\n            }\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\n// Execute the function with safe parameter handling\nreturn await multiExchangePortfolioService(\n    $function,\n    (typeof $strategy !== 'undefined') ? $strategy : null,\n    (typeof $opportunity !== 'undefined') ? $opportunity : null,\n    (typeof $mode !== 'undefined') ? $mode : null,\n    (typeof $exchange_filter !== 'undefined') ? $exchange_filter : null\n);",
  "workspaceId": "9b1b9829-f76f-472f-867f-4bac66fb62c0"
}