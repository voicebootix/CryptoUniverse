{
  "name": "Multi_AI_Consensus_Service",
  "description": "V3: Advanced multi-AI decision engine using GPT-4, Claude, and Gemini for institutional-grade trading consensus with confidence scoring and cost optimization",
  "color": "linear-gradient(rgb(55,253,26), rgb(156,199,187))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"function\",\"type\":\"string\",\"description\":\"Function: 'analyze_opportunity', 'validate_trade', 'risk_assessment', 'portfolio_review', 'market_analysis', 'consensus_decision'\",\"required\":true},{\"id\":1,\"property\":\"analysis_request\",\"type\":\"string\",\"description\":\"Analysis request or opportunity data in JSON format\",\"required\":true},{\"id\":2,\"property\":\"confidence_threshold\",\"type\":\"string\",\"description\":\"Minimum confidence threshold: '70', '75', '80', '85' (default: 80)\",\"required\":false},{\"id\":3,\"property\":\"ai_models\",\"type\":\"string\",\"description\":\"AI models to use: 'all', 'gpt4_claude', 'cost_optimized' (default: all)\",\"required\":false}]",
  "func": "// MULTI AI CONSENSUS SERVICE - Production-Grade Multi-AI Decision Engine\nconst fetch = require('node-fetch');\n\n// ===== PRODUCTION CONFIGURATION =====\nconst CONFIG = {\n    MAX_RETRIES: 3,\n    INITIAL_RETRY_DELAY: 1000,\n    MAX_RESPONSE_LENGTH: 2000,\n    REQUEST_TIMEOUT: 30000,\n    CIRCUIT_BREAKER_THRESHOLD: 5,\n    CIRCUIT_BREAKER_RESET_TIME: 300000, // 5 minutes\n    COST_OPTIMIZATION_ENABLED: true,\n    JSON_SANITIZATION_ENABLED: true\n};\n\n// Circuit breaker state\nconst circuitBreaker = {\n    gpt4: { failures: 0, lastFailure: null, isOpen: false },\n    claude: { failures: 0, lastFailure: null, isOpen: false },\n    gemini: { failures: 0, lastFailure: null, isOpen: false }\n};\n\nasync function multiAIConsensusService(functionType, analysisRequest, confidenceThreshold, aiModels) {\n    const startTime = Date.now();\n    const requestId = generateRequestId();\n    \n    console.log(`🤖 Multi AI Consensus Service [${requestId}] - Function: ${functionType}`);\n    \n    // ===== CORE FUNCTIONS ===== (MOVED TO TOP FOR ACCESSIBILITY)\n    \n    async function analyzeOpportunity(requestData, threshold, models, requestId) {\n        console.log(`🎯 Analyzing trading opportunity [${requestId}]...`);\n        \n        let request;\n        try {\n            request = typeof requestData === 'string' ? JSON.parse(requestData) : requestData;\n        } catch (error) {\n            throw new Error('Invalid analysis request format. Expected valid JSON.');\n        }\n        \n        const analysisPrompt = `\n        As an expert institutional trading analyst, analyze this trading opportunity:\n        ${JSON.stringify(request, null, 2)}\n        \n        Provide detailed analysis focusing on:\n        1. Entry/exit strategy\n        2. Risk/reward analysis\n        3. Market conditions assessment\n        4. Position sizing recommendations\n        5. Confidence level (0-100)\n        \n        Respond with valid JSON in this format:\n        {\n            \"decision\": \"BUY|SELL|HOLD|AVOID\",\n            \"confidence\": 85,\n            \"reasoning\": \"detailed analysis\",\n            \"risk_level\": \"LOW|MEDIUM|HIGH\",\n            \"expected_return\": 8.5,\n            \"time_horizon\": \"1-7 days\",\n            \"key_factors\": [\"factor1\", \"factor2\", \"factor3\"],\n            \"stop_loss\": 95000,\n            \"take_profit\": 125000,\n            \"position_size_percent\": 15\n        }\n        `;\n        \n        const aiAnalyses = await runMultiAIAnalysis(analysisPrompt, models, requestId);\n        const consensus = await calculateConsensus(aiAnalyses, threshold);\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            opportunity_analysis: {\n                request: request,\n                ai_analyses: aiAnalyses,\n                consensus: consensus,\n                confidence_threshold: threshold,\n                models_used: models,\n                recommendation: consensus.overall_confidence >= threshold ? 'PROCEED' : 'REJECT'\n            }\n        };\n    }\n    \n    async function validateTrade(requestData, threshold, models, requestId) {\n        console.log(`✅ Validating trade decision [${requestId}]...`);\n        \n        let request;\n        try {\n            request = typeof requestData === 'string' ? JSON.parse(requestData) : requestData;\n        } catch (error) {\n            throw new Error('Invalid trade validation request format. Expected valid JSON.');\n        }\n        \n        const validationPrompt = `\n        As a risk management expert, validate this trade request:\n        ${JSON.stringify(request, null, 2)}\n        \n        Evaluate:\n        1. Trade parameters validity\n        2. Risk management adequacy\n        3. Market timing appropriateness\n        4. Position sizing rationality\n        5. Potential drawbacks or risks\n        \n        Respond with valid JSON:\n        {\n            \"validation_result\": \"APPROVED|REJECTED|CONDITIONAL\",\n            \"confidence\": 90,\n            \"risk_score\": 65,\n            \"concerns\": [\"concern1\", \"concern2\"],\n            \"recommendations\": [\"rec1\", \"rec2\"],\n            \"adjusted_parameters\": {\n                \"position_size\": 0.8,\n                \"stop_loss\": 94000\n            }\n        }\n        `;\n        \n        const aiAnalyses = await runMultiAIAnalysis(validationPrompt, models, requestId);\n        const consensus = await calculateValidationConsensus(aiAnalyses, threshold);\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            trade_validation: {\n                request: request,\n                ai_validations: aiAnalyses,\n                consensus: consensus,\n                final_decision: consensus.overall_confidence >= threshold ? 'VALIDATED' : 'REJECTED',\n                adjusted_trade: consensus.adjusted_parameters\n            }\n        };\n    }\n    \n    async function performRiskAssessment(requestData, threshold, models, requestId) {\n        console.log(`🛡️ Performing risk assessment [${requestId}]...`);\n        \n        let request;\n        try {\n            request = typeof requestData === 'string' ? JSON.parse(requestData) : requestData;\n        } catch (error) {\n            throw new Error('Invalid risk assessment request format. Expected valid JSON.');\n        }\n        \n        const riskPrompt = `\n        As a quantitative risk analyst, assess the risk profile of:\n        ${JSON.stringify(request, null, 2)}\n        \n        Analyze:\n        1. Market risk factors\n        2. Liquidity risk\n        3. Concentration risk\n        4. Correlation risk\n        5. Tail risk events\n        \n        Respond with valid JSON:\n        {\n            \"overall_risk_score\": 75,\n            \"confidence\": 88,\n            \"risk_breakdown\": {\n                \"market_risk\": 70,\n                \"liquidity_risk\": 30,\n                \"concentration_risk\": 85,\n                \"correlation_risk\": 60\n            },\n            \"risk_factors\": [\"factor1\", \"factor2\"],\n            \"mitigation_strategies\": [\"strategy1\", \"strategy2\"],\n            \"maximum_position_size\": 12\n        }\n        `;\n        \n        const aiAnalyses = await runMultiAIAnalysis(riskPrompt, models, requestId);\n        const consensus = await calculateRiskConsensus(aiAnalyses, threshold);\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            risk_assessment: {\n                request: request,\n                ai_risk_analyses: aiAnalyses,\n                consensus: consensus,\n                risk_rating: consensus.overall_risk_score > 80 ? 'HIGH' : consensus.overall_risk_score > 50 ? 'MEDIUM' : 'LOW'\n            }\n        };\n    }\n    \n    async function reviewPortfolio(requestData, threshold, models, requestId) {\n        console.log(`📊 Reviewing portfolio [${requestId}]...`);\n        \n        let request;\n        try {\n            request = typeof requestData === 'string' ? JSON.parse(requestData) : requestData;\n        } catch (error) {\n            throw new Error('Invalid portfolio review request format. Expected valid JSON.');\n        }\n        \n        const portfolioPrompt = `\n        As a portfolio management expert, review this portfolio:\n        ${JSON.stringify(request, null, 2)}\n        \n        Evaluate:\n        1. Asset allocation efficiency\n        2. Risk-return optimization\n        3. Diversification adequacy\n        4. Rebalancing needs\n        5. Performance potential\n        \n        Respond with valid JSON:\n        {\n            \"portfolio_score\": 78,\n            \"confidence\": 85,\n            \"strengths\": [\"strength1\", \"strength2\"],\n            \"weaknesses\": [\"weakness1\", \"weakness2\"],\n            \"rebalancing_recommendations\": {\n                \"BTC\": 35,\n                \"ETH\": 30,\n                \"SOL\": 20,\n                \"CASH\": 15\n            },\n            \"expected_annual_return\": 45,\n            \"portfolio_volatility\": 32\n        }\n        `;\n        \n        const aiAnalyses = await runMultiAIAnalysis(portfolioPrompt, models, requestId);\n        const consensus = await calculatePortfolioConsensus(aiAnalyses, threshold);\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            portfolio_review: {\n                request: request,\n                ai_portfolio_analyses: aiAnalyses,\n                consensus: consensus,\n                optimization_needed: consensus.portfolio_score < 70\n            }\n        };\n    }\n    \n    async function analyzeMarket(requestData, threshold, models, requestId) {\n        console.log(`🌍 Analyzing market conditions [${requestId}]...`);\n        \n        let request;\n        try {\n            request = typeof requestData === 'string' ? JSON.parse(requestData) : requestData;\n        } catch (error) {\n            throw new Error('Invalid market analysis request format. Expected valid JSON.');\n        }\n        \n        const marketPrompt = `\n        As a macro market analyst, analyze current market conditions:\n        ${JSON.stringify(request, null, 2)}\n        \n        Assess:\n        1. Market sentiment and trends\n        2. Technical indicators\n        3. Fundamental drivers\n        4. Risk factors\n        5. Trading opportunities\n        \n        Respond with valid JSON:\n        {\n            \"market_sentiment\": \"BULLISH|BEARISH|NEUTRAL\",\n            \"confidence\": 82,\n            \"trend_strength\": 75,\n            \"volatility_forecast\": \"HIGH|MEDIUM|LOW\",\n            \"key_drivers\": [\"driver1\", \"driver2\"],\n            \"support_levels\": [115000, 110000],\n            \"resistance_levels\": [125000, 130000],\n            \"trading_bias\": \"LONG|SHORT|NEUTRAL\"\n        }\n        `;\n        \n        const aiAnalyses = await runMultiAIAnalysis(marketPrompt, models, requestId);\n        const consensus = await calculateMarketConsensus(aiAnalyses, threshold);\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            market_analysis: {\n                request: request,\n                ai_market_analyses: aiAnalyses,\n                consensus: consensus,\n                trading_environment: consensus.overall_confidence >= threshold ? 'FAVORABLE' : 'CHALLENGING'\n            }\n        };\n    }\n    \n    async function makeConsensusDecision(requestData, threshold, models, requestId) {\n    console.log(`🎯 Making consensus decision [${requestId}]...`);\n    \n    let request;\n    try {\n        // ENHANCED: Multi-layer JSON parsing with recovery\n        request = parseAndSanitizeRequestData(requestData);\n    } catch (error) {\n        console.warn(`⚠️ JSON parsing failed, attempting recovery: ${error.message}`);\n        \n        // FALLBACK: Create valid structure from available data\n        request = createFallbackRequestStructure(requestData);\n        \n        if (!request) {\n            throw new Error('Invalid consensus request format. Expected valid JSON.');\n        }\n    }\n    \n    try {\n        // Run comprehensive analysis\n        const [opportunityAnalysis, riskAssessment, marketAnalysis] = await Promise.all([\n            analyzeOpportunity(request, threshold, models, requestId),\n            performRiskAssessment(request, threshold, models, requestId),\n            analyzeMarket(request, threshold, models, requestId)\n        ]);\n        \n        // Calculate final consensus\n        const finalConsensus = {\n            decision_confidence: calculateOverallConfidence(opportunityAnalysis, riskAssessment, marketAnalysis),\n            recommendation: 'PENDING',\n            reasoning: [],\n            risk_adjusted_score: 0\n        };\n        \n        // Determine final recommendation\n        const opportunityConf = opportunityAnalysis.opportunity_analysis.consensus.overall_confidence;\n        const riskScore = riskAssessment.risk_assessment.consensus.overall_risk_score;\n        const marketConf = marketAnalysis.market_analysis.consensus.overall_confidence;\n        \n        finalConsensus.risk_adjusted_score = (opportunityConf + marketConf) / 2 - (riskScore * 0.3);\n        \n        if (finalConsensus.decision_confidence >= threshold && finalConsensus.risk_adjusted_score >= 60) {\n            finalConsensus.recommendation = 'EXECUTE';\n            finalConsensus.reasoning.push('High confidence across all AI models');\n        } else if (finalConsensus.decision_confidence >= threshold * 0.8) {\n            finalConsensus.recommendation = 'CONSIDER';\n            finalConsensus.reasoning.push('Moderate confidence, proceed with caution');\n        } else {\n            finalConsensus.recommendation = 'REJECT';\n            finalConsensus.reasoning.push('Insufficient confidence or high risk');\n        }\n        \n        return {\n            success: true,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            consensus_decision: {\n                input_analysis: request,\n                opportunity_analysis: opportunityAnalysis,\n                risk_assessment: riskAssessment,\n                market_analysis: marketAnalysis,\n                final_consensus: finalConsensus,\n                confidence_threshold: threshold,\n                models_used: models\n            }\n        };\n        \n    } catch (analysisError) {\n        console.error(`❌ Consensus analysis failed: ${analysisError.message}`);\n        \n        // Return failed consensus with reasoning\n        return {\n            success: false,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            error: analysisError.message,\n            consensus_decision: {\n                recommendation: 'REJECT',\n                reasoning: ['Analysis failed due to data processing error'],\n                confidence: 0\n            }\n        };\n    }\n}\n\n// NEW: Enhanced JSON parsing with recovery\nfunction parseAndSanitizeRequestData(requestData) {\n    if (!requestData) {\n        throw new Error('No request data provided');\n    }\n    \n    // If already an object, validate and return\n    if (typeof requestData === 'object' && requestData !== null) {\n        return requestData;\n    }\n    \n    let cleanData = requestData;\n    \n    // Step 1: Handle string data\n    if (typeof requestData === 'string') {\n        // Remove common JSON formatting issues\n        cleanData = requestData\n            .replace(/```json\\s*/g, '')\n            .replace(/```\\s*/g, '')\n            .replace(/^\\s*[\"']|[\"']\\s*$/g, '') // Remove surrounding quotes\n            .trim();\n        \n        // Try direct parse first\n        try {\n            return JSON.parse(cleanData);\n        } catch (e) {\n            console.warn('Direct parse failed, attempting cleanup...');\n        }\n        \n        // Step 2: Advanced cleanup\n        cleanData = cleanData\n            .replace(/\\\\n/g, ' ')\n            .replace(/\\\\t/g, ' ')\n            .replace(/\\\\r/g, ' ')\n            .replace(/([^\\\\])\"/g, '$1\\\\\"') // Escape unescaped quotes\n            .replace(/,\\s*}/g, '}') // Remove trailing commas\n            .replace(/,\\s*]/g, ']');\n        \n        // Try parse again\n        try {\n            return JSON.parse(cleanData);\n        } catch (e) {\n            console.warn('Advanced cleanup failed, extracting JSON...');\n        }\n        \n        // Step 3: Extract JSON from mixed content\n        const jsonMatch = cleanData.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n            try {\n                return JSON.parse(jsonMatch[0]);\n            } catch (e) {\n                console.warn('JSON extraction failed');\n            }\n        }\n    }\n    \n    throw new Error('Unable to parse request data as JSON');\n}\n\n// NEW: Fallback structure creation\nfunction createFallbackRequestStructure(requestData) {\n    console.log('🔧 Creating fallback request structure...');\n    \n    const fallback = {\n        timestamp: new Date().toISOString(),\n        source: 'fallback_generator',\n        market_intelligence: {},\n        risk_metrics: {},\n        alpha_signals: {},\n        arbitrage_signals: {},\n        trading_mode: 'balanced',\n        system_health: 'DEGRADED'\n    };\n    \n    // Try to extract any useful data from the corrupted input\n    if (typeof requestData === 'string') {\n        // Extract any numeric values\n        const numbers = requestData.match(/[\\d.]+/g);\n        if (numbers && numbers.length > 0) {\n            fallback.confidence = Math.min(parseFloat(numbers[0]) || 70, 100);\n        }\n        \n        // Extract any symbol references\n        const symbolMatch = requestData.match(/(BTC|ETH|SOL|ADA|DOT|LINK|MATIC)/i);\n        if (symbolMatch) {\n            fallback.symbol = symbolMatch[0].toUpperCase();\n        }\n    }\n    \n    return fallback;\n}\n    \n    // ===== HELPER FUNCTIONS =====\n    \n    async function runMultiAIAnalysis(prompt, models, requestId) {\n        const results = {\n            gpt4: { status: 'not_attempted', cost: 0 },\n            claude: { status: 'not_attempted', cost: 0 },\n            gemini: { status: 'not_attempted', cost: 0 }\n        };\n        \n        // Cost optimization based on models parameter\n        const shouldUseGPT4 = true;\n        const shouldUseClaude = true;\n        const shouldUseGemini = true;\n        \n        const apiCalls = [];\n        \n        // GPT-4 Analysis\n        if (shouldUseGPT4) {\n            apiCalls.push(\n                callAIWithRetry('gpt4', prompt)\n                    .then(result => { results.gpt4 = { status: 'success', ...result }; })\n                    .catch(error => { results.gpt4 = { status: 'error', error: error.message }; })\n            );\n        }\n        \n        // Claude Analysis\n        if (shouldUseClaude) {\n            apiCalls.push(\n                callAIWithRetry('claude', prompt)\n                    .then(result => { results.claude = { status: 'success', ...result }; })\n                    .catch(error => { results.claude = { status: 'error', error: error.message }; })\n            );\n        }\n        \n        // Gemini Analysis\n        if (shouldUseGemini) {\n            apiCalls.push(\n                callAIWithRetry('gemini', prompt)\n                    .then(result => { results.gemini = { status: 'success', ...result }; })\n                    .catch(error => { results.gemini = { status: 'error', error: error.message }; })\n            );\n        }\n        \n        // Wait for all API calls to complete\n        await Promise.all(apiCalls);\n        \n        console.log(`📊 AI Analysis Results [${requestId}]:`, {\n            gpt4: results.gpt4.status,\n            claude: results.claude.status, \n            gemini: results.gemini.status\n        });\n        \n        return results;\n    }\n    \n    async function calculateConsensus(aiAnalyses, threshold) {\n        const validAnalyses = [];\n        let totalCost = 0;\n        \n        // Collect valid analyses\n        Object.entries(aiAnalyses).forEach(([model, result]) => {\n            if (result.status === 'success' && result.analysis) {\n                validAnalyses.push({ model, ...result.analysis });\n                totalCost += result.cost || 0;\n            }\n        });\n        \n        if (validAnalyses.length === 0) {\n            return {\n                overall_confidence: 0,\n                consensus_decision: 'INSUFFICIENT_DATA',\n                agreement_level: 0,\n                cost_usd: totalCost,\n                error: 'No valid AI analyses received'\n            };\n        }\n        \n        // Calculate consensus\n        const decisions = validAnalyses.map(a => a.decision);\n        const confidences = validAnalyses.map(a => a.confidence || 0);\n        \n        // Find most common decision\n        const decisionCounts = {};\n        decisions.forEach(d => {\n            decisionCounts[d] = (decisionCounts[d] || 0) + 1;\n        });\n        \n        const consensusDecision = Object.entries(decisionCounts)\n            .sort(([,a], [,b]) => b - a)[0][0];\n        \n        // Calculate average confidence\n        const avgConfidence = confidences.reduce((sum, c) => sum + c, 0) / confidences.length;\n        \n        // Calculate agreement level\n        const agreementLevel = (decisionCounts[consensusDecision] / validAnalyses.length) * 100;\n        \n        return {\n            overall_confidence: Math.round(avgConfidence),\n            consensus_decision: consensusDecision,\n            agreement_level: Math.round(agreementLevel),\n            individual_analyses: validAnalyses,\n            models_successful: validAnalyses.length,\n            cost_usd: totalCost.toFixed(4),\n            confidence_threshold_met: avgConfidence >= threshold\n        };\n    }\n    \n    async function calculateValidationConsensus(aiAnalyses, threshold) {\n        const validAnalyses = [];\n        let totalCost = 0;\n        \n        Object.entries(aiAnalyses).forEach(([model, result]) => {\n            if (result.status === 'success' && result.analysis) {\n                validAnalyses.push({ model, ...result.analysis });\n                totalCost += result.cost || 0;\n            }\n        });\n        \n        if (validAnalyses.length === 0) {\n            return {\n                overall_confidence: 0,\n                validation_result: 'REJECTED',\n                cost_usd: totalCost\n            };\n        }\n        \n        const approvals = validAnalyses.filter(a => a.validation_result === 'APPROVED').length;\n        const avgConfidence = validAnalyses.reduce((sum, a) => sum + (a.confidence || 0), 0) / validAnalyses.length;\n        \n        return {\n            overall_confidence: Math.round(avgConfidence),\n            validation_result: approvals >= validAnalyses.length / 2 ? 'APPROVED' : 'REJECTED',\n            approval_rate: (approvals / validAnalyses.length) * 100,\n            individual_validations: validAnalyses,\n            cost_usd: totalCost.toFixed(4),\n            adjusted_parameters: validAnalyses[0]?.adjusted_parameters || {}\n        };\n    }\n    \n    async function calculateRiskConsensus(aiAnalyses, threshold) {\n        const validAnalyses = [];\n        let totalCost = 0;\n        \n        Object.entries(aiAnalyses).forEach(([model, result]) => {\n            if (result.status === 'success' && result.analysis) {\n                validAnalyses.push({ model, ...result.analysis });\n                totalCost += result.cost || 0;\n            }\n        });\n        \n        if (validAnalyses.length === 0) {\n            return {\n                overall_risk_score: 100,\n                overall_confidence: 0,\n                cost_usd: totalCost\n            };\n        }\n        \n        const avgRiskScore = validAnalyses.reduce((sum, a) => sum + (a.overall_risk_score || 0), 0) / validAnalyses.length;\n        const avgConfidence = validAnalyses.reduce((sum, a) => sum + (a.confidence || 0), 0) / validAnalyses.length;\n        \n        return {\n            overall_risk_score: Math.round(avgRiskScore),\n            overall_confidence: Math.round(avgConfidence),\n            individual_risk_analyses: validAnalyses,\n            cost_usd: totalCost.toFixed(4),\n            risk_factors: validAnalyses.flatMap(a => a.risk_factors || []),\n            mitigation_strategies: validAnalyses.flatMap(a => a.mitigation_strategies || [])\n        };\n    }\n    \n    async function calculatePortfolioConsensus(aiAnalyses, threshold) {\n        const validAnalyses = [];\n        let totalCost = 0;\n        \n        Object.entries(aiAnalyses).forEach(([model, result]) => {\n            if (result.status === 'success' && result.analysis) {\n                validAnalyses.push({ model, ...result.analysis });\n                totalCost += result.cost || 0;\n            }\n        });\n        \n        if (validAnalyses.length === 0) {\n            return {\n                portfolio_score: 0,\n                overall_confidence: 0,\n                cost_usd: totalCost\n            };\n        }\n        \n        const avgPortfolioScore = validAnalyses.reduce((sum, a) => sum + (a.portfolio_score || 0), 0) / validAnalyses.length;\n        const avgConfidence = validAnalyses.reduce((sum, a) => sum + (a.confidence || 0), 0) / validAnalyses.length;\n        \n        return {\n            portfolio_score: Math.round(avgPortfolioScore),\n            overall_confidence: Math.round(avgConfidence),\n            individual_portfolio_analyses: validAnalyses,\n            cost_usd: totalCost.toFixed(4),\n            consensus_recommendations: validAnalyses[0]?.rebalancing_recommendations || {}\n        };\n    }\n    \n    async function calculateMarketConsensus(aiAnalyses, threshold) {\n        const validAnalyses = [];\n        let totalCost = 0;\n        \n        Object.entries(aiAnalyses).forEach(([model, result]) => {\n            if (result.status === 'success' && result.analysis) {\n                validAnalyses.push({ model, ...result.analysis });\n                totalCost += result.cost || 0;\n            }\n        });\n        \n        if (validAnalyses.length === 0) {\n            return {\n                market_sentiment: 'NEUTRAL',\n                overall_confidence: 0,\n                cost_usd: totalCost\n            };\n        }\n        \n        // Find consensus sentiment\n        const sentiments = validAnalyses.map(a => a.market_sentiment);\n        const sentimentCounts = {};\n        sentiments.forEach(s => {\n            sentimentCounts[s] = (sentimentCounts[s] || 0) + 1;\n        });\n        \n        const consensusSentiment = Object.entries(sentimentCounts)\n            .sort(([,a], [,b]) => b - a)[0][0];\n        \n        const avgConfidence = validAnalyses.reduce((sum, a) => sum + (a.confidence || 0), 0) / validAnalyses.length;\n        \n        return {\n            market_sentiment: consensusSentiment,\n            overall_confidence: Math.round(avgConfidence),\n            individual_market_analyses: validAnalyses,\n            cost_usd: totalCost.toFixed(4),\n            trading_bias: validAnalyses[0]?.trading_bias || 'NEUTRAL'\n        };\n    }\n    \n    function calculateOverallConfidence(opportunityAnalysis, riskAssessment, marketAnalysis) {\n        const opportunityConf = opportunityAnalysis.opportunity_analysis.consensus.overall_confidence;\n        const riskConf = riskAssessment.risk_assessment.consensus.overall_confidence;\n        const marketConf = marketAnalysis.market_analysis.consensus.overall_confidence;\n        \n        // Weighted average: opportunity 40%, market 35%, risk 25%\n        return Math.round((opportunityConf * 0.4) + (marketConf * 0.35) + (riskConf * 0.25));\n    }\n    \n    try {\n        const threshold = parseInt(confidenceThreshold || '80');\n        const models = aiModels || 'all';\n        \n        // Route to specific function (NOW FUNCTIONS ARE DEFINED ABOVE)\n        switch (functionType.toLowerCase()) {\n            case 'analyze_opportunity':\n                return await analyzeOpportunity(analysisRequest, threshold, models, requestId);\n            case 'validate_trade':\n                return await validateTrade(analysisRequest, threshold, models, requestId);\n            case 'risk_assessment':\n                return await performRiskAssessment(analysisRequest, threshold, models, requestId);\n            case 'portfolio_review':\n                return await reviewPortfolio(analysisRequest, threshold, models, requestId);\n            case 'market_analysis':\n                return await analyzeMarket(analysisRequest, threshold, models, requestId);\n            case 'consensus_decision':\n                return await makeConsensusDecision(analysisRequest, threshold, models, requestId);\n            default:\n                throw new Error(`Unknown function: ${functionType}`);\n        }\n        \n    } catch (error) {\n        console.error(`❌ Multi AI Consensus Service [${requestId}] error:`, error);\n        return {\n            success: false,\n            error: error.message,\n            request_id: requestId,\n            timestamp: new Date().toISOString(),\n            function_attempted: functionType\n        };\n    }\n}\n\n// ===== PRODUCTION JSON SANITIZATION =====\nfunction sanitizeJsonResponse(rawResponse) {\n    if (!rawResponse || typeof rawResponse !== 'string') {\n        throw new Error('Invalid response format');\n    }\n    \n    let cleanResponse = rawResponse;\n    \n    try {\n        // Step 1: Remove markdown code blocks\n        cleanResponse = cleanResponse.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n        \n        // Step 2: Extract JSON from mixed content\n        const jsonMatch = cleanResponse.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n            cleanResponse = jsonMatch[0];\n        }\n        \n        // Step 3: Fix common JSON issues\n        cleanResponse = cleanResponse\n            .replace(/\\\\n/g, ' ')  // Replace escaped newlines\n            .replace(/\\\\t/g, ' ')  // Replace escaped tabs\n            .replace(/\\\\r/g, ' ')  // Replace escaped returns\n            .replace(/([\\\"'])([^\"']*?)(?<!\\\\)\\1/g, (match, quote, content) => {\n                // Fix unescaped quotes inside strings\n                const escapedContent = content.replace(/(?<!\\\\)\"/g, '\\\\\"').replace(/(?<!\\\\)'/g, \"\\\\'\");\n                return quote + escapedContent + quote;\n            })\n            .replace(/,\\s*}/g, '}')  // Remove trailing commas\n            .replace(/,\\s*]/g, ']'); // Remove trailing commas in arrays\n        \n        // Step 4: Handle truncated JSON\n        if (!cleanResponse.endsWith('}') && !cleanResponse.endsWith(']')) {\n            const openBraces = (cleanResponse.match(/\\{/g) || []).length;\n            const closeBraces = (cleanResponse.match(/\\}/g) || []).length;\n            const missingBraces = openBraces - closeBraces;\n            \n            for (let i = 0; i < missingBraces; i++) {\n                cleanResponse += '}';\n            }\n        }\n        \n        // Step 5: Validate JSON structure\n        JSON.parse(cleanResponse);\n        return cleanResponse;\n        \n    } catch (parseError) {\n        console.log(`⚠️ JSON sanitization failed, attempting fallback extraction...`);\n        return extractJsonFallback(rawResponse);\n    }\n}\n\nfunction extractJsonFallback(rawResponse) {\n    try {\n        // Attempt to extract partial valid JSON\n        const jsonRegex = /\\{(?:[^{}]|\\{[^{}]*\\})*\\}/g;\n        const matches = rawResponse.match(jsonRegex);\n        \n        if (matches) {\n            // Try each match until one parses successfully\n            for (const match of matches) {\n                try {\n                    JSON.parse(match);\n                    return match;\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        \n        // Last resort: create minimal valid response\n        return JSON.stringify({\n            decision: 'INSUFFICIENT_DATA',\n            confidence: 0,\n            reasoning: 'AI response could not be parsed',\n            status: 'parse_error'\n        });\n        \n    } catch (error) {\n        throw new Error(`Complete JSON parsing failure: ${error.message}`);\n    }\n}\n\n// ===== AI API CALLS WITH CIRCUIT BREAKER =====\nasync function callAIWithRetry(aiService, prompt, maxTokens = 1500) {\n    const serviceState = circuitBreaker[aiService];\n    \n    // Check circuit breaker\n    if (serviceState.isOpen) {\n        const timeSinceLastFailure = Date.now() - serviceState.lastFailure;\n        if (timeSinceLastFailure < CONFIG.CIRCUIT_BREAKER_RESET_TIME) {\n            throw new Error(`Circuit breaker open for ${aiService}`);\n        } else {\n            // Reset circuit breaker\n            serviceState.isOpen = false;\n            serviceState.failures = 0;\n        }\n    }\n    \n    for (let attempt = 1; attempt <= CONFIG.MAX_RETRIES; attempt++) {\n        try {\n            const result = await makeAIRequest(aiService, prompt, maxTokens);\n            \n            // Reset failure count on success\n            serviceState.failures = 0;\n            return result;\n            \n        } catch (error) {\n            console.log(`⚠️ ${aiService} attempt ${attempt}/${CONFIG.MAX_RETRIES} failed: ${error.message}`);\n            \n            if (attempt === CONFIG.MAX_RETRIES) {\n                // Update circuit breaker on final failure\n                serviceState.failures++;\n                serviceState.lastFailure = Date.now();\n                \n                if (serviceState.failures >= CONFIG.CIRCUIT_BREAKER_THRESHOLD) {\n                    serviceState.isOpen = true;\n                    console.log(`🔴 Circuit breaker opened for ${aiService}`);\n                }\n                \n                throw error;\n            }\n            \n            // Exponential backoff\n            const delay = CONFIG.INITIAL_RETRY_DELAY * Math.pow(2, attempt - 1);\n            await sleep(delay);\n        }\n    }\n}\n\nasync function makeAIRequest(aiService, prompt, maxTokens) {\n    const optimizedPrompt = optimizePromptLength(prompt);\n    \n    switch (aiService) {\n        case 'gpt4':\n            return await callGPT4(optimizedPrompt, maxTokens);\n        case 'claude':\n            return await callClaude(optimizedPrompt, maxTokens);\n        case 'gemini':\n            return await callGemini(optimizedPrompt, maxTokens);\n        default:\n            throw new Error(`Unknown AI service: ${aiService}`);\n    }\n}\n\nasync function callGPT4(prompt, maxTokens) {\n    if (!$vars.APIKEY_OPENAI) {\n        throw new Error('OpenAI API key not configured');\n    }\n    \n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${$vars.APIKEY_OPENAI}`,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            model: 'gpt-4',\n            messages: [\n                { role: 'system', content: 'You are an expert trading analyst. Always respond with valid JSON only.' },\n                { role: 'user', content: prompt }\n            ],\n            temperature: 0.3,\n            max_tokens: maxTokens\n        })\n    });\n    \n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`GPT-4 API error: ${response.status} - ${errorText}`);\n    }\n    \n    const data = await response.json();\n    const rawContent = data.choices[0].message.content;\n    \n    // Sanitize and parse response\n    const sanitizedJson = sanitizeJsonResponse(rawContent);\n    const parsedResponse = JSON.parse(sanitizedJson);\n    \n    return {\n        analysis: parsedResponse,\n        cost: (data.usage.total_tokens / 1000) * 0.06,\n        tokens_used: data.usage.total_tokens,\n        raw_response: rawContent.substring(0, 200)\n    };\n}\n\nasync function callClaude(prompt, maxTokens) {\n    if (!$vars.APIKEY_CLAUDE) {\n        throw new Error('Claude API key not configured');\n    }\n    \n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n        method: 'POST',\n        headers: {\n            'x-api-key': $vars.APIKEY_CLAUDE,\n            'Content-Type': 'application/json',\n            'anthropic-version': '2023-06-01'\n        },\n        body: JSON.stringify({\n            model: 'claude-3-5-sonnet-20241022',\n            max_tokens: maxTokens,\n            messages: [{\n                role: 'user',\n                content: `You are an expert trading analyst. ${prompt} Respond with valid JSON only.`\n            }]\n        })\n    });\n    \n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Claude API error: ${response.status} - ${errorText}`);\n    }\n    \n    const data = await response.json();\n    const rawContent = data.content[0].text;\n    \n    // Sanitize and parse response\n    const sanitizedJson = sanitizeJsonResponse(rawContent);\n    const parsedResponse = JSON.parse(sanitizedJson);\n    \n    return {\n        analysis: parsedResponse,\n        cost: (data.usage.input_tokens + data.usage.output_tokens) / 1000 * 0.015,\n        tokens_used: data.usage.input_tokens + data.usage.output_tokens,\n        raw_response: rawContent.substring(0, 200)\n    };\n}\n\nasync function callGemini(prompt, model, retryCount = 0) {\n    try {\n        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${$vars.GOOGLE_API_KEY}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                contents: [{\n                    parts: [{\n                        text: prompt\n                    }]\n                }],\n                generationConfig: {\n                    temperature: 0.7,\n                    topK: 40,\n                    topP: 0.95,\n                    maxOutputTokens: 2048,\n                }\n            })\n        });\n\n        if (!response.ok) {\n            throw new Error(`Gemini API HTTP error: ${response.status}`);\n        }\n\n        const data = await response.json();\n        \n        // ENHANCED: Multi-layer response parsing with fallbacks\n        return parseGeminiResponse(data);\n        \n    } catch (error) {\n        console.error(`Gemini API call failed (attempt ${retryCount + 1}):`, error.message);\n        \n        if (retryCount < 2) {\n            await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));\n            return callGemini(prompt, model, retryCount + 1);\n        }\n        \n        throw error;\n    }\n}\nfunction parseGeminiResponse(data) {\n    console.log('🔍 Parsing Gemini response structure...');\n    \n    // Strategy 1: Standard Gemini response format\n    if (data && data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0) {\n        const candidate = data.candidates[0];\n        \n        if (candidate.content && candidate.content.parts && Array.isArray(candidate.content.parts)) {\n            const textPart = candidate.content.parts.find(part => part.text);\n            if (textPart && textPart.text) {\n                return cleanAndParseGeminiText(textPart.text);\n            }\n        }\n    }\n    \n    // Strategy 2: Alternative response structure\n    if (data && data.text) {\n        return cleanAndParseGeminiText(data.text);\n    }\n    \n    // Strategy 3: Direct content extraction\n    if (data && typeof data === 'string') {\n        return cleanAndParseGeminiText(data);\n    }\n    \n    // Strategy 4: Search for any text content in the response\n    const textContent = extractAnyTextFromResponse(data);\n    if (textContent) {\n        return cleanAndParseGeminiText(textContent);\n    }\n    \n    console.warn('⚠️ No valid text content found in Gemini response:', JSON.stringify(data, null, 2));\n    throw new Error('No valid response structure found in Gemini API response');\n}\n\n// NEW: Clean and parse Gemini text with JSON extraction\nfunction cleanAndParseGeminiText(text) {\n    if (!text || typeof text !== 'string') {\n        throw new Error('Invalid text content from Gemini');\n    }\n    \n    // Remove common Gemini formatting artifacts\n    let cleanText = text\n        .replace(/```json\\s*/g, '')\n        .replace(/```\\s*/g, '')\n        .replace(/^\\s*[\"']|[\"']\\s*$/g, '')\n        .trim();\n    \n    // Try to parse as JSON first\n    try {\n        return JSON.parse(cleanText);\n    } catch (e) {\n        // Extract JSON from mixed content\n        const jsonMatch = cleanText.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n            try {\n                return JSON.parse(jsonMatch[0]);\n            } catch (e2) {\n                console.warn('⚠️ JSON extraction failed, returning raw text');\n            }\n        }\n        \n        // Return structured fallback\n        return {\n            raw_response: cleanText,\n            analysis: cleanText,\n            confidence: 50,\n            timestamp: new Date().toISOString(),\n            source: 'gemini_fallback'\n        };\n    }\n}\n\n// NEW: Extract any text content from complex response objects\nfunction extractAnyTextFromResponse(obj, depth = 0) {\n    if (depth > 3) return null; // Prevent infinite recursion\n    \n    if (typeof obj === 'string') {\n        return obj.length > 10 ? obj : null;\n    }\n    \n    if (Array.isArray(obj)) {\n        for (const item of obj) {\n            const result = extractAnyTextFromResponse(item, depth + 1);\n            if (result) return result;\n        }\n    }\n    \n    if (obj && typeof obj === 'object') {\n        // Check common text fields\n        const textFields = ['text', 'content', 'message', 'response', 'output', 'result'];\n        for (const field of textFields) {\n            if (obj[field]) {\n                const result = extractAnyTextFromResponse(obj[field], depth + 1);\n                if (result) return result;\n            }\n        }\n        \n        // Recursively search all properties\n        for (const [key, value] of Object.entries(obj)) {\n            const result = extractAnyTextFromResponse(value, depth + 1);\n            if (result) return result;\n        }\n    }\n    \n    return null;\n}\n\n// ===== UTILITY FUNCTIONS =====\nfunction generateRequestId() {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n}\n\nfunction optimizePromptLength(prompt) {\n    if (prompt.length <= CONFIG.MAX_RESPONSE_LENGTH) {\n        return prompt;\n    }\n    \n    // Truncate prompt while preserving structure\n    const lines = prompt.split('\\n');\n    let optimizedPrompt = '';\n    \n    for (const line of lines) {\n        if (optimizedPrompt.length + line.length > CONFIG.MAX_RESPONSE_LENGTH) {\n            break;\n        }\n        optimizedPrompt += line + '\\n';\n    }\n    \n    return optimizedPrompt + '\\n[Prompt truncated for optimization]';\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Execute the function with safe parameter handling\nreturn await multiAIConsensusService(\n    $function, \n    $analysis_request,\n    (typeof $confidence_threshold !== 'undefined') ? $confidence_threshold : null,\n    (typeof $ai_models !== 'undefined') ? $ai_models : null\n);",
  "workspaceId": "9b1b9829-f76f-472f-867f-4bac66fb62c0"
}