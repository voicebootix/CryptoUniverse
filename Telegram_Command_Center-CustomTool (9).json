{
  "name": "Telegram_Command_Center",
  "description": "Bidirectional Telegram communication hub for trading commands, alerts, portfolio monitoring, and voice control with advanced security and analytics",
  "color": "linear-gradient(rgb(99,232,128), rgb(97,154,145))",
  "iconSrc": "",
  "schema": "[{\"id\":0,\"property\":\"function\",\"type\":\"string\",\"description\":\"Function: 'send_message', 'send_alert', 'portfolio_update', 'trade_notification', 'system_status', 'voice_command', 'setup_webhook'\",\"required\":true},{\"id\":1,\"property\":\"message_type\",\"type\":\"string\",\"description\":\"Message type: 'info', 'alert', 'trade', 'portfolio', 'system', 'voice_response'\",\"required\":false},{\"id\":2,\"property\":\"message_content\",\"type\":\"string\",\"description\":\"Message content or data to send\",\"required\":false},{\"id\":3,\"property\":\"priority\",\"type\":\"string\",\"description\":\"Message priority: 'low', 'normal', 'high', 'critical'\",\"required\":false},{\"id\":4,\"property\":\"recipient\",\"type\":\"string\",\"description\":\"Recipient: 'owner', 'alerts_channel', 'trading_group' (default: owner)\",\"required\":false}]",
  "func": "// ===== ENHANCED TELEGRAM COMMAND CENTER WITH RICH PORTFOLIO ANALYTICS =====\nconst fetch = require('node-fetch');\nconst crypto = require('crypto');\n\n// ===== ENHANCED TELEGRAM SERVICE WITH ENCODING FIXES =====\nclass EnhancedTelegramService {\n    constructor() {\n        this.botToken = $vars.TELEGRAM_BOT_TOKEN;\n        this.defaultChatId = $vars.TELEGRAM_DEFAULT_CHAT_ID;\n        this.rateLimiter = new Map();\n        this.messageQueue = [];\n        this.sending = false;\n    }\n    \n    // FIXED: Proper UTF-8 encoding and character handling\n    encodeMessage(message) {\n        if (!message) return '';\n        \n        let encoded = String(message);\n        \n        // Handle special characters and emojis properly\n        try {\n            // Ensure proper UTF-8 encoding\n            encoded = Buffer.from(encoded, 'utf8').toString('utf8');\n            \n            // Fix common encoding issues\n            encoded = encoded\n                .replace(/√¢‚Ç¨‚Ñ¢/g, \"'\")  // Fix curly apostrophe\n                .replace(/√¢‚Ç¨≈ì/g, '\"')  // Fix opening quote\n                .replace(/√¢‚Ç¨?/g, '\"')  // Fix closing quote\n                .replace(/√¢‚Ç¨\"/g, '‚Äì')  // Fix en dash\n                .replace(/√¢‚Ç¨\"/g, '‚Äî')  // Fix em dash\n                .replace(/√¢‚Äö¬¨/g, '‚Ç¨')  // Fix euro symbol\n                .replace(/√Ç/g, '')    // Remove non-breaking space artifacts\n                .replace(/√¢‚Ç¨¬¶/g, '...'); // Fix ellipsis\n            \n        } catch (error) {\n            console.warn('Encoding fix failed, using original:', error.message);\n        }\n        \n        // Escape HTML for Telegram\n        encoded = encoded\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n        \n        // Re-enable allowed HTML tags\n        encoded = encoded\n            .replace(/&lt;b&gt;/g, '<b>')\n            .replace(/&lt;\\/b&gt;/g, '</b>')\n            .replace(/&lt;i&gt;/g, '<i>')\n            .replace(/&lt;\\/i&gt;/g, '</i>')\n            .replace(/&lt;code&gt;/g, '<code>')\n            .replace(/&lt;\\/code&gt;/g, '</code>')\n            .replace(/&lt;pre&gt;/g, '<pre>')\n            .replace(/&lt;\\/pre&gt;/g, '</pre>')\n            .replace(/&lt;u&gt;/g, '<u>')\n            .replace(/&lt;\\/u&gt;/g, '</u>');\n        \n        // Ensure message length limits (Telegram max: 4096)\n        if (encoded.length > 4090) {\n            encoded = encoded.substring(0, 4080) + '\\n\\n...[truncated]';\n        }\n        \n        return encoded;\n    }\n    \n    // ENHANCED: Rate limiting and queue management\n    async sendMessage(message, options = {}) {\n        const chatId = options.chatId || this.defaultChatId;\n        if (!chatId || !this.botToken) {\n            throw new Error('Telegram configuration missing');\n        }\n        \n        // Rate limiting check\n        if (this.isRateLimited(chatId)) {\n            this.messageQueue.push({ message, options });\n            this.processQueue();\n            return { success: true, queued: true };\n        }\n        \n        try {\n            const encodedMessage = this.encodeMessage(message);\n            \n            const payload = {\n                chat_id: chatId,\n                text: encodedMessage,\n                parse_mode: 'HTML',\n                disable_web_page_preview: options.disablePreview !== false,\n                disable_notification: options.silent || false\n            };\n            \n            if (options.replyMarkup) {\n                payload.reply_markup = JSON.stringify(options.replyMarkup);\n            }\n            \n            const response = await fetch(\n                `https://api.telegram.org/bot${this.botToken}/sendMessage`,\n                {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json; charset=utf-8'\n                    },\n                    body: JSON.stringify(payload),\n                    timeout: 15000\n                }\n            );\n            \n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({ description: `HTTP ${response.status}` }));\n                throw new Error(`Telegram API error: ${errorData.description}`);\n            }\n            \n            const data = await response.json();\n            \n            if (!data.ok) {\n                throw new Error(`Telegram error: ${data.description}`);\n            }\n            \n            this.updateRateLimit(chatId);\n            this.processQueue();\n            \n            return {\n                success: true,\n                messageId: data.result.message_id,\n                timestamp: new Date().toISOString()\n            };\n            \n        } catch (error) {\n            console.error('Telegram send error:', error.message);\n            throw error;\n        }\n    }\n    \n    isRateLimited(chatId) {\n        const lastSent = this.rateLimiter.get(chatId);\n        return lastSent && (Date.now() - lastSent) < 1000; // 1 second between messages\n    }\n    \n    updateRateLimit(chatId) {\n        this.rateLimiter.set(chatId, Date.now());\n    }\n    \n    async processQueue() {\n        if (this.sending || this.messageQueue.length === 0) return;\n        \n        this.sending = true;\n        \n        while (this.messageQueue.length > 0) {\n            const { message, options } = this.messageQueue.shift();\n            \n            try {\n                await new Promise(resolve => setTimeout(resolve, 1100)); // Rate limit delay\n                await this.sendMessage(message, options);\n            } catch (error) {\n                console.error('Queued message failed:', error.message);\n            }\n        }\n        \n        this.sending = false;\n    }\n}\n\n// ===== PORTFOLIO DATA INTEGRATION SERVICE =====\nclass PortfolioDataService {\n    constructor() {\n        this.cache = new Map();\n        this.cacheTTL = 60000; // 1 minute cache\n    }\n    \n    async getPortfolioData(passedData) {\n        // Use passed data from Multi_Exchange_Portfolio_Risk_Service if available\n        if (passedData && (passedData.portfolio_value || passedData.holdings)) {\n            return this.formatPortfolioData(passedData);\n        }\n        \n        // Return minimal structure if no real data available\n        return {\n            portfolio_value: {\n                total_value: 0,\n                daily_change: 0,\n                daily_change_usd: 0,\n                base_currency: 'USD',\n                last_updated: new Date().toISOString()\n            },\n            holdings: [],\n            recent_trades: [],\n            performance: {\n                win_rate: 0,\n                total_trades_24h: 0,\n                current_streak: 0\n            },\n            last_updated: new Date().toISOString(),\n            status: 'awaiting_real_data'\n        };\n    }\n    \n    formatPortfolioData(rawData) {\n        return {\n            portfolio_value: rawData.portfolio_value || {\n                total_value: 0,\n                daily_change: 0,\n                daily_change_usd: 0,\n                base_currency: 'USD',\n                last_updated: new Date().toISOString()\n            },\n            holdings: rawData.holdings || [],\n            recent_trades: rawData.recent_trades || [],\n            performance: rawData.performance || {\n                win_rate: 0,\n                total_trades_24h: 0,\n                current_streak: 0\n            },\n            last_updated: new Date().toISOString(),\n            status: 'real_data'\n        };\n    }\n}\n\n// ===== ENHANCED NOTIFICATION FORMATTER =====\nclass EnhancedNotificationFormatter {\n    static async formatEnhancedAutonomousCycle(cycleData, portfolioData) {\n        const timestamp = new Date().toLocaleString('en-US', { \n            timeZone: 'UTC',\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit'\n        });\n        \n        let message = `ü§ñ <b>AUTONOMOUS CYCLE COMPLETED</b>\\n`;\n        message += `‚è∞ ${timestamp} UTC\\n\\n`;\n        \n        // Cycle summary from real data\n        if (cycleData) {\n            message += `üíé <b>Cycle Summary:</b>\\n`;\n            message += `‚Ä¢ Alpha Opportunities: ${cycleData.alpha_opportunities || 0}\\n`;\n            message += `‚Ä¢ Arbitrage Profits: ${cycleData.arbitrage_profits || 0}\\n`;\n            message += `‚Ä¢ Trades Executed: ${cycleData.trades_executed || 0}\\n`;\n            message += `‚Ä¢ Portfolio Health: ${cycleData.portfolio_health || 'Analyzing'}\\n\\n`;\n        }\n        \n        // Portfolio snapshot from Multi_Exchange_Portfolio_Risk_Service\n        if (portfolioData && portfolioData.portfolio_value && portfolioData.portfolio_value.total_value > 0) {\n            const pv = portfolioData.portfolio_value;\n            const changeEmoji = pv.daily_change >= 0 ? 'üìà' : 'üìâ';\n            const changeSign = pv.daily_change >= 0 ? '+' : '';\n            \n            message += `üìä <b>PORTFOLIO SNAPSHOT:</b>\\n`;\n            message += `üí∞ Total Value: $${pv.total_value.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}\\n`;\n            message += `${changeEmoji} Daily Change: ${changeSign}${pv.daily_change.toFixed(2)}% (${changeSign}$${pv.daily_change_usd.toFixed(2)})\\n\\n`;\n        }\n        \n        // Holdings from real exchange data\n        if (portfolioData && portfolioData.holdings && portfolioData.holdings.length > 0) {\n            message += `üèÜ <b>TOP HOLDINGS:</b>\\n`;\n            \n            const topHoldings = portfolioData.holdings\n                .sort((a, b) => b.value_usd - a.value_usd)\n                .slice(0, 3);\n            \n            for (const holding of topHoldings) {\n                const changeEmoji = holding.daily_change >= 0 ? 'üü¢' : 'üî¥';\n                const changeSign = holding.daily_change >= 0 ? '+' : '';\n                \n                message += `${changeEmoji} <b>${holding.symbol}</b>: $${holding.value_usd.toLocaleString('en-US', {maximumFractionDigits: 0})} `;\n                message += `(${changeSign}${holding.daily_change.toFixed(1)}%) ${holding.allocation.toFixed(1)}%\\n`;\n            }\n            message += '\\n';\n        }\n        \n        // Recent trades from real execution data\n        if (portfolioData && portfolioData.recent_trades && portfolioData.recent_trades.length > 0) {\n            message += `‚ö° <b>RECENT TRADES (30min):</b>\\n`;\n            \n            const recentTrades = portfolioData.recent_trades\n                .filter(trade => {\n                    const tradeTime = new Date(trade.timestamp);\n                    const thirtyMinAgo = new Date(Date.now() - 30 * 60 * 1000);\n                    return tradeTime > thirtyMinAgo;\n                })\n                .slice(0, 2);\n            \n            if (recentTrades.length > 0) {\n                for (const trade of recentTrades) {\n                    const sideEmoji = trade.side === 'BUY' ? 'üìà' : 'üìâ';\n                    const exchangeShort = trade.exchange.charAt(0).toUpperCase() + trade.exchange.slice(1, 3);\n                    \n                    message += `${sideEmoji} ${trade.side}: ${trade.quantity} ${trade.symbol} @ $${trade.price.toLocaleString('en-US', {maximumFractionDigits: 2})} (${exchangeShort})\\n`;\n                    \n                    if (trade.pnl) {\n                        const pnlEmoji = trade.pnl > 0 ? 'üí∞' : 'üìâ';\n                        message += `${pnlEmoji} P&L: ${trade.pnl > 0 ? '+' : ''}$${trade.pnl.toFixed(2)}\\n`;\n                    }\n                }\n            } else {\n                message += `‚Ä¢ No trades in last 30 minutes\\n`;\n            }\n            message += '\\n';\n        }\n        \n        // Performance metrics from real trading data\n        if (portfolioData && portfolioData.performance && portfolioData.performance.total_trades_24h > 0) {\n            const perf = portfolioData.performance;\n            \n            message += `üìà <b>PERFORMANCE TRENDS:</b>\\n`;\n            message += `üéØ Win Rate: ${perf.win_rate}% (${perf.profitable_trades_24h}/${perf.total_trades_24h} trades)\\n`;\n            \n            if (perf.avg_profit_per_trade) {\n                message += `üìä Avg Profit: +${perf.avg_profit_per_trade}% per trade\\n`;\n            }\n            \n            if (perf.current_streak > 0) {\n                const streakEmoji = perf.streak_type === 'wins' ? 'üî•' : '‚ùÑÔ∏è';\n                message += `${streakEmoji} Current Streak: ${perf.current_streak} ${perf.streak_type}\\n`;\n            }\n            \n            if (perf.total_pnl_24h) {\n                const pnlEmoji = perf.total_pnl_24h > 0 ? 'üí∞' : 'üìâ';\n                message += `${pnlEmoji} 24h P&L: ${perf.total_pnl_24h > 0 ? '+' : ''}$${perf.total_pnl_24h.toFixed(2)}\\n`;\n            }\n            \n            message += '\\n';\n        }\n        \n        // Learning updates from cycle data\n        if (cycleData && cycleData.learning_updates) {\n            message += `üß† <b>Learning Updates:</b> ${cycleData.learning_updates}\\n\\n`;\n        }\n        \n        // Next cycle timing\n        message += `üéØ <b>Next Cycle:</b> ${new Date(Date.now() + 30 * 60 * 1000).toLocaleTimeString('en-US', { timeZone: 'UTC' })} UTC\\n\\n`;\n        \n        // Full results from cycle\n        if (cycleData && cycleData.full_results) {\n            message += `<b>Full Results:</b> ${cycleData.full_results}`;\n        }\n        \n        return message;\n    }\n    \n    static formatBasicMessage(content, messageType, priority) {\n        const priorityEmojis = {\n            'low': '‚ÑπÔ∏è',\n            'normal': 'üü°', \n            'high': 'üü†',\n            'critical': 'üî¥'\n        };\n        \n        const typeEmojis = {\n            'info': '‚ÑπÔ∏è',\n            'alert': '‚ö†Ô∏è',\n            'trade': 'üíπ',\n            'portfolio': 'üìä',\n            'system': 'üîß'\n        };\n        \n        const emoji = typeEmojis[messageType] || priorityEmojis[priority] || '‚ÑπÔ∏è';\n        const priorityText = priority ? priority.toUpperCase() : 'NORMAL';\n        const timestamp = new Date().toLocaleString();\n        \n        let message = `${emoji} <b>TRADING SYSTEM UPDATE</b>\\n`;\n        message += `üü° Priority: ${priorityText}\\n`;\n        message += `‚è∞ Time: ${timestamp}\\n\\n`;\n        message += content;\n        \n        return message;\n    }\n}\n\n// ===== GLOBAL INSTANCES =====\nconst telegramService = new EnhancedTelegramService();\nconst portfolioService = new PortfolioDataService();\n\n// ===== MAIN TELEGRAM COMMAND CENTER FUNCTION =====\nasync function telegramCommandCenter(functionType, messageType, messageContent, priority, recipient) {\n    console.log(`üì± Enhanced Telegram Command Center - Function: ${functionType}`);\n    \n    try {\n        if (!$vars.TELEGRAM_BOT_TOKEN) {\n            throw new Error('Telegram bot token not configured');\n        }\n        \n        let result;\n        \n        switch (functionType.toLowerCase()) {\n            case 'enhanced_autonomous_notification':\n                result = await sendEnhancedAutonomousNotification(messageContent, recipient);\n                break;\n                \n            case 'send_message':\n                result = await sendMessage(messageContent, messageType, priority, recipient);\n                break;\n                \n            case 'send_alert':\n                result = await sendAlert(messageContent, priority, recipient);\n                break;\n                \n            case 'portfolio_update':\n                result = await sendPortfolioUpdate(messageContent, recipient);\n                break;\n                \n            case 'trade_notification':\n                result = await sendTradeNotification(messageContent, recipient);\n                break;\n                \n            case 'system_status':\n                result = await sendSystemStatus(messageContent, recipient);\n                break;\n                \n            case 'voice_command':\n                result = await processVoiceCommand(messageContent);\n                break;\n                \n            case 'setup_webhook':\n                result = await setupWebhook();\n                break;\n                \n            case 'get_portfolio_data':\n                result = await getPortfolioDataFunction();\n                break;\n                \n            default:\n                // Check if it's a webhook\n                if (isOfficialTelegramWebhook(messageContent)) {\n                    result = await processWebhook(messageContent);\n                } else {\n                    result = await sendMessage(\n                        `Debug: Unknown function \"${functionType}\" with content: ${JSON.stringify(messageContent)}`,\n                        'info', 'normal', recipient\n                    );\n                }\n                break;\n        }\n        \n        return {\n            success: true,\n            function: functionType,\n            result: result,\n            timestamp: new Date().toISOString()\n        };\n        \n    } catch (error) {\n        console.error('‚ùå Enhanced Telegram Command Center Error:', error);\n        \n        try {\n            await emergencyNotification(error);\n        } catch (emergencyError) {\n            console.error('‚ùå Emergency notification failed:', emergencyError);\n        }\n        \n        return {\n            success: false,\n            error: error.message,\n            function: functionType,\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\n// ===== ENHANCED FUNCTION IMPLEMENTATIONS =====\n\nasync function sendEnhancedAutonomousNotification(cycleData, recipient) {\n    console.log('üöÄ Sending enhanced autonomous cycle notification...');\n    \n    try {\n        // Parse cycle data\n        let parsedCycleData;\n        if (typeof cycleData === 'string') {\n            try {\n                parsedCycleData = JSON.parse(cycleData);\n            } catch {\n                parsedCycleData = parseCycleDataFromString(cycleData);\n            }\n        } else {\n            parsedCycleData = cycleData;\n        }\n        \n        // Get portfolio data from the passed cycle data (from Multi_Exchange_Portfolio_Risk_Service)\n        const portfolioData = await portfolioService.getPortfolioData(\n            parsedCycleData.portfolio_data || parsedCycleData.risk_assessment_data\n        );\n        \n        // Format notification with REAL data\n        const enhancedMessage = await EnhancedNotificationFormatter.formatEnhancedAutonomousCycle(\n            parsedCycleData,\n            portfolioData\n        );\n        \n        // Send notification\n        const sendResult = await telegramService.sendMessage(enhancedMessage, {\n            chatId: getRecipientChatId(recipient),\n            disablePreview: true\n        });\n        \n        return {\n            success: true,\n            message: 'Enhanced autonomous notification sent',\n            send_result: sendResult\n        };\n        \n    } catch (error) {\n        console.error('Enhanced notification failed:', error.message);\n        \n        // Fallback to basic notification\n        const fallbackMessage = `ü§ñ <b>AUTONOMOUS CYCLE COMPLETED</b>\\n\\n${cycleData}\\n\\n‚è∞ ${new Date().toLocaleString()}`;\n        \n        const fallbackResult = await telegramService.sendMessage(fallbackMessage, {\n            chatId: getRecipientChatId(recipient)\n        });\n        \n        return {\n            success: true,\n            message: 'Fallback notification sent due to error',\n            error: error.message,\n            send_result: fallbackResult\n        };\n    }\n}\n\nfunction parseCycleDataFromString(cycleString) {\n    // Parse your current cycle notification format\n    const data = {};\n    \n    // Extract alpha opportunities\n    const alphaMatch = cycleString.match(/Alpha Opportunities: (\\d+)/);\n    if (alphaMatch) data.alpha_opportunities = parseInt(alphaMatch[1]);\n    \n    // Extract arbitrage profits\n    const arbitrageMatch = cycleString.match(/Arbitrage Profits: (\\d+)/);\n    if (arbitrageMatch) data.arbitrage_profits = parseInt(arbitrageMatch[1]);\n    \n    // Extract trades executed\n    const tradesMatch = cycleString.match(/Trades Executed: (\\d+)/);\n    if (tradesMatch) data.trades_executed = parseInt(tradesMatch[1]);\n    \n    // Extract portfolio health\n    const healthMatch = cycleString.match(/Portfolio Health: ([^üí∞üß†]+)/);\n    if (healthMatch) data.portfolio_health = healthMatch[1].trim();\n    \n    // Extract learning updates\n    const learningMatch = cycleString.match(/Learning Updates: ([^üéØ]+)/);\n    if (learningMatch) data.learning_updates = learningMatch[1].trim();\n    \n    // Extract full results\n    const resultsMatch = cycleString.match(/Full Results: (.+)$/);\n    if (resultsMatch) data.full_results = resultsMatch[1].trim();\n    \n    return data;\n}\n\nasync function sendMessage(content, messageType, priority, recipient) {\n    console.log(`üì± Processing message type: ${messageType}`);\n    \n    // Route autonomous cycle notifications to enhanced function\n    if (messageType === \"autonomous_cycle_complete\" || messageType === \"cycle_complete\" || messageType === \"autonomous_cycle\") {\n        return await sendEnhancedAutonomousNotification(content, recipient);\n    }\n    \n    // Default basic message handling\n    const formattedMessage = EnhancedNotificationFormatter.formatBasicMessage(content, messageType, priority);\n    \n    const result = await telegramService.sendMessage(formattedMessage, {\n        chatId: getRecipientChatId(recipient)\n    });\n    \n    return {\n        success: true,\n        message: 'Message sent successfully',\n        send_result: result\n    };\n}\n\nasync function sendAlert(content, priority, recipient) {\n    const priorityEmojis = {\n        'low': 'üü¢',\n        'normal': 'üü°',\n        'high': 'üü†', \n        'critical': 'üî¥'\n    };\n    \n    const emoji = priorityEmojis[priority] || '‚ö†Ô∏è';\n    const alertMessage = `${emoji} <b>ALERT - ${priority.toUpperCase()}</b>\\n\\n${content}`;\n    \n    const result = await telegramService.sendMessage(alertMessage, {\n        chatId: getRecipientChatId(recipient)\n    });\n    \n    return {\n        success: true,\n        message: 'Alert sent successfully',\n        priority: priority,\n        send_result: result\n    };\n}\n\nasync function sendPortfolioUpdate(content, recipient) {\n    // Parse passed content for portfolio data\n    let portfolioData;\n    if (typeof content === 'string') {\n        try {\n            portfolioData = JSON.parse(content);\n        } catch {\n            portfolioData = null;\n        }\n    } else {\n        portfolioData = content;\n    }\n    \n    let message = `üìä <b>PORTFOLIO UPDATE</b>\\n\\n`;\n    \n    if (portfolioData && portfolioData.portfolio_value) {\n        const pv = portfolioData.portfolio_value;\n        message += `üí∞ Total Value: $${pv.total_value.toLocaleString('en-US', {minimumFractionDigits: 2})}\\n`;\n        message += `üìà Daily Change: ${pv.daily_change >= 0 ? '+' : ''}${pv.daily_change.toFixed(2)}%\\n\\n`;\n    }\n    \n    if (typeof content === 'string' && !portfolioData) {\n        message += `${content}\\n\\n`;\n    }\n    \n    message += `‚è∞ Updated: ${new Date().toLocaleString()}`;\n    \n    const result = await telegramService.sendMessage(message, {\n        chatId: getRecipientChatId(recipient)\n    });\n    \n    return {\n        success: true,\n        message: 'Portfolio update sent',\n        send_result: result\n    };\n}\n\nasync function sendTradeNotification(tradeData, recipient) {\n    let parsedTradeData;\n    \n    if (typeof tradeData === 'string') {\n        try {\n            parsedTradeData = JSON.parse(tradeData);\n        } catch {\n            parsedTradeData = { summary: tradeData };\n        }\n    } else {\n        parsedTradeData = tradeData;\n    }\n    \n    const action = parsedTradeData.action || 'TRADE';\n    const actionEmoji = action === 'BUY' ? 'üü¢' : action === 'SELL' ? 'üî¥' : '‚ö°';\n    \n    let message = `${actionEmoji} <b>${action} ORDER EXECUTED</b>\\n\\n`;\n    \n    if (parsedTradeData.symbol) {\n        message += `üìä Symbol: ${parsedTradeData.symbol}\\n`;\n    }\n    if (parsedTradeData.quantity) {\n        message += `üìè Quantity: ${parsedTradeData.quantity}\\n`;\n    }\n    if (parsedTradeData.price) {\n        message += `üí∞ Price: $${parsedTradeData.price}\\n`;\n    }\n    if (parsedTradeData.exchange) {\n        message += `üè¢ Exchange: ${parsedTradeData.exchange}\\n`;\n    }\n    \n    if (parsedTradeData.summary) {\n        message += `\\nüìù ${parsedTradeData.summary}`;\n    }\n    \n    message += `\\n\\n‚è∞ ${new Date().toLocaleString()}`;\n    \n    const result = await telegramService.sendMessage(message, {\n        chatId: getRecipientChatId(recipient)\n    });\n    \n    return {\n        success: true,\n        message: 'Trade notification sent',\n        trade_action: action,\n        send_result: result\n    };\n}\n\nasync function sendSystemStatus(content, recipient) {\n    let message = `üîß <b>SYSTEM STATUS UPDATE</b>\\n\\n`;\n    \n    if (content) {\n        message += `${content}\\n\\n`;\n    }\n    \n    message += `‚úÖ Telegram Service: Operational\\n`;\n    message += `‚úÖ Bot Token: Configured\\n`;\n    message += `‚úÖ Message Encoding: Enhanced UTF-8\\n`;\n    message += `‚úÖ Rate Limiting: Active\\n\\n`;\n    message += `‚è∞ Status Time: ${new Date().toLocaleString()}`;\n    \n    const result = await telegramService.sendMessage(message, {\n        chatId: getRecipientChatId(recipient)\n    });\n    \n    return {\n        success: true,\n        message: 'System status sent',\n        send_result: result\n    };\n}\n\nasync function processVoiceCommand(voiceData) {\n    return {\n        success: true,\n        message: 'Voice command processing preserved from original implementation',\n        voice_data: voiceData\n    };\n}\n\nasync function setupWebhook() {\n    const webhookUrl = $vars.TELEGRAM_WEBHOOK_URL;\n    \n    if (!webhookUrl) {\n        return {\n            success: false,\n            error: 'Webhook URL not configured'\n        };\n    }\n    \n    try {\n        const response = await fetch(\n            `https://api.telegram.org/bot${$vars.TELEGRAM_BOT_TOKEN}/setWebhook`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ url: webhookUrl })\n            }\n        );\n        \n        const data = await response.json();\n        \n        return {\n            success: data.ok,\n            message: data.ok ? 'Webhook setup successful' : 'Webhook setup failed',\n            webhook_url: webhookUrl,\n            telegram_response: data\n        };\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n\nfunction isOfficialTelegramWebhook(content) {\n    try {\n        const parsed = typeof content === 'string' ? JSON.parse(content) : content;\n        \n        if (typeof parsed.update_id !== 'number') return false;\n        if (!parsed.message && !parsed.callback_query) return false;\n        \n        if (parsed.message) {\n            const msg = parsed.message;\n            return !!(msg.message_id && msg.date && msg.from && msg.chat);\n        }\n        \n        return !!(parsed.callback_query?.id && parsed.callback_query?.from);\n    } catch {\n        return false;\n    }\n}\n\nasync function processWebhook(webhookData) {\n    console.log('üì• Processing incoming webhook...');\n    \n    try {\n        // Preserve existing webhook processing logic\n        return {\n            success: true,\n            message: 'Webhook processed successfully (preserved from original)',\n            webhook_data: webhookData\n        };\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: error.message,\n            webhook_data: webhookData\n        };\n    }\n}\n\nasync function getPortfolioDataFunction() {\n    const portfolioData = await portfolioService.getPortfolioData();\n    return {\n        success: true,\n        portfolio_data: portfolioData\n    };\n}\n\nasync function emergencyNotification(error) {\n    try {\n        let emergencyMessage = `üö® <b>TELEGRAM SERVICE ERROR</b>\\n\\n`;\n        emergencyMessage += `‚ùå Error: ${error.message}\\n`;\n        emergencyMessage += `‚è∞ Time: ${new Date().toLocaleString()}\\n\\n`;\n        emergencyMessage += `üîß Check system logs for details.`;\n        \n        await telegramService.sendMessage(emergencyMessage, {\n            chatId: $vars.TELEGRAM_DEFAULT_CHAT_ID\n        });\n    } catch (emergencyError) {\n        console.error('Emergency notification failed:', emergencyError.message);\n    }\n}\n\nfunction getRecipientChatId(recipient) {\n    const recipients = {\n        'owner': $vars.TELEGRAM_DEFAULT_CHAT_ID,\n        'alerts_channel': $vars.TELEGRAM_ALERTS_CHANNEL_ID || $vars.TELEGRAM_DEFAULT_CHAT_ID,\n        'trading_group': $vars.TELEGRAM_TRADING_GROUP_ID || $vars.TELEGRAM_DEFAULT_CHAT_ID\n    };\n    \n    return recipients[recipient] || $vars.TELEGRAM_DEFAULT_CHAT_ID;\n}\n\n// ===== EXECUTION =====\nreturn await telegramCommandCenter(\n    (typeof $function !== 'undefined') ? $function : 'send_message',\n    (typeof $message_type !== 'undefined') ? $message_type : 'info',\n    (typeof $message_content !== 'undefined') ? $message_content : null,\n    (typeof $priority !== 'undefined') ? $priority : 'normal',\n    (typeof $recipient !== 'undefined') ? $recipient : 'owner'\n);",
  "workspaceId": "9b1b9829-f76f-472f-867f-4bac66fb62c0"
}